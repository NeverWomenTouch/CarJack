--!nocheck
-- luacheck: globals cloneref isfile isfolder makefolder writefile readfile listfiles delfile Color3 Enum game UDim2 Vector2 Rect
local cloneref = cloneref or function(x) return x end
local function SRV(name) return cloneref(game:GetService(name)) end
local CoreGui = SRV("CoreGui")
local TweenService = SRV("TweenService")
local TextService = SRV("TextService")
local UserInputService = SRV("UserInputService")
local ContextActionService = SRV("ContextActionService")
local HttpService = SRV("HttpService")
local MarketplaceService = SRV("MarketplaceService")
local _isfile = (isfile or function() return false end)
local _isfolder = (isfolder or function() return false end)
local _makefolder = (makefolder or function() end)
local _writefile = (writefile or function() end)
local _readfile = (readfile or function() return "" end)
local _listfiles = (listfiles or function() return {} end)
local _delfile = (delfile or function() end)
local function Create(className, props, children)
    local inst = Instance.new(className)
    if props then for k, v in pairs(props) do inst[k] = v end end
    if children then for _, c in ipairs(children) do c.Parent = inst end end
    return inst
end
local function Round(num, inc) inc = inc or 1 return math.floor(num / inc + 0.5) * inc end
local function Clamp(v, a, b) return (v < a and a) or (v > b and b) or v end
local Theme = {
    Bg = Color3.fromRGB(12, 14, 13),
    Panel = Color3.fromRGB(18, 20, 19),
    Stroke = Color3.fromRGB(34, 38, 36),
    Accent = Color3.fromRGB(0, 255, 170),
    Accent2 = Color3.fromRGB(0, 220, 150),
    Text = Color3.fromRGB(235, 238, 236),
    SubText = Color3.fromRGB(158, 165, 160),
    Hover = Color3.fromRGB(32, 36, 34),
    Button = Color3.fromRGB(26, 28, 27),
    Good = Color3.fromRGB(0, 255, 170),
    Warn = Color3.fromRGB(240, 180, 70),
    Bad = Color3.fromRGB(235, 80, 90),
    Scrollbar = Color3.fromRGB(50, 54, 52),
}
local Fonts = {
    Regular = Enum.Font.Gotham,
    Medium = Enum.Font.GothamMedium,
    Bold = Enum.Font.GothamBold,
}
local function T(i, t, p) return TweenService:Create(i, TweenInfo.new(t, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), p) end
local Config = {}
do
    local function sanitize(s) s = tostring(s or "Game"); s = s:gsub("[^%w%s%-_]", "_"); s = s:gsub("%s+", "_"); return s end
    local function gameKey()
        local ok, info = pcall(function() return MarketplaceService:GetProductInfo(game.PlaceId) end)
        if ok and info and info.Name and #info.Name > 0 then return sanitize(info.Name) end
        return "Place_" .. tostring(game.PlaceId)
    end
    local Base = "DendriteUI"
    local Folder = Base .. "/" .. gameKey()
    function Config.Ensure() if not _isfolder(Base) then _makefolder(Base) end if not _isfolder(Folder) then _makefolder(Folder) end end
    function Config.Path(n) Config.Ensure() return Folder .. "/" .. sanitize(n) .. ".json" end
    function Config.Save(n, d) local p = Config.Path(n) local ok, j = pcall(function() return HttpService:JSONEncode(d or {}) end) if ok then _writefile(p, j) end return ok end
    function Config.Load(n) local p = Config.Path(n) if _isfile(p) then local ok, t = pcall(function() return HttpService:JSONDecode(_readfile(p)) end) if ok and type(t)=="table" then return t end end return {} end
    function Config.List() Config.Ensure() local r = {} for _, f in ipairs(_listfiles(Folder) or {}) do local n = f:match("([^/\\]+)$") or f n = n:gsub("%.json$", "") table.insert(r, n) end table.sort(r) return r end
    function Config.Delete(n) local p = Config.Path(n) if _isfile(p) then _delfile(p) end end
end
local function Signal()
    local h = {}
    return {
        Connect = function(_, fn)
            local c = {Connected = true}
            h[#h+1] = {fn = fn, c = c}
            function c:Disconnect() self.Connected = false end
            return c
        end,
        Fire = function(_, ...)
            for i=1,#h do local x=h[i]; if x.c.Connected then coroutine.wrap(x.fn)(...) end end
        end
    }
end
local Library = { _windows = {}, _controls = {}, _theme = Theme, _fonts = Fonts, _version = "3.1.0", _searchEntries = {}, Flags = {} }
-- stronger pre-destroy: remove ANY ScreenGui named DendriteUI before creating new root
do
    for _, child in ipairs(CoreGui:GetChildren()) do
        if child:IsA("ScreenGui") and child.Name == "DendriteUI" then
            pcall(function() child:Destroy() end)
        end
    end
end
local RootGui = (function()
    local g = Create("ScreenGui", {Name = "DendriteUI", ZIndexBehavior = Enum.ZIndexBehavior.Sibling, IgnoreGuiInset = true, ResetOnSpawn = false, DisplayOrder = 999999, Parent = CoreGui})
    return g
end)()
function Library:_registerControl(c)
    self._controls[c.id] = c
    -- If the control id is a simple flag (no path separators), expose via Library.Flags
    if type(c.id) == "string" and not string.find(c.id, "/", 1, true) then
        self.Flags[c.id] = c
    end
end
function Library:_setValue(id, v, s) local c = self._controls[id]; if c and c.Set then c:Set(v, s) end end
function Library:_getSnapshot() local d = {} for id, c in pairs(self._controls) do if c.Get then d[id] = c:Get() end end return d end
function Library:SaveConfig(n) return Config.Save(n, self:_getSnapshot()) end
function Library:LoadConfig(n) local t = Config.Load(n) for id, v in pairs(t) do self:_setValue(id, v, true) end end
function Library:ListConfigs() return Config.List() end

function Library:CreateLibrary(opts)
    -- destroy previous instance windows if any (singleton behavior)
    if self._singletonRoot and self._singletonRoot.Parent then
        pcall(function()
            for _, child in ipairs(self._singletonRoot:GetChildren()) do child:Destroy() end
            self._singletonRoot:Destroy()
        end)
    end
    -- reset search entries on new window
    self._searchEntries = {}
    -- reset public Flags mapping for the new UI instance
    self.Flags = {}
    opts = opts or {}
    local title = tostring(opts.Name or "Dendrite UI")
    local titleMode = tostring(opts.TitleMode or "Static"):lower() -- static | type
    -- Removed TitleTypeConfig: using fixed tuned timings
    local autoDevice = opts.AutoDeviceCheck == true
    local forceShowMobileBtn = opts.ShowMobileButton == true -- new option: show mobile toggle even on PC
    local size = opts.Size or UDim2.fromOffset(600, 540)
    local closeCb = opts.CloseCallback
    local Window = { Name = title, _categories = {}, _selectedCategory = nil }
    local z = 100
    local rootStroke = Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})
    -- device adapt
    local isMobile = (UserInputService.TouchEnabled and not UserInputService.MouseEnabled) or (UserInputService.KeyboardEnabled == false)
    if isMobile and autoDevice then
        size = UDim2.fromOffset(math.clamp(size.X.Offset, 480, 560), math.clamp(size.Y.Offset, 360, 420))
    end
    local showMobileBtn = isMobile or forceShowMobileBtn
    local root = Create("Frame", {Name = "Window", Size = size, BackgroundColor3 = Theme.Panel, BorderSizePixel = 0, Position = UDim2.fromScale(0.5, 0.5), AnchorPoint = Vector2.new(0.5, 0.5), ZIndex = z, Parent = RootGui}, {
        rootStroke,
        -- added gentle rounding (was square); adjust 12 -> different look if needed
        Create("UICorner", {CornerRadius = UDim.new(0,12)})
    })
    self._singletonRoot = root
    -- Simplified header: clean bar + single accent line
    -- header color lightened (was Theme.Bg) to match panel tone for preview
    local header = Create("Frame", {Name = "Header", Size = UDim2.new(1, 0, 0, 42), BackgroundColor3 = Theme.Panel, BorderSizePixel = 0, ZIndex = z + 1, Parent = root}, {
        Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.25}),
        -- mirror rounding so top edge matches window curvature (bottom stays visually seamless)
        Create("UICorner", {CornerRadius = UDim.new(0,12)})
    })
    -- removed accent line per request
    local titleLabel = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1, -160, 1, 0), Position = UDim2.fromOffset(12, 0), Text = title:upper(), TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Font = Fonts.Bold, TextSize = 16, ZIndex = z + 2, Parent = header})
    -- Title animation: only Static or looping Type
    if titleMode == "type" then
        task.spawn(function()
            local function animateText(display, text, delay)
                if not display then return end
                local animatedRandom = "1234567890"
                for i = 1, #text do
                    local revealChar = text:sub(i, i)
                    local displayText = text:sub(1, i - 1)
                    for _ = 1, math.random(1, 6) do
                        local random = math.random(1, #animatedRandom)
                        local randomChar = animatedRandom:sub(random, random)
                        display.Text = displayText .. randomChar
                        task.wait(delay)
                    end
                    display.Text = displayText .. revealChar
                    task.wait(delay)
                end
                task.wait(5)
            end
            local upper = title:upper()
            while true do
                titleLabel.Text = ""
                animateText(titleLabel, upper, 0.045)
            end
        end)
    else
        titleLabel.Text = title:upper()
    end
    local btnCluster = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(108, 32), Position = UDim2.new(1, -8, 0.5, 0), AnchorPoint = Vector2.new(1,0.5), Parent = header})
    local clusterLayout = Create("UIListLayout", {FillDirection = Enum.FillDirection.Horizontal, HorizontalAlignment = Enum.HorizontalAlignment.Right, VerticalAlignment = Enum.VerticalAlignment.Center, Padding = UDim.new(0,4)}) clusterLayout.Parent = btnCluster
    local function makeHeaderBtn(iconChar)
        local b = Create("TextButton", {Size = UDim2.fromOffset(32,32), BackgroundColor3 = Theme.Button, AutoButtonColor = false, Text = iconChar, Font = Fonts.Medium, TextSize = 18, TextColor3 = Theme.Text, ZIndex = z + 3, Parent = btnCluster}, {
            Create("UICorner", {CornerRadius = UDim.new(0,5)}),
            Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})
        })
        b.MouseEnter:Connect(function() T(b,0.12,{BackgroundColor3 = Theme.Hover}):Play() end)
        b.MouseLeave:Connect(function() T(b,0.12,{BackgroundColor3 = Theme.Button}):Play() end)
        return b
    end
    local closeBtn = makeHeaderBtn("X")
    local fsBtn = makeHeaderBtn("")
    local minBtn = makeHeaderBtn("â€“")
    -- reposition cluster order: minimize, fullscreen, close (already appended; adjust layout order)
    minBtn.LayoutOrder = 1 fsBtn.LayoutOrder = 2 closeBtn.LayoutOrder = 3
    -- custom fullscreen icon (aggressive corners)
    local fsIcon = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(16,16), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.fromScale(0.5,0.5), Parent = fsBtn})
    local function makeCorner(ax, ay)
        local c = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(7,7), AnchorPoint = Vector2.new(ax,ay), Position = UDim2.new(ax, ax==1 and -1 or 1, ay, ay==1 and -1 or 1), Parent = fsIcon})
    Create("Frame", {BackgroundColor3 = Theme.Text, BorderSizePixel = 0, Size = UDim2.fromOffset(7,2), Position = UDim2.new(ax==1 and 1 or 0, ax==1 and -7 or 0, ay==1 and 1 or 0, ay==1 and -2 or 0), Parent = c})
    Create("Frame", {BackgroundColor3 = Theme.Text, BorderSizePixel = 0, Size = UDim2.fromOffset(2,7), Position = UDim2.new(ax==1 and 1 or 0, ax==1 and -2 or 0, ay==1 and 1 or 0, ay==1 and -7 or 0), Parent = c})
        return c
    end
    local fsCorners = {makeCorner(0,0), makeCorner(1,0), makeCorner(0,1), makeCorner(1,1)}
    closeBtn.MouseEnter:Connect(function() T(closeBtn, 0.12, {BackgroundColor3 = Theme.Bad}):Play() end)
    closeBtn.MouseLeave:Connect(function() T(closeBtn, 0.16, {BackgroundColor3 = Theme.Button}):Play() end)
    closeBtn.MouseButton1Click:Connect(function() root.Visible = false if type(closeCb) == "function" then pcall(closeCb) end end)
    minBtn.MouseEnter:Connect(function() T(minBtn, 0.12, {BackgroundColor3 = Theme.Hover}):Play() end)
    minBtn.MouseLeave:Connect(function() T(minBtn, 0.12, {BackgroundColor3 = Theme.Button}):Play() end)
    fsBtn.MouseEnter:Connect(function() T(fsBtn, 0.12, {BackgroundColor3 = Theme.Hover}):Play() end)
    fsBtn.MouseLeave:Connect(function() T(fsBtn, 0.12, {BackgroundColor3 = Theme.Button}):Play() end)
    local minimized, prevSize, prevPos = false, root.Size, root.Position
    local fullscreen, fsPrevSize, fsPrevPos = false, nil, nil
    minBtn.MouseButton1Click:Connect(function()
        if fullscreen then
            -- exit fullscreen first
            T(root, 0.18, {Size = fsPrevSize, Position = fsPrevPos}):Play()
            fullscreen = false
        end
        minimized = not minimized
        if minimized then
            prevSize = root.Size; prevPos = root.Position
            for _, child in ipairs(root:GetChildren()) do if child ~= header and child:IsA("GuiObject") then child.Visible = false end end
            T(root, 0.18, {Size = UDim2.new(prevSize.X.Scale, prevSize.X.Offset, 0, header.Size.Y.Offset)}):Play()
        else
            for _, child in ipairs(root:GetChildren()) do if child ~= header and child:IsA("GuiObject") then child.Visible = true end end
            T(root, 0.18, {Size = prevSize, Position = prevPos}):Play()
        end
    end)
    fsBtn.MouseButton1Click:Connect(function()
        if minimized then
            -- restore from minimized before fullscreen
            minimized = false
            for _, child in ipairs(root:GetChildren()) do if child ~= header and child:IsA("GuiObject") then child.Visible = true end end
            T(root, 0.12, {Size = prevSize, Position = prevPos}):Play()
        end
        if not fullscreen then
            fsPrevSize, fsPrevPos = root.Size, root.Position
            T(root, 0.22, {Size = UDim2.new(1, -20, 1, -20), Position = UDim2.fromScale(0.5, 0.5)}):Play()
            fullscreen = true
        else
            T(root, 0.22, {Size = fsPrevSize, Position = fsPrevPos}):Play()
            fullscreen = false
        end
    end)
    local body = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1, -12, 1, -(46 + 12)), Position = UDim2.fromOffset(6, 46 + 6), ZIndex = z, Parent = root})
    local sidebar = Create("ScrollingFrame", {Name = "Sidebar", BackgroundColor3 = Theme.Panel, BorderSizePixel = 0, Size = UDim2.new(0, 100, 1, 0), ScrollBarThickness = 2, ScrollBarImageColor3 = Theme.Scrollbar, CanvasSize = UDim2.fromOffset(0,0), AutomaticCanvasSize = Enum.AutomaticSize.Y, ScrollingDirection = Enum.ScrollingDirection.Y, ZIndex = z + 1, Parent = body}, {Create("UICorner", {CornerRadius = UDim.new(0, 4)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3}), Create("UIListLayout", {Padding = UDim.new(0, 6), SortOrder = Enum.SortOrder.LayoutOrder}), Create("UIPadding", {PaddingTop = UDim.new(0, 6), PaddingLeft = UDim.new(0, 6), PaddingRight = UDim.new(0, 6), PaddingBottom = UDim.new(0, 6)})})
    local content = Create("Frame", {Name = "Content", BackgroundColor3 = Theme.Panel, BorderSizePixel = 0, ClipsDescendants = true, Size = UDim2.new(1, -(100 + 6), 1, 0), Position = UDim2.new(0, 100 + 6, 0, 0), ZIndex = z, Parent = body}, {Create("UICorner", {CornerRadius = UDim.new(0, 4)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})})
    do
        -- Smooth, resilient dragging (supports mouse & touch) without stutter.
    local dragging = false
    local dragStart
    local frameStart
        local lastInput
        local RS = game:GetService("RunService")
        local function update()
            if not dragging or not lastInput then return end
            local curPos = (lastInput.UserInputType == Enum.UserInputType.Touch) and lastInput.Position or UserInputService:GetMouseLocation()
            local delta = curPos - dragStart
            root.Position = UDim2.new(frameStart.X.Scale, frameStart.X.Offset + delta.X, frameStart.Y.Scale, frameStart.Y.Offset + delta.Y)
        end
        header.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                lastInput = input
                dragStart = (input.UserInputType == Enum.UserInputType.Touch) and input.Position or UserInputService:GetMouseLocation()
                frameStart = root.Position
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)
        header.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                lastInput = input
            end
        end)
        UserInputService.InputChanged:Connect(function(input)
            if not dragging then return end
            if input == lastInput then
                update()
            end
        end)
        RS.RenderStepped:Connect(update)
        local resizingCount = 0
        local sizeLabel = Create("TextLabel", {BackgroundTransparency = 0.25, BackgroundColor3 = Theme.Bg, Size = UDim2.fromOffset(110, 20), AnchorPoint = Vector2.new(1,1), Position = UDim2.new(1, -8, 1, -8), Text = "", Font = Fonts.Medium, TextSize = 12, TextColor3 = Theme.Text, Visible = false, Parent = root}, {Create("UICorner", {CornerRadius = UDim.new(0, 4)}), Create("UIStroke", {Color = Theme.Accent, Thickness = 1, Transparency = 0.4})})
        local function resizeStartEffect()
            T(rootStroke, 0.15, {Thickness = 2, Transparency = 0.15}):Play()
        end
        local function resizeEndEffect()
            local tw = T(rootStroke, 0.18, {Thickness = 3, Transparency = 0.05})
            tw:Play()
            tw.Completed:Connect(function()
                T(rootStroke, 0.25, {Thickness = 1, Transparency = 0.3}):Play()
            end)
        end
        local function updateSizeLabel()
            local sz = root.AbsoluteSize
            sizeLabel.Text = ("%d x %d"):format(sz.X, sz.Y)
        end
        local function addCornerGrip(mode, showVisual)
            local gp = {tl = Vector2.new(0,0), tr = Vector2.new(1,0), bl = Vector2.new(0,1), br = Vector2.new(1,1)}
            local ap = gp[mode] or gp.br
            local grip = Create("Frame", {Name = "Grip_"..mode, BackgroundTransparency = 1, Size = UDim2.fromOffset(26,26), Position = UDim2.new(ap.X, ap.X==1 and 0 or 0, ap.Y, ap.Y==1 and 0 or 0), AnchorPoint = ap, ZIndex = z + 3, Parent = root})
            if showVisual then
                -- Clean resize grip with diagonal dot pattern
                local gripRoot = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(16,16), AnchorPoint = Vector2.new(1,1), Position = UDim2.new(1,-4,1,-4), ZIndex = z + 4, Parent = grip})
                
                -- Create a proper diagonal grip pattern using small squares
                local gripElements = {}
                local dotSize = 2
                local spacing = 4
                
                -- Create diagonal rows of dots pointing toward bottom-right corner
                local dotPositions = {
                    -- First diagonal line (1 dot) - closest to corner
                    {x = 12, y = 12},
                    -- Second diagonal line (2 dots)  
                    {x = 8, y = 12},
                    {x = 12, y = 8},
                    -- Third diagonal line (3 dots) - furthest from corner
                    {x = 4, y = 12},
                    {x = 8, y = 8}, 
                    {x = 12, y = 4}
                }
                
                for i, pos in ipairs(dotPositions) do
                    local dot = Create("Frame", {
                        BackgroundColor3 = Theme.Accent,
                        BackgroundTransparency = 0.4,
                        BorderSizePixel = 0,
                        Size = UDim2.fromOffset(dotSize, dotSize),
                        Position = UDim2.fromOffset(pos.x, pos.y),
                        ZIndex = z + 5 + i,
                        Parent = gripRoot
                    }, {
                        Create("UICorner", {CornerRadius = UDim.new(0, 1)}) -- Slightly rounded
                    })
                    
                    gripElements[#gripElements + 1] = {dot = dot, originalPos = pos}
                end
                
                -- Smooth hover effects
                local function hover(on)
                    for i, entry in ipairs(gripElements) do
                        local dot = entry.dot
                        
                        if on then
                            -- Make dots more visible and slightly bigger
                            T(dot, 0.15, {
                                BackgroundTransparency = 0.1,
                                Size = UDim2.fromOffset(dotSize + 1, dotSize + 1)
                            }):Play()
                        else
                            -- Return to normal
                            T(dot, 0.2, {
                                BackgroundTransparency = 0.4,
                                Size = UDim2.fromOffset(dotSize, dotSize)
                            }):Play()
                        end
                    end
                end
                
                grip.MouseEnter:Connect(function() hover(true) end)
                grip.MouseLeave:Connect(function() hover(false) end)
            end
            local resizing = false
            local startMouse, startAbsPos, startAbsSize, parentAbs
            local minW, minH = 520, 380
            grip.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    resizing = true
                    resizingCount = resizingCount + 1
                    if resizingCount == 1 then resizeStartEffect() end
                    sizeLabel.Visible = true
                    local pos = (input.UserInputType == Enum.UserInputType.Touch) and input.Position or UserInputService:GetMouseLocation()
                    startMouse = Vector2.new(pos.X, pos.Y)
                    startAbsPos = root.AbsolutePosition
                    startAbsSize = root.AbsoluteSize
                    parentAbs = root.Parent.AbsolutePosition
                    input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then resizing = false end end)
                end
            end)
            UserInputService.InputChanged:Connect(function(input)
                if not resizing then return end
                if input.UserInputType ~= Enum.UserInputType.MouseMovement and input.UserInputType ~= Enum.UserInputType.Touch then return end
                local pos = (input.UserInputType == Enum.UserInputType.Touch) and input.Position or UserInputService:GetMouseLocation()
                local dx = pos.X - startMouse.X
                local dy = pos.Y - startMouse.Y
                local left, top = startAbsPos.X, startAbsPos.Y
                local right, bottom = startAbsPos.X + startAbsSize.X, startAbsPos.Y + startAbsSize.Y
                if mode == "br" then right = right + dx bottom = bottom + dy end
                if mode == "bl" then left = left + dx bottom = bottom + dy end
                if mode == "tr" then right = right + dx top = top + dy end
                if mode == "tl" then left = left + dx top = top + dy end
                local newW = math.max(minW, right - left)
                local newH = math.max(minH, bottom - top)
                -- recompute left/top if min constraints clipped
                if mode == "bl" then left = right - newW end
                if mode == "tr" then top = bottom - newH end
                if mode == "tl" then left = right - newW top = bottom - newH end
                local centerX = left + newW/2
                local centerY = top + newH/2
                root.Size = UDim2.fromOffset(newW, newH)
                root.Position = UDim2.fromOffset(centerX - parentAbs.X, centerY - parentAbs.Y)
                updateSizeLabel()
            end)
            grip.InputEnded:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    if resizing then
                        resizing = false
                        resizingCount = math.max(0, resizingCount - 1)
                        if resizingCount == 0 then
                            resizeEndEffect()
                            task.delay(0.6, function() if resizingCount == 0 then sizeLabel.Visible = false end end)
                        end
                    end
                end
            end)
        end
        addCornerGrip("br", true)
        addCornerGrip("bl", false)
        addCornerGrip("tr", false)
        addCornerGrip("tl", false)
    end
    function Window:AddCategory(o)
        o = o or {}
        local name = tostring(o.Name or "Category")
        local icon = o.Icon
        local Category = { Name = name, _pages = {}, _selectedPage = nil }
        local btn = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = "", Size = UDim2.new(1, 0, 0, 38), ZIndex = z + 2, Parent = sidebar})
        local inner = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1, -2, 1, -2), Position = UDim2.fromOffset(1,1), Parent = btn})
        local iconImg
        -- unified layout: reserve 18px slot at left; text always starts after it
        if icon then
            if type(icon) == "number" or tostring(icon):match("^%d+$") then icon = "rbxassetid://" .. tostring(icon) end
            iconImg = Create("ImageLabel", {BackgroundTransparency = 1, Size = UDim2.fromOffset(16,16), Position = UDim2.fromOffset(4, 11), Image = icon, ImageColor3 = Theme.SubText, ZIndex = z + 3, Parent = inner})
        end
        local lbl = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1, -10, 1, 0), Position = UDim2.fromOffset( (icon and 24) or 24, 0), Text = name, Font = Fonts.Medium, TextSize = 14, TextColor3 = Theme.SubText, TextXAlignment = Enum.TextXAlignment.Left, ZIndex = z + 3, Parent = inner})
        local catInd = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0,0,0,2), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,0,1,0), Visible = false, ZIndex = z + 3, Parent = inner})
        btn.MouseEnter:Connect(function() if Window._selectedCategory ~= Category then T(lbl, 0.12, {TextColor3 = Theme.Text}):Play() if iconImg then T(iconImg, 0.12, {ImageColor3 = Theme.Text}):Play() end end end)
        btn.MouseLeave:Connect(function() if Window._selectedCategory ~= Category then T(lbl, 0.12, {TextColor3 = Theme.SubText}):Play() if iconImg then T(iconImg, 0.12, {ImageColor3 = Theme.SubText}):Play() end end end)
        local catContainer = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromScale(1,1), Visible = false, Parent = content})
    local subBar = Create("ScrollingFrame", {BackgroundTransparency = 1, BorderSizePixel = 0, Size = UDim2.new(1, -10, 0, 24), Position = UDim2.fromOffset(5, 5), ScrollBarThickness = 2, ScrollBarImageColor3 = Theme.Scrollbar, CanvasSize = UDim2.fromOffset(0,0), AutomaticCanvasSize = Enum.AutomaticSize.X, ScrollingDirection = Enum.ScrollingDirection.X, ZIndex = z + 1, Parent = catContainer}, {Create("UIListLayout", {FillDirection = Enum.FillDirection.Horizontal, Padding = UDim.new(0, 8), VerticalAlignment = Enum.VerticalAlignment.Center, HorizontalAlignment = Enum.HorizontalAlignment.Left})})
    -- search popup + button (only create once for the entire window)
    if not Window._globalSearchCreated then
        Window._globalSearchCreated = true
    Window._globalSearchPopup = Create("Frame", {BackgroundColor3 = Theme.Bg, BorderSizePixel = 0, Visible = false, Size = UDim2.fromOffset(210, 30), Position = UDim2.fromOffset(0,0), AnchorPoint = Vector2.new(0,0), ZIndex = z + 500, Parent = root}, {
            Create("UICorner", {CornerRadius = UDim.new(0,6)}),
            Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.4}),
            Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,8), PaddingTop = UDim.new(0,4), PaddingBottom = UDim.new(0,4)})
        })
        Window._globalSearchBox = Create("TextBox", {BackgroundTransparency = 1, ClearTextOnFocus = false, Text = "", PlaceholderText = "Search...", PlaceholderColor3 = Theme.SubText, TextColor3 = Theme.Text, Font = Fonts.Medium, TextSize = 13, Size = UDim2.new(1,0,1,0), TextXAlignment = Enum.TextXAlignment.Left, Parent = Window._globalSearchPopup})
        
        -- Global search state
        Window._filteredPage = nil
        Window._activeHighlightStroke = nil
        Window._activeStrokeOrigColor = nil
        Window._activeStrokeOrigThickness = nil
        Window._activeStrokeOrigTrans = nil
        
        function Window:RestoreColumns()
            if self._filteredPage and self._filteredPage._columnsFrames then
                for _, cfr in ipairs(self._filteredPage._columnsFrames) do cfr.Visible = true end
            end
            self._filteredPage = nil
            if self._activeHighlightStroke and self._activeHighlightStroke.Parent then
                self._activeHighlightStroke.Color = self._activeStrokeOrigColor or self._activeHighlightStroke.Color
                self._activeHighlightStroke.Thickness = self._activeStrokeOrigThickness or 1
                self._activeHighlightStroke.Transparency = self._activeStrokeOrigTrans or self._activeHighlightStroke.Transparency
            end
            self._activeHighlightStroke = nil
        end
        
        function Window:ToggleSearch(show)
            show = (show == nil) and (not self._globalSearchPopup.Visible) or show
            if show then
                -- Prevent immediate reopen if we just closed from the same button
                if self._searchForceClosedUntil and os.clock() < (self._searchForceClosedUntil or 0) then
                    if self._currentSearchBtn and self._searchForceClosedSource and self._currentSearchBtn == self._searchForceClosedSource then
                        return
                    end
                end
                -- If already open with same owner, just reposition and return
                if self._globalSearchPopup.Visible and self._searchOwner and self._searchOwner == self._currentSearchBtn then
                    if self._currentSearchBtn and self._currentSearchBtn.Parent then
                        local btnAbs = self._currentSearchBtn.AbsolutePosition
                        local rootAbs = root.AbsolutePosition
                        local btnSize = self._currentSearchBtn.AbsoluteSize
                        local popupW = 210
                        local px = btnAbs.X - rootAbs.X
                        local maxX = root.AbsoluteSize.X - popupW - 4
                        if px < 4 then px = 4 elseif px > maxX then px = maxX end
                        local py = btnAbs.Y - rootAbs.Y + btnSize.Y + 6
                        self._globalSearchPopup.Position = UDim2.fromOffset(px, py)
                    end
                    return
                end
                self._globalSearchPopup.Visible = true
        -- Remember which button owns this open instance
        self._searchOwner = self._currentSearchBtn
                -- Clear any stale force-close guard now that we opened intentionally
                self._searchForceClosedUntil = nil
                self._searchForceClosedSource = nil
                -- Position popup relative to current search button
                if Window._currentSearchBtn then
                    local btnAbs = Window._currentSearchBtn.AbsolutePosition
                    local rootAbs = root.AbsolutePosition
                    local btnSize = Window._currentSearchBtn.AbsoluteSize
                    local popupW = 210
                    -- align popup's left edge with button's left edge
                    local px = btnAbs.X - rootAbs.X
                    local maxX = root.AbsoluteSize.X - popupW - 4
                    if px < 4 then px = 4 elseif px > maxX then px = maxX end
                    local py = btnAbs.Y - rootAbs.Y + btnSize.Y + 6
                    self._globalSearchPopup.Position = UDim2.fromOffset(px, py)
                end
                
                -- Animation
                local stroke = self._globalSearchPopup:FindFirstChild("Stroke")
                if stroke then stroke.Thickness = 2.2 stroke.Transparency = 0.75 end
                self._globalSearchPopup.BackgroundTransparency = 1
                self._globalSearchPopup.Size = UDim2.fromOffset(0,0)
                T(self._globalSearchPopup,0.22,{Size = UDim2.fromOffset(210,30)}):Play()
                T(self._globalSearchPopup,0.25,{BackgroundTransparency = 0}):Play()
                if stroke then T(stroke,0.35,{Thickness = 1, Transparency = 0.4}):Play() end
                task.defer(function() pcall(function() self._globalSearchBox:CaptureFocus() end) end)
            else
                self._globalSearchPopup.Visible = false
                self._globalSearchBox.Text = ""
                self:RestoreColumns()
                self._searchOwner = nil
                -- Set a short guard to avoid accidental reopen from the same button within the same click frame
                self._searchForceClosedUntil = os.clock() + 0.25
                self._searchForceClosedSource = self._currentSearchBtn or self._searchOwner
            end
        end
        
        function Window:ApplySearchFilter()
            local term = self._globalSearchBox.Text or ""
            if term == "" then
                self:RestoreColumns()
                return
            end
            local match = self:Search(term, true)
            if match and match.page and match.groupFrame then
                local wasSearchOpen = self._globalSearchPopup.Visible
                
                -- Switch to correct category if needed
                if self._selectedCategory ~= match.category then
                    match.category:Select()
                end
                if match.category._selectedPage ~= match.page then
                    match.page:Select()
                end
                
                -- If search was open and we switched categories, keep it open and reposition
                if wasSearchOpen then
                    self._globalSearchPopup.Visible = true
                    -- Ensure current button points to the matched category's search button
                    self._currentSearchBtn = match.category and match.category._searchBtn or self._currentSearchBtn
                    -- Reposition popup relative to current category's search button aligned to right edge
                    if self._currentSearchBtn and self._currentSearchBtn.Parent then
                        -- Update owner to the active category's button
                        self._searchOwner = self._currentSearchBtn
                        local btnAbs = self._currentSearchBtn.AbsolutePosition
                        local rootAbs = root.AbsolutePosition
                        local btnSize = self._currentSearchBtn.AbsoluteSize
                        local popupW = 210
                        -- align popup's left edge with button's left edge
                        local px = btnAbs.X - rootAbs.X
                        local maxX = root.AbsoluteSize.X - popupW - 4
                        if px < 4 then px = 4 elseif px > maxX then px = maxX end
                        local py = btnAbs.Y - rootAbs.Y + btnSize.Y + 6
                        self._globalSearchPopup.Position = UDim2.fromOffset(px, py)
                    end
                end
                
                -- Hide other columns in that page
                local page = match.page
                if page._columnsFrames then
                    self._filteredPage = page
                    for _, cfr in ipairs(page._columnsFrames) do
                        cfr.Visible = (cfr == match.groupFrame.Parent)
                    end
                end
                
                -- Highlight the found element
                local stroke = nil
                for _, child in ipairs(match.groupFrame:GetChildren()) do
                    if child:IsA("UIStroke") then stroke = child break end
                end
                if stroke then
                    if self._activeHighlightStroke ~= stroke then
                        if self._activeHighlightStroke and self._activeHighlightStroke.Parent then
                            self._activeHighlightStroke.Color = self._activeStrokeOrigColor or self._activeHighlightStroke.Color
                            self._activeHighlightStroke.Thickness = self._activeStrokeOrigThickness or 1
                            self._activeHighlightStroke.Transparency = self._activeStrokeOrigTrans or self._activeHighlightStroke.Transparency
                        end
                        self._activeHighlightStroke = stroke
                        self._activeStrokeOrigColor = stroke.Color
                        self._activeStrokeOrigThickness = stroke.Thickness
                        self._activeStrokeOrigTrans = stroke.Transparency
                    end
                    stroke.Color = Theme.Accent
                    stroke.Transparency = 0.15
                    T(stroke,0.35,{Thickness = 2}):Play()
                end
            end
        end
        
        -- Global search event handlers
        local lastChange = 0
        Window._globalSearchBox:GetPropertyChangedSignal("Text"):Connect(function()
            if not Window._globalSearchPopup.Visible then return end
            if Window._globalSearchBox.Text == "" then Window:RestoreColumns() return end
            lastChange = lastChange + 1
            local version = lastChange
            task.delay(0.15, function() if version == lastChange then Window:ApplySearchFilter() end end)
        end)
        
        Window._globalSearchBox.FocusLost:Connect(function(enter)
            if enter then Window:ApplySearchFilter() end
        end)
        
        Window._globalSearchBox.ReturnPressedFromOnScreenKeyboard:Connect(function() Window:ApplySearchFilter() end)
        
        UserInputService.InputBegan:Connect(function(inp)
            if Window._globalSearchPopup.Visible and (inp.KeyCode == Enum.KeyCode.Escape) then Window:ToggleSearch(false) end
        end)
        
        UserInputService.InputBegan:Connect(function(inp)
            if not Window._globalSearchPopup.Visible then return end
            if inp.UserInputType == Enum.UserInputType.MouseButton1 then
                local pos = UserInputService:GetMouseLocation()

                -- Check if click is inside search popup
                local searchAbs = Window._globalSearchPopup.AbsolutePosition
                local searchSz = Window._globalSearchPopup.AbsoluteSize
                local insideSearch = pos.X >= searchAbs.X and pos.X <= searchAbs.X+searchSz.X and pos.Y >= searchAbs.Y and pos.Y <= searchAbs.Y+searchSz.Y

                -- Check if click is inside ANY category's search button
                local insideAnyBtn = false
                for _, cat in ipairs(Window._categories or {}) do
                    local b = cat._searchBtn
                    if b and b.Parent then
                        local bAbs = b.AbsolutePosition
                        local bSz = b.AbsoluteSize
                        if pos.X >= bAbs.X and pos.X <= bAbs.X+bSz.X and pos.Y >= bAbs.Y and pos.Y <= bAbs.Y+bSz.Y then
                            insideAnyBtn = true
                            break
                        end
                    end
                end

                -- Close search if clicking anywhere except search popup or any search button
                if not insideSearch and not insideAnyBtn then
                    Window:ToggleSearch(false)
                end
            end
        end)
    end
    
    -- Create search button for this category
    local searchBtn = Create("TextButton", {BackgroundColor3 = Theme.Button, AutoButtonColor = false, Size = UDim2.fromOffset(32,22), Text = "ðŸ”", Font = Fonts.Medium, TextSize = 14, TextColor3 = Theme.Text, ZIndex = z + 2, Parent = subBar}, {
        Create("UICorner", {CornerRadius = UDim.new(0,5)}),
        Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.45})
    })
    Category._searchBtn = searchBtn
    
    searchBtn.MouseEnter:Connect(function() T(searchBtn,0.12,{BackgroundColor3 = Theme.Hover}):Play() end)
    searchBtn.MouseLeave:Connect(function() T(searchBtn,0.12,{BackgroundColor3 = Theme.Button}):Play() end)
    searchBtn.MouseButton1Click:Connect(function()
        local isOpen = Window._globalSearchPopup and Window._globalSearchPopup.Visible
        local owner = Window._searchOwner
        if isOpen and owner == searchBtn then
            -- Same button while open -> close
            Window:ToggleSearch(false)
            return
        end
        if isOpen and owner ~= searchBtn then
            -- Different button while open -> keep open and reposition
            Window._currentSearchBtn = searchBtn
            Window:ToggleSearch(true)
            return
        end
        -- Was closed -> open under this button
        Window._currentSearchBtn = searchBtn
        Window:ToggleSearch(true)
    end)
    local pageArea = Create("Frame", {BackgroundTransparency = 1, ClipsDescendants = true, Size = UDim2.new(1, -10, 1, -(24 + 10 + 6)), Position = UDim2.fromOffset(5, 24 + 9), Parent = catContainer})
        function Category:Select()
            if Window._selectedCategory and Window._selectedCategory._label then
                T(Window._selectedCategory._label, 0.12, {TextColor3 = Theme.SubText}):Play()
                if Window._selectedCategory._indicator then Window._selectedCategory._indicator.Visible = false Window._selectedCategory._indicator.Size = UDim2.fromOffset(0,2) end
                if Window._selectedCategory._icon then T(Window._selectedCategory._icon, 0.12, {ImageColor3 = Theme.SubText}):Play() end
            end
            Window._selectedCategory = Category
            -- update current search button so global search can reposition correctly
            Window._currentSearchBtn = Category._searchBtn or Window._currentSearchBtn
            for _, f in ipairs(content:GetChildren()) do if f:IsA("Frame") then f.Visible = false end end
            catContainer.Visible = true
            T(lbl, 0.12, {TextColor3 = Theme.Text}):Play()
            if iconImg then T(iconImg, 0.12, {ImageColor3 = Theme.Text}):Play() end
            catInd.Visible = true
            -- underline now expands full inner width (minus padding) for aggressive look
            T(catInd, 0.2, {Size = UDim2.new(1, -8, 0, 2), Position = UDim2.new(0,4,1,0)}):Play()
            if not Category._selectedPage and #Category._pages > 0 then Category._pages[1]:Select() end
        end
        btn.MouseButton1Click:Connect(function() Category:Select() end)
    function Category:AddSection(p)
            p = p or {}
            local pname = tostring(p.Name or "Page")
            local Page = { Name = pname, _blocks = {}, _columns = Clamp(tonumber(p.Columns) or 2, 1, 3) }
            local tb = TextService:GetTextSize(pname, 13, Fonts.Medium, Vector2.new(1000, 22))
            local subBtn = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = pname, TextColor3 = Theme.SubText, Font = Fonts.Medium, TextSize = 13, Size = UDim2.fromOffset(tb.X + 18, 22), ZIndex = z + 2, Parent = subBar})
            local subInd = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0,0,0,2), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,4,1,0), Visible = false, ZIndex = z + 3, Parent = subBtn})
            subBtn.MouseEnter:Connect(function() if Category._selectedPage ~= Page then T(subBtn, 0.12, {TextColor3 = Theme.Text}):Play() end end)
            subBtn.MouseLeave:Connect(function() if Category._selectedPage ~= Page then T(subBtn, 0.12, {TextColor3 = Theme.SubText}):Play() end end)
            local pageFrame = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromScale(1,1), Visible = false, Parent = pageArea})
            local cols = {}
            do
            local pad = 4
                local cw = 1 / Page._columns
                for i=1, Page._columns do
                local col = Create("ScrollingFrame", {BackgroundTransparency = 1, ClipsDescendants = true, Size = UDim2.new(cw, -(pad * (Page._columns + 1)) / Page._columns, 1, -2), Position = UDim2.new((i-1)*cw, pad * i - (pad / Page._columns), 0, 1), ScrollBarThickness = 2, ScrollBarImageColor3 = Theme.Scrollbar, CanvasSize = UDim2.fromOffset(0,0), AutomaticCanvasSize = Enum.AutomaticSize.Y, ScrollingDirection = Enum.ScrollingDirection.Y, Parent = pageFrame}, {Create("UIListLayout", {Padding = UDim.new(0, 3), HorizontalAlignment = Enum.HorizontalAlignment.Center, SortOrder = Enum.SortOrder.LayoutOrder}), Create("UIPadding", {PaddingLeft = UDim.new(0,2), PaddingRight = UDim.new(0,2), PaddingTop = UDim.new(0,2), PaddingBottom = UDim.new(0,3)})})
                    cols[i] = col
                end
            end
            Page._columnsFrames = cols
            function Page:Select()
                for _, pfr in ipairs(pageArea:GetChildren()) do if pfr:IsA("Frame") then pfr.Visible = false end end
                pageFrame.Visible = true
                Category._selectedPage = Page
                for _, b in ipairs(subBar:GetChildren()) do
                    if b:IsA("TextButton") then
                        T(b, 0.12, {TextColor3 = Theme.SubText}):Play()
                        local u = b:FindFirstChildOfClass("Frame") if u then u.Visible = false u.Size = UDim2.fromOffset(0,2) end
                    end
                end
                T(subBtn, 0.12, {TextColor3 = Theme.Text}):Play()
                subInd.Visible = true
                T(subInd, 0.2, {Size = UDim2.new(1, -8, 0, 2), Position = UDim2.new(0,4,1,0)}):Play()
            end
            subBtn.MouseButton1Click:Connect(function() Page:Select() end)
            -- Back-compat alias: Category:AddPage now Category:AddSection
            Category.AddPage = Category.AddSection
            function Page:AddPage(g)
                g = g or {}
                local gName = tostring(g.Name or "Block")
                local desc = g.Description
                local side = Clamp(tonumber(g.Side) or 1, 1, Page._columns)
                local Group = { Name = gName, _controls = {} }
                local gFrame = Create("Frame", {BackgroundColor3 = Theme.Bg, ClipsDescendants = true, Size = UDim2.new(1, -4, 0, 58), AutomaticSize = Enum.AutomaticSize.Y, BorderSizePixel = 0, ZIndex = z + 1, Parent = cols[side]}, {
                    Create("UICorner", {CornerRadius = UDim.new(0, 4)}),
                    Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3}),
                    Create("UIPadding", {PaddingLeft = UDim.new(0,6), PaddingRight = UDim.new(0,6), PaddingTop = UDim.new(0,6), PaddingBottom = UDim.new(0,6)})
                })
                Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 18), Text = gName, Font = Fonts.Bold, TextSize = 14, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, ZIndex = z + 2, Parent = gFrame})
                local y = 22
                if desc and #desc > 0 then
                    -- Larger visible info badge with plain 'i' (reworked: anchor via scale so resizing window doesn't break alignment)
                    local infoBtn = Create("TextButton", {BackgroundTransparency = 1, Size = UDim2.fromOffset(18,18), Position = UDim2.new(1, -6, 0, 1), AnchorPoint = Vector2.new(1,0), Text = "i", TextColor3 = Theme.SubText, Font = Fonts.Bold, TextSize = 14, AutoButtonColor = false, ZIndex = z + 6, Parent = gFrame})
                    -- hover circle (separate so base stays transparent) follows same anchored position
                    local hoverCircle = Create("Frame", {BackgroundColor3 = Color3.fromRGB(40,42,41), BackgroundTransparency = 1, Size = infoBtn.Size, Position = infoBtn.Position, AnchorPoint = Vector2.new(1,0), ZIndex = z + 5, Parent = gFrame})
                    Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = hoverCircle})
                    Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = infoBtn})
                    local iStroke = Create("UIStroke", {Color = Theme.Stroke, Thickness = 1.8, Transparency = 0, Parent = hoverCircle})
                    -- hover: shift stroke color instead of hiding it
                    local function hover(on)
                        if on then
                            T(hoverCircle,0.16,{BackgroundTransparency = 0.15}):Play()
                            T(infoBtn,0.14,{TextColor3 = Theme.Text}):Play()
                            T(iStroke,0.18,{Color = Theme.Text}):Play()
                        else
                            if popup and popup.Visible then return end
                            T(hoverCircle,0.20,{BackgroundTransparency = 1}):Play()
                            T(infoBtn,0.18,{TextColor3 = Theme.SubText}):Play()
                            T(iStroke,0.22,{Color = Theme.Stroke}):Play()
                        end
                    end
                    infoBtn.MouseEnter:Connect(function() hover(true) end)
                    infoBtn.MouseLeave:Connect(function() hover(false) end)
                    -- no AbsoluteSize polling needed; anchored with scale to right edge
                    -- measure text for better width
                    local meas = TextService:GetTextSize(desc, 12, Fonts.Regular, Vector2.new(320, math.huge))
                    local baseW = math.clamp(meas.X + 30, 140, 340)
                    local popup = Create("Frame", {BackgroundColor3 = Color3.fromRGB(28,30,29), BorderSizePixel = 0, Visible = false, Size = UDim2.new(0, baseW, 0, 0), ZIndex = z + 500, Parent = gFrame}, {
                        Create("UICorner", {CornerRadius = UDim.new(0,100)}),
                        Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.4}),
                        Create("UIPadding", {PaddingLeft = UDim.new(0,10), PaddingRight = UDim.new(0,10), PaddingTop = UDim.new(0,6), PaddingBottom = UDim.new(0,6)})
                    })
                    local pText = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,0,0), TextWrapped = true, TextYAlignment = Enum.TextYAlignment.Top, Text = desc, Font = Fonts.Regular, TextSize = 12, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, ZIndex = z + 501, Parent = popup})
                    pText.AutomaticSize = Enum.AutomaticSize.Y
                    popup.AutomaticSize = Enum.AutomaticSize.Y
                    popup.ClipsDescendants = true
                    -- arrow (triangle) using rotated square trick
                    -- arrow removed for minimalist pill popup
                    -- layout popup on show
                    local function positionPopup()
                        local relX = infoBtn.AbsolutePosition.X - gFrame.AbsolutePosition.X
                        local desired = relX - popup.AbsoluteSize.X/2 + infoBtn.AbsoluteSize.X/2
                        desired = math.clamp(desired, 4, math.max(4, gFrame.AbsoluteSize.X - popup.AbsoluteSize.X - 4))
                        popup.Position = UDim2.fromOffset(desired, 20)
                    end
                    local showing = false
                    local function show()
                        if showing then return end
                        showing = true
                        popup.Visible = true
                        popup.Size = UDim2.new(0, baseW, 0, 0)
                        positionPopup()
                        T(popup,0.18,{Size = UDim2.new(0,baseW,0,pText.AbsoluteSize.Y + 12)}):Play()
                        T(infoBtn,0.15,{BackgroundColor3 = Color3.fromRGB(48,52,50)}):Play()
                        T(iStroke,0.15,{Transparency = 0.35}):Play()
                    end
                    local function hide()
                        if not showing then return end
                        showing = false
                        local tw = T(popup,0.15,{Size = UDim2.new(0,baseW,0,0)})
                        tw:Play()
                        tw.Completed:Connect(function()
                            if not showing then
                                popup.Visible = false
                                T(infoBtn,0.18,{BackgroundColor3 = Color3.fromRGB(36,38,37)}):Play()
                                T(iStroke,0.18,{Transparency = 0.55}):Play()
                            end
                        end)
                    end
                    infoBtn.MouseEnter:Connect(show)
                    infoBtn.MouseLeave:Connect(function()
                        -- hide only if cursor not over popup
                        local con; con = game:GetService("RunService").RenderStepped:Connect(function()
                            local pos = UserInputService:GetMouseLocation()
                            local abs = popup.AbsolutePosition
                            local sz = popup.AbsoluteSize
                            local inside = pos.X >= abs.X and pos.X <= abs.X+sz.X and pos.Y >= abs.Y and pos.Y <= abs.Y+sz.Y
                            local btnAbs = infoBtn.AbsolutePosition
                            local btnSz = infoBtn.AbsoluteSize
                            local insideBtn = pos.X >= btnAbs.X and pos.X <= btnAbs.X+btnSz.X and pos.Y >= btnAbs.Y and pos.Y <= btnAbs.Y+btnSz.Y
                            if not inside and not insideBtn then
                                hide(); con:Disconnect()
                            end
                        end)
                    end)
                    infoBtn.MouseButton1Click:Connect(function()
                        if showing then hide() else show() end
                    end)
                    -- add a small vertical gap so controls aren't cramped under the info badge
                    y = y + 8
                end
                local function nextY(h) local o=y; y=y+h+6; return o end
                -- search registration helper (captures Category/Page/Group)
                local function registerSearch(text, searchType)
                    if not text or text == "" then return end
                    Library._searchEntries[#Library._searchEntries+1] = {
                        textLower = string.lower(text), 
                        category = Category, 
                        page = Page, 
                        groupFrame = gFrame,
                        originalText = text,
                        searchType = searchType or "control"
                    }
                end
                
                -- Register group name, category name, and page name for search
                registerSearch(gName, "group")
                registerSearch(Category.Name, "category") 
                registerSearch(Page.Name, "page")
                -- Back-compat alias: Page:AddBlock now Page:AddPage
                Page.AddBlock = Page.AddPage
                if desc and desc ~= "" then
                    registerSearch(desc, "description")
                end
                -- Toggle
                function Group:AddToggle(o)
                    o = o or {}
                    local label = tostring(o.Name or "Toggle")
                    local default = (o.Default == true)
                    local cb = o.Callback
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,32), Position = UDim2.fromOffset(0,nextY(32)), Parent = gFrame})
                    local container = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = "", Size = UDim2.new(1,0,1,0), Parent = row})
                    local labelWidth = 0.44
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(labelWidth,-6,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = container})
                    local shell = Create("Frame", {BackgroundColor3 = Color3.fromRGB(50,50,50), Size = UDim2.fromOffset(40,18), AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1,-4,0.5,0), Parent = container})
                    Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = shell})
                    local recess = Create("Frame", {BackgroundColor3 = Theme.Bg, Size = UDim2.fromOffset(36,14), Position = UDim2.fromOffset(2,2), Parent = shell})
                    Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = recess})
                    local accentFill = Create("Frame", {BackgroundColor3 = Theme.Accent, BackgroundTransparency = 1, Size = UDim2.fromScale(1,1), Parent = shell})
                    Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = accentFill})
                    local knob = Create("Frame", {BackgroundColor3 = Theme.Scrollbar, Size = UDim2.fromOffset(12,12), Position = UDim2.new(0,4,0.5,0), AnchorPoint = Vector2.new(0,0.5), Parent = shell})
                    Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = knob})
                    local Toggle = { id = id, _value = default, _signal = Signal() }
                    function Toggle:Get() return self._value end
                    function Toggle:Set(v, silent)
                        v = (v == true)
                        self._value = v
                        if v then
                            T(accentFill,0.25,{BackgroundTransparency = 0}):Play()
                            T(knob,0.25,{Position = UDim2.new(1,-16,0.5,0), BackgroundColor3 = Theme.Text}):Play()
                        else
                            T(accentFill,0.25,{BackgroundTransparency = 1}):Play()
                            T(knob,0.25,{Position = UDim2.new(0,4,0.5,0), BackgroundColor3 = Theme.Scrollbar}):Play()
                        end
                        if not silent then if type(cb)=="function" then pcall(cb,v) end Toggle._signal:Fire(v) end
                    end
                    function Toggle:OnChanged(fn) return self._signal:Connect(fn) end
                    container.MouseButton1Click:Connect(function() Toggle:Set(not Toggle._value) end)
                    container.MouseEnter:Connect(function() T(shell,0.15,{BackgroundColor3 = Color3.fromRGB(58,58,58)}):Play() end)
                    container.MouseLeave:Connect(function() T(shell,0.15,{BackgroundColor3 = Color3.fromRGB(50,50,50)}):Play() end)
                    Toggle:Set(default,true)
                    Library:_registerControl(Toggle)
                    table.insert(Group._controls, Toggle)
                    registerSearch(label)
                    return Toggle
                end
                -- Button
                function Group:AddButton(o)
                    o = o or {}
                    local label = tostring(o.Name or "Button")
                    local cb = o.Callback
                    local compact = o.Compact == true
                    local h = compact and 28 or 32
                    local row = Create("TextButton", {BackgroundColor3 = Theme.Button, AutoButtonColor = false, Size = UDim2.new(1,0,0,h), Position = UDim2.fromOffset(0,nextY(h)), Text = "", Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, Parent = gFrame}, {
                        Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                        Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.45}),
                        Create("UIPadding", {PaddingLeft = UDim.new(0,10), PaddingRight = UDim.new(0,10)})
                    })
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})
                    local bar = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0,0,0,2), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,0,1,0), BackgroundTransparency = 0.15, Parent = row})
                    local function hover(on)
                        if on then
                            T(row,0.11,{BackgroundColor3 = Theme.Hover}):Play()
                            T(row.Stroke,0.14,{Transparency = 0.25}):Play()
                        else
                            T(row,0.11,{BackgroundColor3 = Theme.Button}):Play()
                            T(row.Stroke,0.14,{Transparency = 0.45}):Play()
                        end
                    end
                    row.MouseEnter:Connect(function() hover(true) end)
                    row.MouseLeave:Connect(function() hover(false) end)
                    row.MouseButton1Click:Connect(function()
                        if type(cb)=="function" then pcall(cb) end
                        -- animate bar across then retract & hide
                        bar.BackgroundTransparency = 0.15
                        bar.Size = UDim2.new(0,0,0,2)
                        local tween1 = T(bar,0.18,{Size = UDim2.new(1,0,0,2)})
                        tween1:Play()
                        tween1.Completed:Connect(function()
                            local tween2 = T(bar,0.18,{Size = UDim2.new(0,0,0,2)})
                            tween2:Play()
                            tween2.Completed:Connect(function()
                                bar.BackgroundTransparency = 1
                            end)
                        end)
                    end)
                    local Button = { id = ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label) }
                    Library:_registerControl(Button)
                    table.insert(Group._controls, Button)
                    registerSearch(label)
                    return Button
                end
                -- Slider
                function Group:AddSlider(o)
                    o = o or {}
                    local label = tostring(o.Name or "Slider")
                    local min = tonumber(o.Min) or 0
                    local max = tonumber(o.Max) or 100
                    if max == min then max = min + 1 end
                    local default = tonumber(o.Default or min)
                    local step = tonumber(o.Step or 1)
                    local cb = o.Callback
                    local precise = o.Precise == true
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)
                    -- UI row (compressed height)
                    local rowHeight = 46
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,rowHeight), Position = UDim2.fromOffset(0,nextY(rowHeight)), Parent = gFrame})
                    -- Label anchored top-left
                    local labelText = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1, -80, 0, 18), Position = UDim2.new(0,0,0,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})
                    -- Value box floats to right of label
                    local valueBox = Create("TextBox", {BackgroundColor3 = Theme.Button, Text = tostring(default), Font = Fonts.Medium, TextSize = 12, TextColor3 = Theme.SubText, Size = UDim2.new(0,64,0,18), Position = UDim2.new(1,-66,0,0), AnchorPoint = Vector2.new(0,0), ClearTextOnFocus = false, TextXAlignment = Enum.TextXAlignment.Center, Parent = row})
                    Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = valueBox})
                    local vbStroke = Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.45, Parent = valueBox})
                    -- Bar spans almost entire width beneath
                    local bar = Create("Frame", {BackgroundColor3 = Color3.fromRGB(30,32,31), Size = UDim2.new(1,0,0,6), Position = UDim2.new(0,0,0,26), Parent = row}, {Create("UICorner", {CornerRadius = UDim.new(1,0)})})
                    local barStroke = Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.6, Parent = bar})
                    -- drag pulse effect frame (overlay)
                    local dragPulse = Create("Frame", {BackgroundColor3 = Theme.Accent, BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Parent = bar})
                    Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = dragPulse})
                    dragPulse.ZIndex = bar.ZIndex + 1
                    local fill = Create("Frame", {BackgroundColor3 = Theme.Accent, Size = UDim2.new(0,0,1,0), Parent = bar}, {Create("UICorner", {CornerRadius = UDim.new(1,0)})})
                    local gradient = Instance.new("UIGradient")
                    gradient.Color = ColorSequence.new({
                        ColorSequenceKeypoint.new(0, Theme.Accent),
                        ColorSequenceKeypoint.new(0.5, Theme.Accent2),
                        ColorSequenceKeypoint.new(1, Theme.Accent)
                    })
                    gradient.Rotation = 0
                    gradient.Parent = fill
                    -- animate gradient shift
                    task.spawn(function()
                        local t0 = tick()
                        while row.Parent do
                            local tNow = (tick() - t0) * 25
                            gradient.Offset = Vector2.new((tNow % 100)/100, 0)
                            task.wait(0.05)
                        end
                    end)
                    local knob = Create("Frame", {BackgroundColor3 = Theme.Text, Size = UDim2.fromOffset(14,14), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.new(0,0,0.5,0), Parent = bar}, {Create("UICorner", {CornerRadius = UDim.new(1,0)})})
                    local knobStroke = Create("UIStroke", {Color = Theme.Bg, Thickness = 2, Transparency = 0.2, Parent = knob})
                    local knobGlow = Create("ImageLabel", {BackgroundTransparency = 1, Image = "rbxassetid://4996891970", ImageColor3 = Theme.Accent, ImageTransparency = 0.9, Size = UDim2.fromOffset(28,28), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.new(0.5,0,0.5,0), Parent = knob})
                    -- sheen effect
                    local sheen = Create("Frame", {BackgroundColor3 = Color3.fromRGB(255,255,255), BackgroundTransparency = 0.85, Size = UDim2.new(0,0,1,0), Parent = fill})
                    Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = sheen})
                    -- tooltip
                    knobGlow.ZIndex = 9 knob.ZIndex = 9
                    -- min/max subtle labels
                    -- removed min/max labels per request
                    -- Hover effects
                    local function hover(on)
                        if on then
                            T(bar,0.16,{BackgroundColor3 = Color3.fromRGB(36,40,38)}):Play()
                            T(barStroke,0.18,{Transparency = 0.35}):Play()
                            T(knobGlow,0.2,{ImageTransparency = 0.75}):Play()
                            T(knob,0.18,{Size = UDim2.fromOffset(18,18)}):Play()
                        else
                            T(bar,0.20,{BackgroundColor3 = Color3.fromRGB(30,32,31)}):Play()
                            T(barStroke,0.20,{Transparency = 0.6}):Play()
                            T(knobGlow,0.25,{ImageTransparency = 0.9}):Play()
                            T(knob,0.20,{Size = UDim2.fromOffset(14,14)}):Play()
                        end
                    end
                    bar.MouseEnter:Connect(function() hover(true) end)
                    bar.MouseLeave:Connect(function() hover(false) end)
                    knob.MouseEnter:Connect(function() hover(true) end)
                    -- early declare interaction state so hover callbacks capture them
                    local dragging, fine, lastClick = false, false, 0
                    -- sink game input while dragging to avoid A/D or other keys affecting gameplay/camera
                    local dragSinkAction = "DendriteSliderDrag_" .. id
                    local function bindDragSink()
                        local keys = Enum.KeyCode:GetEnumItems()
                        ContextActionService:BindAction(dragSinkAction, function(_, state, input)
                            if not dragging then return Enum.ContextActionResult.Pass end
                            -- While dragging the slider, sink keyboard/gamepad inputs
                            return Enum.ContextActionResult.Sink
                        end, false, table.unpack(keys))
                    end
                    local function unbindDragSink()
                        pcall(function() ContextActionService:UnbindAction(dragSinkAction) end)
                    end
                    knob.MouseLeave:Connect(function() if not dragging then hover(false) end end)
                    valueBox.Focused:Connect(function() T(vbStroke,0.15,{Transparency = 0.25}):Play() end)
                    valueBox.FocusLost:Connect(function() T(vbStroke,0.18,{Transparency = 0.45}):Play() end)
                    local Slider = { id = id, _value = default }
                    function Slider:Get() return self._value end
                    local function formatValue(v)
                        if precise then
                            local s = string.format("%.3f", v)
                            s = s:gsub("0+$", "")
                            s = s:gsub("%.$", "")
                            return s
                        else
                            return tostring(math.floor(v + 0.5))
                        end
                    end
                    function Slider:Set(v, silent)
                        local num = tonumber(v)
                        if not num or num ~= num or num == math.huge or num == -math.huge then
                            return
                        end
                        -- Clamp and round appropriately
                        if precise then
                            if step and step > 0 then
                                num = Round(num, step)
                            end
                            num = Clamp(num, min, max)
                        else
                            num = Clamp(Round(num, step or 1), min, max)
                        end
                        self._value = num
                        local pct = (num - min) / (max - min)
                        fill.Size = UDim2.new(pct,0,1,0)
                        knob.Position = UDim2.new(pct,0,0.5,0)
                        valueBox.Text = formatValue(num)
                        if not silent and type(cb)=="function" then pcall(cb,num) end
                    end
                    -- dragging / fine control logic (state already declared above)
                    -- ctrl-held fine adjustment flag is 'fine'
                    -- double click reset support uses 'lastClick'
                    local function updateFromX(x)
                        local rel = (x - bar.AbsolutePosition.X)/math.max(1, bar.AbsoluteSize.X)
                        rel = math.clamp(rel,0,1)
                        local raw = min + rel * (max - min)
                        if not precise then
                            Slider:Set(raw)
                        else
                            Slider:Set(raw)
                        end
                    end
                    local function beginDrag(input)
                        dragging = true
                        bindDragSink()
                        -- start pulse
                        dragPulse.BackgroundTransparency = 0.9
                        dragPulse.Size = UDim2.new(1,0,1,0)
                        T(dragPulse,0.25,{BackgroundTransparency = 1}):Play()
                        local x = (input.UserInputType==Enum.UserInputType.Touch) and input.Position.X or UserInputService:GetMouseLocation().X
                        updateFromX(x)
                    end
                    bar.InputBegan:Connect(function(input)
                        if input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.Touch then
                            local now = tick()
                            if now - lastClick < 0.35 then
                                -- double click -> reset to default
                                Slider:Set(default)
                            else
                                beginDrag(input)
                            end
                            lastClick = now
                        end
                    end)
                    knob.InputBegan:Connect(function(input)
                        if input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.Touch then
                            beginDrag(input)
                        end
                    end)
                    UserInputService.InputChanged:Connect(function(input)
                        if dragging and (input.UserInputType==Enum.UserInputType.MouseMovement or input.UserInputType==Enum.UserInputType.Touch) then
                            local x = (input.UserInputType==Enum.UserInputType.Touch) and input.Position.X or UserInputService:GetMouseLocation().X
                            if fine then
                                -- apply smaller incremental move by biasing x slightly toward previous value position
                                updateFromX(x)
                            else
                                updateFromX(x)
                            end
                        end
                    end)
                    UserInputService.InputEnded:Connect(function(input)
                        if input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.Touch then
                            if dragging then
                                -- end pulse
                                T(dragPulse,0.18,{BackgroundTransparency = 1}):Play()
                                unbindDragSink()
                            end
                            dragging=false
                        end
                    end)
                    UserInputService.InputBegan:Connect(function(input)
                        if input.KeyCode == Enum.KeyCode.LeftControl or input.KeyCode == Enum.KeyCode.RightControl then fine = true end
                        if dragging then return end -- ignore arrow adjustments while dragging
                        if input.KeyCode == Enum.KeyCode.Left then
                            if fine then Slider:Set(Slider._value - (precise and (step*0.25) or step)) else Slider:Set(Slider._value - step) end
                        elseif input.KeyCode == Enum.KeyCode.Right then
                            if fine then Slider:Set(Slider._value + (precise and (step*0.25) or step)) else Slider:Set(Slider._value + step) end
                        end
                    end)
                    UserInputService.InputEnded:Connect(function(input)
                        if input.KeyCode == Enum.KeyCode.LeftControl or input.KeyCode == Enum.KeyCode.RightControl then fine = false end
                    end)
                    -- valueBox editing
                    valueBox.Focused:Connect(function()
                        valueBox.TextColor3 = Theme.Text
                    end)
                    valueBox.FocusLost:Connect(function(enter)
                        valueBox.TextColor3 = Theme.SubText
                        local num = tonumber(valueBox.Text)
                        if num then
                            Slider:Set(num)
                        else
                            valueBox.Text = formatValue(Slider._value)
                        end
                    end)
                    valueBox:GetPropertyChangedSignal("Text"):Connect(function()
                        if precise then return end
                        -- Limit to digits and optional leading minus
                        local t = valueBox.Text
                        -- Remove non-digits
                        t = t:gsub("[^%d%-]", "")
                        -- Keep only first minus sign at start
                        local neg = t:match("^%-") and "-" or ""
                        t = t:gsub("%-", "")
                        t = neg .. t
                        if t ~= valueBox.Text then valueBox.Text = t end
                    end)
                    -- init
                    Slider:Set(default,true)
                    -- continuous sheen sweep loop
                    task.spawn(function()
                        while row.Parent do
                            sheen.Size = UDim2.new(0,0,1,0)
                            sheen.BackgroundTransparency = 0.9
                            T(sheen,1.2,{Size = UDim2.new(1,0,1,0), BackgroundTransparency = 1}):Play()
                            task.wait(3.5)
                        end
                    end)
                    Library:_registerControl(Slider)
                    table.insert(Group._controls, Slider)
                    registerSearch(label)
                    return Slider
                end
                -- NewSlider(text, low, high, precise, callback, defaultValue, flag)
                function Group:NewSlider(text, low, high, precise, callback, defaultValue, flag)
                    return Group:AddSlider({
                        Name = text,
                        Min = low,
                        Max = high,
                        Precise = precise,
                        Callback = callback,
                        Default = defaultValue,
                        Flag = flag,
                        Step = precise and ( (high - low) / 300 ) or 1,
                    })
                end
                -- Dropdown (new design v2)
                function Group:AddDropdown(...)
                    -- Accept both table-based and positional API:
                    -- AddDropdown({ Name=label, Options=options, Default=default, Multi=isMulti, Callback=cb, Flag=flag, Search=true/false, Placeholder=.. })
                    -- AddDropdown(label, options, default, isMulti, cb, flag)
                    local argc = select("#", ...)
                    local _first = ...
                    local o
                    if argc == 1 and type(_first) == "table" then
                        o = _first or {}
                    else
                        local labelArg, optionsArg, defaultArg, isMultiArg, cbArg, flagArg = ...
                        o = { Name = labelArg, Options = optionsArg, Default = defaultArg, Multi = isMultiArg, Callback = cbArg, Flag = flagArg }
                    end
                    o = o or {}
                    local label = tostring(o.Name or "Dropdown")
                    local options = o.Options or {}
                    local default = o.Default
                    local cb = o.Callback
                    local isMulti = (o.Multi == true) or (o.IsMulti == true)
                    -- Back-compat: allow either Filter or Search to toggle
                    local enableSearch = (o.Search ~= false) and (o.Filter ~= false)
                    local placeholder = tostring(o.Placeholder or "Choose...")
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)

                    -- Row + label
                    local rowH = 28
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,rowH), Position = UDim2.fromOffset(0,nextY(rowH)), Parent = gFrame})
                    local labelWidth = 0.42
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(labelWidth,-6,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})

                    -- Trigger: compact solid
                    local trigger = Create("TextButton", {BackgroundColor3 = Theme.Button, AutoButtonColor = false, Text = "", Size = UDim2.new(1-labelWidth,-4,1,0), Position = UDim2.new(labelWidth,4,0,0), Parent = row}, {
                        Create("UICorner", {CornerRadius = UDim.new(0,5)}),
                        Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.45}),
                        Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,0)})
                    })
                    -- Always start with placeholder; defaults are applied via Set() after options initialize
                    local valueLbl = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,-18,1,0), Text = placeholder, Font = Fonts.Medium, TextSize = 12, TextXAlignment = Enum.TextXAlignment.Left, TextColor3 = Theme.SubText, Parent = trigger})
                    local caret = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.fromOffset(16,14), AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1,-2,0.5,0), Text = "â–¼", Font = Fonts.Bold, TextSize = 14, TextColor3 = Theme.SubText, Parent = trigger})
                    caret.ZIndex = (trigger.ZIndex or 1) + 1

                    -- Panel (root-parented), width follows trigger; horizontally clamped to root
                    local panel = Create("Frame", {BackgroundColor3 = Theme.Bg, BorderSizePixel = 0, Visible = false, Size = UDim2.fromOffset(0,0), ZIndex = z + 350, Parent = root}, {
                        Create("UICorner", {CornerRadius = UDim.new(0,6)}),
                        Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.35})
                    })
                    local shadow = Create("ImageLabel", {BackgroundTransparency = 1, Image = "rbxassetid://4996891970", ImageColor3 = Theme.Bg, ImageTransparency = 0.85, Size = UDim2.fromScale(1,1), ZIndex = panel.ZIndex - 1, Parent = panel})
                    shadow.ScaleType = Enum.ScaleType.Slice; shadow.SliceCenter = Rect.new(20,20,280,280)

                    -- Internals
                    local innerPad = 6
                    local searchBox, listFrame, header
                    local itemHeight = 22
                    local maxVisible = 7
                    local open = false
                    local anim = false
                    local conns = {}
                    local activeIndex = 1
                    local Dropdown = { id = id, _value = default, _values = {}, _options = {}, _filtered = {}, _itemMap = {}, _onOpen = nil, _onClose = nil, _multi = isMulti, _clickGate = false }
                    -- forward declaration for helper used by context menu below (assigned later)
                    local getMouseGuiPosition

                    -- Context menu state (for multi-select): right-click -> Select All / Unselect All
                    local ctxMenu, ctxOpen = nil, false
                    local ctxBlocker = nil
                    local ctxConns = {}
                    local function ctxDisconnectAll()
                        for i = #ctxConns, 1, -1 do
                            local c = ctxConns[i]
                            if c and c.Disconnect then pcall(function() c:Disconnect() end) end
                            ctxConns[i] = nil
                        end
                    end
                    local function closeCtxMenu()
                        if not ctxOpen then return end
                        ctxOpen = false
                        if ctxBlocker and ctxBlocker.Parent then ctxBlocker:Destroy() end
                        ctxBlocker = nil
                        if ctxMenu and ctxMenu.Parent then ctxMenu:Destroy() end
                        ctxMenu = nil
                        ctxDisconnectAll()
                        if Library and Library._openDropdownCtx == closeCtxMenu then
                            Library._openDropdownCtx = nil
                        end
                    end
                    local function openCtxMenu(input)
                        if not Dropdown._multi then return end
                        -- toggle if already open
                        if ctxOpen then closeCtxMenu(); return end
                        -- Close any other dropdown context menu globally
                        if Library and Library._openDropdownCtx and Library._openDropdownCtx ~= closeCtxMenu then
                            pcall(Library._openDropdownCtx)
                        end
                        ctxOpen = true
                        -- create a full-screen modal blocker to prevent hover/click on other UI and allow right-click-to-close
                        ctxBlocker = Create("TextButton", {AutoButtonColor = false, Modal = false, BackgroundTransparency = 1, Text = "", Size = UDim2.fromScale(1,1), Position = UDim2.fromOffset(0,0), ZIndex = 10999, Parent = RootGui})
                        table.insert(ctxConns, ctxBlocker.MouseButton1Click:Connect(function()
                            closeCtxMenu()
                        end))
                        table.insert(ctxConns, ctxBlocker.MouseButton2Click:Connect(function()
                            closeCtxMenu()
                        end))
                        table.insert(ctxConns, ctxBlocker.TouchTap:Connect(function()
                            closeCtxMenu()
                        end))
                        -- build menu (match library style: solid lib background, standard outline, simple items)
                        local textService = game:GetService("TextService")
                        local labelFont = Fonts.Medium
                        local labelSize = 12
                        local sidePad, vPad, gap, itemH = 10, 6, 2, 24
                        local function measure(text)
                            local sz = textService:GetTextSize(text or "", labelSize, labelFont, Vector2.new(1000, itemH))
                            return sz.X
                        end
                        local maxTextW = math.max(measure("Select All"), measure("Unselect All"))
                        local menuW = math.clamp(math.floor(maxTextW + (sidePad*2) + 8), 140, 220)
                        local finalH = vPad*2 + (itemH*2) + gap
                        ctxMenu = Create("Frame", {BackgroundColor3 = Theme.Bg, BackgroundTransparency = 0, BorderSizePixel = 0, Size = UDim2.fromOffset(menuW, 0), ZIndex = z + 360, ClipsDescendants = true, Parent = root}, {
                            Create("UICorner", {CornerRadius = UDim.new(0,6)}),
                            Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.40})
                        })
                        -- subtle outer shadow like other panels
                        local shadow2 = Create("ImageLabel", {BackgroundTransparency = 1, Image = "rbxassetid://4996891970", ImageColor3 = Theme.Bg, ImageTransparency = 0.92, Size = UDim2.fromScale(1,1), ZIndex = (ctxMenu.ZIndex or 1) - 1, Parent = ctxMenu})
                        shadow2.ScaleType = Enum.ScaleType.Slice; shadow2.SliceCenter = Rect.new(20,20,280,280)
                        -- content container
                        local content = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1, -(sidePad*2), 1, -(vPad*2)), Position = UDim2.fromOffset(sidePad, vPad), ZIndex = ctxMenu.ZIndex + 1, Parent = ctxMenu}, {
                            Create("UIListLayout", {Padding = UDim.new(0, gap), SortOrder = Enum.SortOrder.LayoutOrder})
                        })
                        local function makeItem(text, onClick)
                            local btn = Create("TextButton", {AutoButtonColor = false, BackgroundTransparency = 0, BackgroundColor3 = Theme.Bg, Size = UDim2.new(1, 0, 0, itemH), Text = "", ZIndex = content.ZIndex + 1, Parent = content}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                                Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,8)})
                            })
                            Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Position = UDim2.fromOffset(0,0), Text = text, Font = labelFont, TextSize = labelSize, TextXAlignment = Enum.TextXAlignment.Left, TextColor3 = Theme.Text, Parent = btn})
                            btn.MouseEnter:Connect(function()
                                T(btn,0.10,{BackgroundColor3 = Theme.Hover}):Play()
                            end)
                            btn.MouseLeave:Connect(function()
                                T(btn,0.10,{BackgroundColor3 = Theme.Bg}):Play()
                            end)
                            if btn.Activated then
                                table.insert(ctxConns, btn.Activated:Connect(function()
                                    closeCtxMenu()
                                    onClick()
                                end))
                            else
                                table.insert(ctxConns, btn.MouseButton1Click:Connect(function()
                                    closeCtxMenu()
                                    onClick()
                                end))
                            end
                            return btn
                        end
                        makeItem("Select All", function() Dropdown:SelectAll() end)
                        makeItem("Unselect All", function() Dropdown:UnselectAll() end)
                        -- position above the dropdown, aligned to right edge; flip below when needed
                        local tAbs = trigger.AbsolutePosition
                        local tSz = trigger.AbsoluteSize
                        local rootAbs = root.AbsolutePosition
                        local rootSz = root.AbsoluteSize
                        local menuH = finalH
                        local px = (tAbs.X - rootAbs.X) + tSz.X - menuW
                        local py = (tAbs.Y - rootAbs.Y) - menuH - 6
                        if px < 4 then px = 4 end
                        if px + menuW > rootSz.X - 4 then px = rootSz.X - menuW - 4 end
                        if py < 4 then py = (tAbs.Y - rootAbs.Y) + tSz.Y + 6 end
                        if py + menuH > rootSz.Y - 4 then py = rootSz.Y - menuH - 4 end
                        ctxMenu.Position = UDim2.fromOffset(px, py)
                        -- open animation
                        ctxMenu.Size = UDim2.fromOffset(menuW, 0)
                        local openTw = T(ctxMenu, 0.16, {Size = UDim2.fromOffset(menuW, finalH), BackgroundTransparency = 0})
                        openTw:Play()
                        -- outside click / esc to close
                        table.insert(ctxConns, UserInputService.InputBegan:Connect(function(inp)
                            if not ctxOpen or not ctxMenu or not ctxMenu.Parent then return end
                            if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.MouseButton2 or inp.UserInputType == Enum.UserInputType.Touch then
                                -- inline-adjusted mouse position (avoid dependency on helper creation order)
                                local m
                                if inp and (inp.UserInputType == Enum.UserInputType.Touch) then
                                    m = Vector2.new(inp.Position.X, inp.Position.Y)
                                else
                                    m = UserInputService:GetMouseLocation()
                                end
                                local ok, inset = pcall(function()
                                    return game:GetService("GuiService"):GetGuiInset()
                                end)
                                if ok and typeof(inset) == "Vector2" then
                                    m = Vector2.new(m.X, m.Y - inset.Y)
                                end
                                local p = ctxMenu.AbsolutePosition; local s = ctxMenu.AbsoluteSize
                                local inside = m.X >= p.X and m.X <= p.X+s.X and m.Y >= p.Y and m.Y <= p.Y+s.Y
                                if not inside then closeCtxMenu() end
                            elseif inp.KeyCode == Enum.KeyCode.Escape then
                                closeCtxMenu()
                            end
                        end))
                        -- also close context menu if trigger becomes hidden or removed
                        table.insert(ctxConns, trigger:GetPropertyChangedSignal("Visible"):Connect(function()
                            if ctxOpen and trigger.Visible == false then closeCtxMenu() end
                        end))
                        table.insert(ctxConns, trigger.AncestryChanged:Connect(function()
                            if ctxOpen and not trigger:IsDescendantOf(root) then closeCtxMenu() end
                        end))
                        if Library then Library._openDropdownCtx = closeCtxMenu end
                    end

                    local function refreshLabelFromSelection()
                        if Dropdown._multi then
                            local selectedTexts = {}
                            for _, opt in ipairs(Dropdown._options) do
                                if Dropdown._values[tostring(opt)] then table.insert(selectedTexts, tostring(opt)) end
                            end
                            local count = #selectedTexts
                            if count == 0 then
                                valueLbl.Text = placeholder; valueLbl.TextColor3 = Theme.SubText
                            else
                                if count <= 2 then
                                    valueLbl.Text = table.concat(selectedTexts, ", ")
                                else
                                    valueLbl.Text = ("%d selected"):format(count)
                                end
                                valueLbl.TextColor3 = Theme.Text
                            end
                        else
                            if Dropdown._value == nil then
                                valueLbl.Text = placeholder; valueLbl.TextColor3 = Theme.SubText
                            else
                                valueLbl.Text = tostring(Dropdown._value); valueLbl.TextColor3 = Theme.Text
                            end
                        end
                    end

                    local function disconnectAll()
                        for i = #conns, 1, -1 do
                            local c = conns[i]
                            if c and c.Disconnect then pcall(function() c:Disconnect() end) end
                            conns[i] = nil
                        end
                    end
                    local function source()
                        return Dropdown._filtered[1] and Dropdown._filtered or Dropdown._options
                    end
                    local function clamp(v, lo, hi) if v < lo then return lo elseif v > hi then return hi else return v end end
                    local function positionPanel(finalH)
                        local rootAbs = root.AbsolutePosition
                        local rootSz = root.AbsoluteSize
                        local tAbs = trigger.AbsolutePosition
                        local tSz = trigger.AbsoluteSize
                        local width = tSz.X
                        local px = tAbs.X - rootAbs.X
                        px = clamp(px, 0, math.max(0, rootSz.X - width))
                        local openBelowY = (tAbs.Y - rootAbs.Y) + tSz.Y + 2
                        -- Always open dropdown panels below the trigger (no flip), and clamp within root height
                        local py = openBelowY
                        if finalH then
                            py = math.clamp(py, 4, math.max(4, rootSz.Y - finalH - 4))
                        end
                        panel.Position = UDim2.fromOffset(px, py)
                        panel.Size = UDim2.fromOffset(width, finalH or 0)
                    end
                    local function buildPanel()
                        for _, c in ipairs(panel:GetChildren()) do
                            if c:IsA("ScrollingFrame") or c:IsA("TextBox") or c:IsA("TextLabel") then
                                c:Destroy()
                            end
                        end
                        local y = innerPad
                        if enableSearch then
                            -- external icon on the left of the search box
                            local searchY = y
                            Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.fromOffset(16,24), Position = UDim2.fromOffset(innerPad, searchY), Text = "ðŸ”Ž", Font = Fonts.Medium, TextSize = 12, TextColor3 = Theme.SubText, TextXAlignment = Enum.TextXAlignment.Center, Parent = panel})
                            searchBox = Create("TextBox", {BackgroundColor3 = Theme.Button, ClearTextOnFocus = false, Text = "", PlaceholderText = "Search...", PlaceholderColor3 = Theme.SubText, TextColor3 = Theme.Text, Font = Fonts.Medium, TextSize = 12, TextXAlignment = Enum.TextXAlignment.Center, Size = UDim2.new(1, -(innerPad*2 + 16 + 6), 0, 24), Position = UDim2.fromOffset(innerPad + 16 + 6, searchY), Parent = panel}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,5)}),
                                Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.4})
                            })
                            y = y + 24 + innerPad
                        end
                        listFrame = Create("ScrollingFrame", {BackgroundTransparency = 1, BorderSizePixel = 0, Position = UDim2.fromOffset(innerPad, y), Size = UDim2.new(1, -innerPad*2, 1, -y - innerPad), CanvasSize = UDim2.fromOffset(0,0), AutomaticCanvasSize = Enum.AutomaticSize.Y, ScrollingDirection = Enum.ScrollingDirection.Y, ScrollBarThickness = 2, ScrollBarImageColor3 = Theme.Accent, ZIndex = panel.ZIndex + 1, Parent = panel}, {
                            Create("UIListLayout", {Padding = UDim.new(0,4), SortOrder = Enum.SortOrder.LayoutOrder})
                        })
                    end
                    local function updateSelection()
                        if Dropdown._multi then
                            for key, ref in pairs(Dropdown._itemMap) do
                                if ref and ref.dot then ref.dot.Visible = (Dropdown._values[key] == true) end
                            end
                        else
                            local cur = tostring(Dropdown._value)
                            for key, ref in pairs(Dropdown._itemMap) do
                                if ref and ref.dot then ref.dot.Visible = (key == cur) end
                            end
                        end
                    end
                    local function ensureVisible(index)
                        local layout = listFrame:FindFirstChildOfClass("UIListLayout")
                        if not layout then return end
                        local children = listFrame:GetChildren()
                        local items = {}
                        for _, c in ipairs(children) do if c:IsA("TextButton") then table.insert(items, c) end end
                        local item = items[index]
                        if not item then return end
                        local top = item.AbsolutePosition.Y - listFrame.AbsolutePosition.Y
                        local bottom = top + item.AbsoluteSize.Y
                        local viewTop = listFrame.CanvasPosition.Y
                        local viewBottom = viewTop + listFrame.AbsoluteWindowSize.Y
                        if top < viewTop then
                            listFrame.CanvasPosition = Vector2.new(0, top)
                        elseif bottom > viewBottom then
                            listFrame.CanvasPosition = Vector2.new(0, bottom - listFrame.AbsoluteWindowSize.Y)
                        end
                    end
                    local function renderItems()
                        for _, c in ipairs(listFrame:GetChildren()) do if c:IsA("TextButton") then c:Destroy() end end
                        Dropdown._itemMap = {}
                        local src = source()
                        for _, val in ipairs(src) do
                            local item = Create("TextButton", {AutoButtonColor = false, BackgroundColor3 = Theme.Button, Size = UDim2.new(1,0,0,itemHeight), Text = "", Parent = listFrame, ZIndex = panel.ZIndex + 2}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,5)}),
                                Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.45}),
                                Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,8)})
                            })
                            -- Radio marker (left): ring + inner dot
                            local radio = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(16,16), AnchorPoint = Vector2.new(0,0.5), Position = UDim2.new(0,0,0.5,0), Parent = item})
                            local ring = Create("Frame", {BackgroundColor3 = Theme.Bg, Size = UDim2.fromOffset(16,16), Position = UDim2.fromOffset(0,0), Parent = radio})
                            Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = ring})
                            Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.45, Parent = ring})
                            local dot = Create("Frame", {BackgroundColor3 = Theme.Accent, Size = UDim2.fromOffset(8,8), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.new(0.5,0,0.5,0), Parent = ring})
                            Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = dot})
                            dot.Visible = (Dropdown._multi and Dropdown._values[tostring(val)] == true) or (tostring(Dropdown._value) == tostring(val))
                            local text = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,-24,1,0), Position = UDim2.fromOffset(22,0), Text = tostring(val), Font = Fonts.Medium, TextSize = 12, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = item})
                            item.MouseEnter:Connect(function()
                                T(item,0.12,{BackgroundColor3 = Theme.Hover}):Play()
                                local stroke = item:FindFirstChild("Stroke")
                                if stroke then T(stroke,0.12,{Transparency = 0.35}):Play() end
                            end)
                            item.MouseLeave:Connect(function()
                                T(item,0.12,{BackgroundColor3 = Theme.Button}):Play()
                                local stroke = item:FindFirstChild("Stroke")
                                if stroke then T(stroke,0.12,{Transparency = 0.45}):Play() end
                            end)
                            local function selectUI()
                                if Dropdown._multi then
                                    if Dropdown._clickGate then return end
                                    Dropdown._clickGate = true
                                    Dropdown:Set(val)
                                    task.delay(0.08, function()
                                        Dropdown._clickGate = false
                                    end)
                                else
                                    Dropdown:Set(val)
                                end
                            end
                            -- Use overlay only for click handling to avoid duplicate Down/Click toggles
                            -- Topmost invisible click-catcher to prevent visual children from blocking selection
                            local hit = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = "", Size = UDim2.new(1,0,1,0), Position = UDim2.fromOffset(0,0), Parent = item})
                            hit.ZIndex = (item.ZIndex or 1) + 100
                            if hit.Activated then
                                hit.Activated:Connect(selectUI)
                            else
                                -- Fallback for environments without Activated
                                hit.MouseButton1Click:Connect(selectUI)
                            end
                            local key = tostring(val)
                            Dropdown._itemMap[key] = {item = item, dot = dot}
                        end
                        if #src == 0 then
                            local empty = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,0,itemHeight), Text = "No matches", Font = Fonts.Medium, TextSize = 12, TextColor3 = Theme.SubText, TextXAlignment = Enum.TextXAlignment.Center, Parent = listFrame, ZIndex = panel.ZIndex + 2})
                        end
                        listFrame.CanvasPosition = Vector2.new(0,0)
                    end

                    -- Helper: mouse position adjusted for GUI inset (so we can do accurate bounds checks)
                    getMouseGuiPosition = function(input)
                        local pos
                        if input and (input.UserInputType == Enum.UserInputType.Touch) then
                            pos = Vector2.new(input.Position.X, input.Position.Y)
                        else
                            pos = UserInputService:GetMouseLocation()
                        end
                        -- Subtract top GUI inset so coordinates match AbsolutePosition space
                        local ok, inset = pcall(function()
                            return game:GetService("GuiService"):GetGuiInset()
                        end)
                        if ok and typeof(inset) == "Vector2" then
                            return Vector2.new(pos.X, pos.Y - inset.Y)
                        end
                        return pos
                    end

                    local function openPanel()
                        if open or anim then return end
                        anim = true; open = true
                        T(trigger,0.12,{BackgroundColor3 = Theme.Hover}):Play()
                        local tStroke = trigger:FindFirstChild("Stroke")
                        if tStroke then T(tStroke,0.12,{Transparency = 0.35}):Play() end
                        T(caret,0.16,{TextColor3 = Theme.Text}):Play(); caret.Text = "â–²"

                        closeCtxMenu() -- hide context menu if open
                        buildPanel(); Dropdown._filtered = {}; renderItems();
                        panel.Visible = true; panel.ClipsDescendants = true

                        local count = #source()
                        local searchH = enableSearch and (24 + innerPad) or 0
                        local listH = math.min(count, maxVisible) * (itemHeight + 4)
                        local targetH = math.max(searchH + listH + innerPad, (innerPad*2 + itemHeight))
                        positionPanel(targetH)
                        panel.Size = UDim2.fromOffset(panel.AbsoluteSize.X, 0)
                        local tw = T(panel,0.18,{Size = UDim2.fromOffset(panel.AbsoluteSize.X, targetH)})
                        tw:Play(); tw.Completed:Connect(function() anim = false if type(Dropdown._onOpen)=="function" then pcall(Dropdown._onOpen) end end)

                        if enableSearch and searchBox then
                            table.insert(conns, searchBox:GetPropertyChangedSignal("Text"):Connect(function()
                                local q = (searchBox.Text or ""):lower()
                                Dropdown._filtered = {}
                                if q ~= "" then for _, v in ipairs(Dropdown._options) do if tostring(v):lower():find(q,1,true) then table.insert(Dropdown._filtered, v) end end end
                                activeIndex = 1; renderItems(); ensureVisible(activeIndex)
                            end))
                        end

                        table.insert(conns, UserInputService.InputBegan:Connect(function(input)
                            if not panel.Visible or not open then return end
                            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                                local pos = getMouseGuiPosition(input)
                                local p = panel.AbsolutePosition; local ps = panel.AbsoluteSize
                                local insideP = pos.X >= p.X and pos.X <= p.X+ps.X and pos.Y >= p.Y and pos.Y <= p.Y+ps.Y
                                local b = trigger.AbsolutePosition; local bs = trigger.AbsoluteSize
                                local insideB = pos.X >= b.X and pos.X <= b.X+bs.X and pos.Y >= b.Y and pos.Y <= b.Y+bs.Y
                                local insideC = false
                                if ctxMenu and ctxMenu.Parent then
                                    local c = ctxMenu.AbsolutePosition; local cs = ctxMenu.AbsoluteSize
                                    insideC = pos.X >= c.X and pos.X <= c.X+cs.X and pos.Y >= c.Y and pos.Y <= c.Y+cs.Y
                                end
                                if not insideP and not insideB and not insideC then Dropdown:_closePanel() end
                            elseif input.KeyCode == Enum.KeyCode.Escape then
                                Dropdown:_closePanel()
                            elseif input.KeyCode == Enum.KeyCode.Up then
                                activeIndex = math.max(1, activeIndex - 1); ensureVisible(activeIndex)
                            elseif input.KeyCode == Enum.KeyCode.Down then
                                local n = #source(); activeIndex = math.min(n, activeIndex + 1); ensureVisible(activeIndex)
                            elseif input.KeyCode == Enum.KeyCode.Home then
                                activeIndex = 1; ensureVisible(activeIndex)
                            elseif input.KeyCode == Enum.KeyCode.End then
                                activeIndex = #source(); ensureVisible(activeIndex)
                            elseif input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.KeypadEnter then
                                local src = source(); if src[activeIndex] ~= nil then Dropdown:Set(src[activeIndex]) end
                            end
                        end))

                        -- reposition while open if layout moves
                        table.insert(conns, trigger:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
                            if open then positionPanel(panel.AbsoluteSize.Y) end
                        end))
                        table.insert(conns, root:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                            if open then positionPanel(panel.AbsoluteSize.Y) end
                        end))
                        -- auto-close when trigger hides or is removed (category/section change)
                        table.insert(conns, trigger:GetPropertyChangedSignal("Visible"):Connect(function()
                            if open and trigger.Visible == false then Dropdown:_closePanel() end
                        end))
                        table.insert(conns, trigger.AncestryChanged:Connect(function()
                            if open and not trigger:IsDescendantOf(root) then Dropdown:_closePanel() end
                        end))
                    end
                    function Dropdown:_closePanel()
                        if not open or anim then return end
                        open = false; anim = true
                        closeCtxMenu()
                        T(trigger,0.12,{BackgroundColor3 = Theme.Button}):Play()
                        local tStroke = trigger:FindFirstChild("Stroke")
                        if tStroke then T(tStroke,0.12,{Transparency = 0.45}):Play() end
                        T(caret,0.16,{TextColor3 = Theme.SubText}):Play(); caret.Text = "â–¼"
                        local tw = T(panel,0.18,{Size = UDim2.fromOffset(panel.AbsoluteSize.X, 0)})
                        tw:Play(); tw.Completed:Connect(function() panel.Visible = false; anim = false if type(Dropdown._onClose)=="function" then pcall(Dropdown._onClose) end end)
                        -- Safety unlock in case tween completion is skipped by engine race
                        task.delay(0.35, function()
                            if panel and panel.Parent and panel.Visible and panel.AbsoluteSize.Y <= 1 then
                                panel.Visible = false
                            end
                            anim = false
                        end)
                        disconnectAll()
                    end

                    trigger.MouseEnter:Connect(function()
                        if not open and not anim then
                            T(trigger,0.12,{BackgroundColor3 = Theme.Hover}):Play()
                            local s = trigger:FindFirstChild("Stroke"); if s then T(s,0.12,{Transparency = 0.35}):Play() end
                        end
                    end)
                    trigger.MouseLeave:Connect(function()
                        if not open and not anim then
                            T(trigger,0.12,{BackgroundColor3 = Theme.Button}):Play()
                            local s = trigger:FindFirstChild("Stroke"); if s then T(s,0.12,{Transparency = 0.45}):Play() end
                        end
                    end)
                    trigger.MouseButton1Click:Connect(function() if open then Dropdown:_closePanel() else openPanel() end end)
                    -- Right-click context menu for multi-select
                    trigger.MouseButton2Click:Connect(function(input)
                        if Dropdown._multi then openCtxMenu(input) end
                    end)

                    -- Public controls
                    function Dropdown:Open()
                        openPanel()
                    end
                    function Dropdown:Close()
                        self:_closePanel()
                    end
                    function Dropdown:Toggle()
                        if open then self:_closePanel() else openPanel() end
                    end

                    function Dropdown:Get()
                        if self._multi then
                            local list = {}
                            for _, opt in ipairs(self._options) do if self._values[tostring(opt)] then table.insert(list, opt) end end
                            return list
                        end
                        return self._value
                    end
                    local function resolveOption(v)
                        if table.find(Dropdown._options, v) then return v end
                        local sv = tostring(v)
                        for _, opt in ipairs(Dropdown._options) do if tostring(opt) == sv then return opt end end
                        return nil
                    end
                    function Dropdown:Set(v, silent)
                        if self._multi then
                            if v == nil then
                                self._values = {}
                            else
                                if type(v) == "table" then
                                    local newSet = {}
                                    for _, item in ipairs(v) do
                                        local r = resolveOption(item)
                                        if r ~= nil then newSet[tostring(r)] = true end
                                    end
                                    self._values = newSet
                                else
                                    local resolved = resolveOption(v); if not self._options or not resolved then return end
                                    local key = tostring(resolved)
                                    if self._values[key] then self._values[key] = nil else self._values[key] = true end
                                end
                            end
                            updateSelection(); refreshLabelFromSelection()
                            -- Don't auto-close for multi-select
                            if not silent and type(cb)=="function" then pcall(cb, self:Get()) end
                            return
                        end
                        -- single-select behavior
                        if v == nil then
                            self._value = nil
                            refreshLabelFromSelection()
                            if open then Dropdown:_closePanel() end
                            return
                        end
                        local resolved = resolveOption(v); if not self._options or not resolved then return end
                        self._value = resolved
                        refreshLabelFromSelection(); updateSelection();
                        if open then Dropdown:_closePanel() end
                        if not silent and type(cb)=="function" then pcall(cb, resolved) end
                    end
                    function Dropdown:SetOptions(nl)
                        self._options = {}
                        for _, val in ipairs(nl or {}) do table.insert(self._options, val) end
                        Dropdown._filtered = {}
                        if self._multi then
                            -- prune selections that no longer exist
                            local valid = {}
                            for _, opt in ipairs(self._options) do valid[tostring(opt)] = true end
                            for key, _ in pairs(self._values) do if not valid[key] then self._values[key] = nil end end
                        end
                        if panel.Visible then buildPanel(); renderItems(); updateSelection() end
                        refreshLabelFromSelection()
                    end
                    -- Public helpers for multi-select
                    function Dropdown:SelectAll(silent)
                        if not self._multi then return end
                        local newSet = {}
                        for _, opt in ipairs(self._options) do newSet[tostring(opt)] = true end
                        self._values = newSet
                        updateSelection(); refreshLabelFromSelection()
                        if not silent and type(cb)=="function" then pcall(cb, self:Get()) end
                    end
                    function Dropdown:UnselectAll(silent)
                        if not self._multi then return end
                        self._values = {}
                        updateSelection(); refreshLabelFromSelection()
                        if not silent and type(cb)=="function" then pcall(cb, self:Get()) end
                    end
                    function Dropdown:OnOpen(fn) self._onOpen = fn end
                    function Dropdown:OnClose(fn) self._onClose = fn end
                    function Dropdown:FocusSearch() if enableSearch and searchBox then pcall(function() searchBox:CaptureFocus() end) end end

                    Dropdown:SetOptions(options)
                    -- Initialize default(s)
                    if default ~= nil then
                        if isMulti then
                            if type(default) == "table" then Dropdown:Set(default, true) else Dropdown:Set({default}, true) end
                        else
                            Dropdown:Set(default, true)
                        end
                    end
                    refreshLabelFromSelection()
                    Library:_registerControl(Dropdown)
                    table.insert(Group._controls, Dropdown)
                    registerSearch(label)
                    return Dropdown
                end
                -- Textbox
                function Group:AddTextbox(o)
                    o = o or {}
                    local label = tostring(o.Name or "Text")
                    local placeholder = tostring(o.Placeholder or "")
                    local default = tostring(o.Default or "")
                    local cb = o.Callback
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,30), Position = UDim2.fromOffset(0,nextY(30)), Parent = gFrame})
                    -- Align label/input split with dropdown (label 42%, input 58%), and match right margin (-4/+4)
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(0.42,-6,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})
                    local box = Create("TextBox", {BackgroundColor3 = Theme.Button, Size = UDim2.new(0.58,-4,1,0), Position = UDim2.new(0.42,4,0,0), ClearTextOnFocus = false, PlaceholderText = placeholder, Text = default, Font = Fonts.Regular, TextSize = 13, TextColor3 = Theme.Text, PlaceholderColor3 = Theme.SubText, Parent = row}, {
                        Create("UICorner", {CornerRadius = UDim.new(0,3)}),
                        Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.55}),
                        Create("UIPadding", {PaddingLeft = UDim.new(0,6), PaddingRight = UDim.new(0,6)})
                    })
                    local focusBar = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0,0,0,2), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,0,1,0), BackgroundTransparency = 1, Parent = box})
                    local Textbox = { id = id, _value = default }
                    function Textbox:Get() return self._value end
                    function Textbox:Set(v, silent) v = tostring(v or "") self._value = v box.Text = v if not silent and type(cb)=="function" then pcall(cb,v) end end
                    -- One-time clear on first focus if it's still showing the default text
                    local _clearedOnce = false
                    box.Focused:Connect(function()
                        if not _clearedOnce and (box.Text == tostring(default or "")) then
                            box.Text = ""
                            _clearedOnce = true
                        end
                        focusBar.BackgroundTransparency = 0
                        focusBar.Size = UDim2.new(0,0,0,2)
                        T(focusBar,0.20,{Size = UDim2.new(1,0,0,2)}):Play()
                        T(box.Stroke,0.15,{Transparency = 0.35}):Play()
                    end)
                    box.FocusLost:Connect(function()
                        Textbox:Set(box.Text)
                        local tw1 = T(focusBar,0.18,{Size = UDim2.new(0,0,0,2)})
                        tw1:Play()
                        tw1.Completed:Connect(function() focusBar.BackgroundTransparency = 1 end)
                        T(box.Stroke,0.18,{Transparency = 0.55}):Play()
                    end)
                    Library:_registerControl(Textbox)
                    table.insert(Group._controls, Textbox)
                    registerSearch(label)
                    return Textbox
                end
                -- Paragraph (note text / read-only, flag updatable)
                function Group:AddParagraph(o)
                    o = o or {}
                    local label = tostring(o.Name or "Paragraph")
                    local text = tostring(o.Text or o.Value or "")
                    local cb = o.Callback -- optional: fire when text changes via Set
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)
                    local h = tonumber(o.Height) or 48
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,h), Position = UDim2.fromOffset(0,nextY(h)), Parent = gFrame})
                    local box = Create("Frame", {BackgroundColor3 = Theme.Button, Size = UDim2.new(1,0,1,0), Parent = row}, {
                        Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                        Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.45}),
                        Create("UIPadding", {PaddingLeft = UDim.new(0,10), PaddingRight = UDim.new(0,10), PaddingTop = UDim.new(0,8), PaddingBottom = UDim.new(0,8)})
                    })
                    local txt = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), TextWrapped = true, Text = text, Font = Fonts.Regular, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Top, Parent = box})
                    -- Auto-resize helpers: compute required height and reflow following controls
                    local function measureNeededHeight(str)
                        local availW = math.max(20, row.AbsoluteSize.X - 20) -- account for 10px left/right padding
                        local sz = TextService:GetTextSize(tostring(str or ""), 13, Fonts.Regular, Vector2.new(availW, math.huge))
                        local innerPadY = 8 + 8
                        local need = math.max(h, sz.Y + innerPadY)
                        return need
                    end
                    local function reflowToHeight(newH)
                        newH = math.floor(newH + 0.5)
                        local oldH = row.Size.Y.Offset
                        if newH == oldH then return end
                        local baseY = row.Position.Y.Offset
                        local delta = newH - oldH
                        row.Size = UDim2.new(row.Size.X.Scale, row.Size.X.Offset, 0, newH)
                        -- Shift subsequent siblings down/up by delta
                        for _, child in ipairs(gFrame:GetChildren()) do
                            if child ~= row and child:IsA("GuiObject") then
                                local pos = child.Position
                                if pos.Y.Scale == 0 and pos.X.Scale == 0 and pos.Y.Offset > baseY then
                                    child.Position = UDim2.new(pos.X.Scale, pos.X.Offset, pos.Y.Scale, pos.Y.Offset + delta)
                                end
                            end
                        end
                        -- Update running y so future nextY placements are correct
                        y = y + delta
                    end
                    local function resizeNow()
                        -- Defer if width is zero (not laid out yet)
                        if row.AbsoluteSize.X <= 0 then
                            task.defer(resizeNow)
                            return
                        end
                        local need = measureNeededHeight(txt.Text)
                        reflowToHeight(need)
                    end
                    -- hover feedback like other controls
                    box.MouseEnter:Connect(function()
                        T(box,0.12,{BackgroundColor3 = Theme.Hover}):Play()
                        local s = box:FindFirstChild("Stroke"); if s then T(s,0.12,{Transparency = 0.25}):Play() end
                    end)
                    box.MouseLeave:Connect(function()
                        T(box,0.12,{BackgroundColor3 = Theme.Button}):Play()
                        local s = box:FindFirstChild("Stroke"); if s then T(s,0.12,{Transparency = 0.45}):Play() end
                    end)
                    local Paragraph = { id = id, _value = text, _label = label, _row = row, _box = box, _text = txt }
                    function Paragraph:Get() return self._value end
                    function Paragraph:Set(v, silent)
                        v = tostring(v or "")
                        self._value = v
                        txt.Text = v
                        resizeNow()
                        if not silent and type(cb) == "function" then pcall(cb, v) end
                    end
                    -- react to width changes (window resize / column change)
                    row:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                        resizeNow()
                    end)
                    gFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                        resizeNow()
                    end)
                    -- initial size pass (after mount)
                    task.defer(resizeNow)
                    Library:_registerControl(Paragraph)
                    table.insert(Group._controls, Paragraph)
                    registerSearch(label)
                    return Paragraph
                end
                -- Keybind
                function Group:AddKeybind(o)
                    o = o or {}
                    local label = tostring(o.Name or "Keybind")
                    local default = o.Default
                    local cb = o.Callback
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,0,0,30), Position = UDim2.fromOffset(0,nextY(30)), Parent = gFrame})
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(0.5,-8,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})
                    local box = Create("TextButton", {BackgroundColor3 = Theme.Button, AutoButtonColor = false, Size = UDim2.new(0.5,-4,1,0), Position = UDim2.new(0.5,4,0,0), Text = default and default.Name or "Press a key...", Font = Fonts.Regular, TextSize = 13, TextColor3 = Theme.SubText, Parent = row}, {Create("UICorner", {CornerRadius = UDim.new(0,4)}), Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})})
                    -- Focus line (like Textbox) shown during capture
                    local focusBar = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0,0,0,2), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,0,1,0), BackgroundTransparency = 1, Parent = box})
                    local stroke = box:FindFirstChild("Stroke")
                    local waiting = false
                    local actionName = "DendriteKeybindCapture_" .. id
                    

                    local function startVisual()
                        -- Show bottom accent line and slightly emphasize stroke; keep background unchanged
                        if focusBar then
                            focusBar.BackgroundTransparency = 0
                            focusBar.Size = UDim2.new(0,0,0,2)
                            T(focusBar,0.20,{Size = UDim2.new(1,0,0,2)}):Play()
                        end
                        if stroke then T(stroke,0.15,{Transparency = 0.18}):Play() end
                    end

                    local function stopVisual()
                        -- Hide bottom accent line and reset stroke emphasis
                        if focusBar then
                            local tw1 = T(focusBar,0.18,{Size = UDim2.new(0,0,0,2)})
                            tw1:Play()
                            tw1.Completed:Connect(function()
                                if focusBar.Parent then focusBar.BackgroundTransparency = 1 end
                            end)
                        end
                        if stroke then T(stroke,0.18,{Transparency = 0.3}):Play() end
                    end

                    local Keybind = { id = id, _value = default }
                    function Keybind:Get() return self._value end
                    function Keybind:Set(keycode, silent)
                        self._value = keycode
                        box.Text = keycode and keycode.Name or "None"
                        box.TextColor3 = keycode and Theme.Text or Theme.SubText
                        box.Font = Fonts.Regular
                        if keycode and not silent and type(cb) == "function" then pcall(cb, keycode) end
                    end

                    local function unbindSink()
                        pcall(function() ContextActionService:UnbindAction(actionName) end)
                    end

                    local function bindSink()
                        local function handler(_, state, input)
                            if not waiting then return Enum.ContextActionResult.Pass end
                            if state ~= Enum.UserInputState.Begin then return Enum.ContextActionResult.Sink end
                            if input.UserInputType == Enum.UserInputType.Keyboard then
                                waiting = false
                                Keybind:Set(input.KeyCode)
                                stopVisual()
                                unbindSink()
                            end
                            return Enum.ContextActionResult.Sink
                        end
                        -- sink all keyboard keys while capturing
                        local keys = Enum.KeyCode:GetEnumItems()
                        ContextActionService:BindAction(actionName, handler, false, table.unpack(keys))
                    end

                    box.MouseButton1Click:Connect(function()
                        waiting = true
                        box.Text = "..."
                        box.Font = Fonts.Regular
                        box.TextColor3 = Theme.Text
                        startVisual()
                        bindSink()
                    end)

                    -- Fallback: still listen to InputBegan (in case CAS is unavailable)
                    UserInputService.InputBegan:Connect(function(input)
                        if waiting and input.UserInputType == Enum.UserInputType.Keyboard then
                            waiting = false
                            Keybind:Set(input.KeyCode)
                            stopVisual()
                            unbindSink()
                        elseif waiting and input.KeyCode == Enum.KeyCode.Escape then
                            -- cancel capture with ESC
                            waiting = false
                            stopVisual()
                            unbindSink()
                            box.Text = Keybind._value and Keybind._value.Name or "None"
                            box.TextColor3 = Keybind._value and Theme.Text or Theme.SubText
                            box.Font = Fonts.Regular
                        end
                    end)

                    Library:_registerControl(Keybind)
                    table.insert(Group._controls, Keybind)
                    registerSearch(label)
                    return Keybind
                end
                -- Colorpicker
                function Group:AddColorpicker(o)
                    o = o or {}
                    local label = tostring(o.Name or "Color")
                    local cb = o.Callback
                    local amount = math.max(1, tonumber(o.Amount) or 1)
                    -- Always start with Rainbow off; per-slot toggle only
                    local startRainbow = false
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)
                    -- helpers
                    local function clamp01(x) if x < 0 then return 0 elseif x > 1 then return 1 else return x end end
                    local function toRGB255(c)
                        return math.floor(c.R*255+0.5), math.floor(c.G*255+0.5), math.floor(c.B*255+0.5)
                    end
                    local function rgbToHex(r,g,b)
                        return string.format("#%02X%02X%02X", math.clamp(r,0,255), math.clamp(g,0,255), math.clamp(b,0,255))
                    end
                    local function hexToRGB(hex)
                        hex = tostring(hex or ""):gsub("^#","")
                        if #hex == 6 then
                            local r = tonumber(hex:sub(1,2),16)
                            local g = tonumber(hex:sub(3,4),16)
                            local b = tonumber(hex:sub(5,6),16)
                            if r and g and b then return r,g,b end
                        end
                        return nil
                    end
                    local function parseRGBText(t)
                        -- accept formats like "255,255,255" or "255, 255, 255"
                        local r,g,b = t:match("%s*(%d+)%s*,%s*(%d+)%s*,%s*(%d+)%s*")
                        if r and g and b then return tonumber(r), tonumber(g), tonumber(b) end
                        return nil
                    end

                    -- rainbow sync bus
                    Library._rainbowBus = Library._rainbowBus or { listeners = {}, conn = nil }
                    local function rainbowStart()
                        if Library._rainbowBus.conn then return end
                        local RS = game:GetService("RunService")
                        local t0 = tick()
                        Library._rainbowBus.conn = RS.RenderStepped:Connect(function()
                            local t = (tick() - t0) * 0.08 -- speed
                            local h = t % 1
                            for _, fn in ipairs(Library._rainbowBus.listeners) do
                                pcall(fn, h)
                            end
                        end)
                    end
                    local function rainbowAdd(fn)
                        table.insert(Library._rainbowBus.listeners, fn)
                        rainbowStart()
                        return fn
                    end
                    local function rainbowRemove(fn)
                        for i=#Library._rainbowBus.listeners,1,-1 do
                            if Library._rainbowBus.listeners[i] == fn then table.remove(Library._rainbowBus.listeners,i) end
                        end
                        if #Library._rainbowBus.listeners == 0 and Library._rainbowBus.conn then
                            Library._rainbowBus.conn:Disconnect(); Library._rainbowBus.conn = nil
                        end
                    end

                    -- Resolve defaults per slot
                    local defaults = {}
                    local function colorFromAny(v)
                        if typeof(v) == "Color3" then return v end
                        if type(v) == "table" and v.r and v.g and v.b then return Color3.fromRGB(v.r, v.g, v.b) end
                        if type(v) == "string" then
                            local r,g,b = parseRGBText(v)
                            if r then return Color3.fromRGB(r,g,b) end
                            local hr,hg,hb = hexToRGB(v)
                            if hr then return Color3.fromRGB(hr,hg,hb) end
                        end
                        return Theme.Accent
                    end
                    -- accept Default or Value as initial colors
                    local init = (o.Default ~= nil) and o.Default or o.Value
                    if type(init) == "table" and amount > 1 then
                        for i=1, amount do defaults[i] = colorFromAny(init[i]) end
                    else
                        local c = colorFromAny(init)
                        for i=1, amount do defaults[i] = c end
                    end

                    -- build row
                    local rowH = 30
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,rowH), Position = UDim2.fromOffset(0,nextY(rowH)), Parent = gFrame})
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(0.42,-6,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})
                    local holder = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(0.58,-4,1,0), Position = UDim2.new(0.42,4,0,0), Parent = row}, {
                        Create("UIPadding", {PaddingLeft = UDim.new(0,0), PaddingRight = UDim.new(0,0)})
                    })
                    local layout = Create("UIListLayout", {Parent = holder, FillDirection = Enum.FillDirection.Horizontal, Padding = UDim.new(0,6), HorizontalAlignment = Enum.HorizontalAlignment.Right, VerticalAlignment = Enum.VerticalAlignment.Center})

                    -- state per slot
                    local slots = {}
                    for i=1, amount do
                        local btn = Create("TextButton", {AutoButtonColor = false, BackgroundColor3 = Theme.Button, Size = UDim2.fromOffset(26,26), Text = "", Parent = holder}, {
                            Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                            Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.35})
                        })
                        local fill = Create("Frame", {BackgroundColor3 = defaults[i], Size = UDim2.new(1,-6,1,-6), Position = UDim2.fromOffset(3,3), Parent = btn}, {
                            Create("UICorner", {CornerRadius = UDim.new(0,3)})
                        })
                        btn.MouseEnter:Connect(function() T(btn,0.12,{BackgroundColor3 = Theme.Hover}):Play(); local s = btn:FindFirstChild("Stroke"); if s then T(s,0.12,{Transparency = 0.25}):Play() end end)
                        btn.MouseLeave:Connect(function() T(btn,0.12,{BackgroundColor3 = Theme.Button}):Play(); local s = btn:FindFirstChild("Stroke"); if s then T(s,0.12,{Transparency = 0.35}):Play() end end)
                        slots[i] = { btn = btn, fill = fill, color = defaults[i], hsv = { Color3.toHSV(defaults[i]) }, rainbow = startRainbow, rainbowHook = nil, pulse = false, pulseHook = nil }
                    end

                    -- panel singleton per control
                    local panel, open, anim = nil, false, false
                    local panelBlocker = nil
                    local activeIndex = 1
                    local conns = {}
                    local function disconnectAll()
                        for i=#conns,1,-1 do conns[i]:Disconnect(); table.remove(conns,i) end
                    end

                    -- Clipboard helpers (exploit env)
                    local function copyText(s)
                        if typeof(setclipboard) == "function" then pcall(setclipboard, s) end
                        Library._clipboardColor = s
                    end
                    local function pasteText()
                        if typeof(getclipboard) == "function" then local ok, v = pcall(getclipboard); if ok then return v end end
                        return Library._clipboardColor
                    end

                    -- context menu (right click)
                    local ctxMenu, ctxOpen
                    local ctxBlocker = nil
                    local ctxConns = {}
                    local function ctxDisconnectAll()
                        for i=#ctxConns,1,-1 do ctxConns[i]:Disconnect(); table.remove(ctxConns,i) end
                    end
                    local function closeCtx()
                        if not ctxOpen or not ctxMenu then return end
                        ctxOpen = false
                        ctxDisconnectAll()
                        if ctxBlocker and ctxBlocker.Parent then pcall(function() ctxBlocker:Destroy() end) end
                        ctxBlocker = nil
                        -- Destroy immediately to avoid stuck animation when spamming clicks
                        pcall(function() if ctxMenu then ctxMenu:Destroy() end end)
                        ctxMenu = nil
                        if Library._openColorCtxClose == closeCtx then Library._openColorCtxClose = nil end
                    end
                    local function openCtx(btnFor)
                        if Library._openColorCtxClose and Library._openColorCtxClose ~= closeCtx then pcall(Library._openColorCtxClose) end
                        closeCtx()
                        if ctxMenu then pcall(function() ctxMenu:Destroy() end); ctxMenu=nil end
                        -- Create modal blocker to capture outside clicks and block underlying UI across the whole screen
                        local menuZBase = 12000
                        ctxBlocker = Create("TextButton", {AutoButtonColor = false, Modal = false, BackgroundTransparency = 1, Text = "", Size = UDim2.fromScale(1,1), Position = UDim2.fromOffset(0,0), ZIndex = menuZBase, Parent = RootGui})
                        table.insert(ctxConns, ctxBlocker.MouseButton1Click:Connect(function() closeCtx() end))
                        table.insert(ctxConns, ctxBlocker.MouseButton2Click:Connect(function() closeCtx() end))
                        table.insert(ctxConns, ctxBlocker.TouchTap:Connect(function() closeCtx() end))
                        -- Match multi-dropdown menu visuals (padding, corner radius, outline, hover behavior)
                        local textService = game:GetService("TextService")
                        local labelFont = Fonts.Medium
                        local labelSize = 12
                        local sidePad, vPad, gap, itemH = 10, 6, 2, 24
                        local function measure(text)
                            local sz = textService:GetTextSize(text or "", labelSize, labelFont, Vector2.new(1000, itemH))
                            return sz.X
                        end
                        local maxTextW = math.max(measure("Copy Value"), measure("Paste Value"))
                        local menuW = math.clamp(math.floor(maxTextW + (sidePad*2) + 8), 140, 220)
                        ctxMenu = Create("Frame", {BackgroundColor3 = Theme.Bg, BackgroundTransparency = 0, BorderSizePixel = 0, Size = UDim2.fromOffset(menuW,0), ZIndex = menuZBase + 1, ClipsDescendants = true, Parent = RootGui}, {
                            Create("UICorner", {CornerRadius = UDim.new(0,6)}),
                            Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.40})
                        })
                        local shadow2 = Create("ImageLabel", {BackgroundTransparency = 1, Image = "rbxassetid://4996891970", ImageColor3 = Theme.Bg, ImageTransparency = 0.92, Size = UDim2.fromScale(1,1), ZIndex = (ctxMenu.ZIndex or 1)-1, Parent = ctxMenu})
                        shadow2.ScaleType = Enum.ScaleType.Slice; shadow2.SliceCenter = Rect.new(20,20,280,280)
                        local content = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1, -(sidePad*2), 1, -(vPad*2)), Position = UDim2.fromOffset(sidePad, vPad), ZIndex = ctxMenu.ZIndex + 1, Parent = ctxMenu}, {
                            Create("UIListLayout", {Padding = UDim.new(0,gap), SortOrder = Enum.SortOrder.LayoutOrder})
                        })
                        local function item(text, on)
                            local btn = Create("TextButton", {AutoButtonColor = false, BackgroundTransparency = 0, BackgroundColor3 = Theme.Bg, Size = UDim2.new(1,0,0,itemH), Text = "", ZIndex = content.ZIndex + 1, Parent = content}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                                Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,8)})
                            })
                            Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Position = UDim2.fromOffset(0,0), Text = text, Font = labelFont, TextSize = labelSize, TextXAlignment = Enum.TextXAlignment.Left, TextColor3 = Theme.Text, Parent = btn})
                            btn.MouseEnter:Connect(function() T(btn,0.10,{BackgroundColor3 = Theme.Hover}):Play() end)
                            btn.MouseLeave:Connect(function() T(btn,0.10,{BackgroundColor3 = Theme.Bg}):Play() end)
                            btn.MouseButton1Click:Connect(function() on(); closeCtx() end)
                            return btn
                        end
                        item("Copy Value", function()
                            local c = slots[activeIndex].color
                            local r,g,b = toRGB255(c)
                            copyText(string.format("%d, %d, %d", r,g,b))
                        end)
                        item("Paste Value", function()
                            local txt = pasteText()
                            if not txt then return end
                            local r,g,b = parseRGBText(txt)
                            if not r then local hr,hg,hb = hexToRGB(txt); if hr then r,g,b = hr,hg,hb end end
                            if r then
                                local c = Color3.fromRGB(r,g,b)
                                slots[activeIndex].hsv = { Color3.toHSV(c) }
                                slots[activeIndex].color = c
                                slots[activeIndex].fill.BackgroundColor3 = c
                                if type(cb)=="function" then pcall(cb, c, activeIndex) end
                            end
                        end)
                        -- position near btnFor
                        local finalH = vPad*2 + (itemH*2) + gap
                        local tAbs, tSz = btnFor.AbsolutePosition, btnFor.AbsoluteSize
                        local rootAbs, rootSz = root.AbsolutePosition, root.AbsoluteSize
                        -- align to bottom-right of the swatch (same right edge as the colorpicker panel above)
                        local px = (tAbs.X - rootAbs.X) + tSz.X - menuW
                        local py = (tAbs.Y - rootAbs.Y) + tSz.Y + 6
                        -- clamp within root
                        px = math.clamp(px, 4, rootSz.X - menuW - 4)
                        py = math.clamp(py, 4, rootSz.Y - finalH - 4)
                        -- parented to RootGui, so convert to absolute screen coords by adding rootAbs
                        ctxMenu.Position = UDim2.fromOffset(rootAbs.X + px, rootAbs.Y + py)
                        ctxMenu.Size = UDim2.fromOffset(menuW,0)
                        local tw = T(ctxMenu,0.14,{Size = UDim2.fromOffset(menuW, finalH), BackgroundTransparency = 0})
                        tw:Play(); ctxOpen = true
                        -- No ESC handler; close via mouse/touch/blocker only
                        Library._openColorCtxClose = closeCtx
                        -- Swallow clicks on menu content so they don't bubble to blocker
                        table.insert(ctxConns, ctxMenu.InputBegan:Connect(function() end))
                    end

                    -- Build color panel (once)
                    local sv, svWhite, svBlack, svCursor
                    local hueSlider, hueGrab
                    local rgbBox, hexBox
                    local rainbowToggle -- simple small toggle
                    local function hsvToColor(hsv)
                        return Color3.fromHSV(clamp01(hsv[1] or 0), clamp01(hsv[2] or 0), clamp01(hsv[3] or 0))
                    end
                    local function updateSVBackground(h)
                        if sv then sv.BackgroundColor3 = Color3.fromHSV(h,1,1) end
                    end
                    local function applyColorFromHSV(index)
                        local hsv = slots[index].hsv
                        local c = hsvToColor(hsv)
                        slots[index].color = c
                        slots[index].fill.BackgroundColor3 = c
                        -- update inputs
                        if rgbBox then local r,g,b = toRGB255(c); rgbBox.Text = string.format("%d, %d, %d", r,g,b) end
                        if hexBox then local r,g,b = toRGB255(c); hexBox.Text = rgbToHex(r,g,b) end
                        if type(cb)=="function" then pcall(cb, c, index) end
                    end
                    local function setHSV(index, h,s,v)
                        local H,S,V = slots[index].hsv[1], slots[index].hsv[2], slots[index].hsv[3]
                        if h~=nil then H=h end; if s~=nil then S=s end; if v~=nil then V=v end
                        slots[index].hsv = { clamp01(H), clamp01(S), clamp01(V) }
                        updateSVBackground(H)
                        applyColorFromHSV(index)
                    end

                    -- helper: attach rainbow animation to a specific slot index, updating UI only if it's the active one
                    local function attachRainbow(i)
                        local slot = slots[i]
                        return rainbowAdd(function(h)
                            local s,v = slot.hsv[2], slot.hsv[3]
                            slot.hsv = {h,s,v}
                            if open and activeIndex == i then
                                updateSVBackground(h)
                                if hueSlider and hueGrab then hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), h * hueSlider.AbsoluteSize.Y) end
                                applyColorFromHSV(i)
                            else
                                -- update color silently when not active
                                local c = hsvToColor(slot.hsv)
                                slot.color = c
                                slot.fill.BackgroundColor3 = c
                                if type(cb) == "function" then pcall(cb, c, i) end
                            end
                        end)
                    end

                    local function openPanel(btnFor, index)
                        if anim then return end
                        -- toggle close if clicking the same swatch while open
                        if open and panel and activeIndex == index then
                            if Library._openColorPanelClose then pcall(Library._openColorPanelClose); Library._openColorPanelClose = nil end
                            return
                        end
                        if open and panel then
                            -- retarget existing panel to new slot
                            activeIndex = index
                            -- reposition near new button
                            local tAbs, tSz = btnFor.AbsolutePosition, btnFor.AbsoluteSize
                            local rootAbs, rootSz = root.AbsolutePosition, root.AbsoluteSize
                            local width, height = panel.AbsoluteSize.X, panel.AbsoluteSize.Y
                            -- Align right edge of panel with swatch; place above by 6px
                            local px = tAbs.X + tSz.X - width
                            local py = tAbs.Y - height
                            px = math.clamp(px, rootAbs.X + 4, rootAbs.X + rootSz.X - width - 4)
                            py = math.clamp(py, rootAbs.Y + 4, rootAbs.Y + rootSz.Y - height - 4)
                            panel.Position = UDim2.fromOffset(px, py)
                            -- refresh UI to the selected slot
                            local h,s,v = table.unpack(slots[index].hsv)
                            updateSVBackground(h)
                            if svCursor and sv then svCursor.Position = UDim2.fromOffset(s*(sv.AbsoluteSize.X), (1-v)*(sv.AbsoluteSize.Y)) end
                            if hueGrab and hueSlider then hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), h*(hueSlider.AbsoluteSize.Y)) end
                            if rgbBox then local r,g,b = toRGB255(slots[index].color); rgbBox.Text = string.format("%d, %d, %d", r,g,b) end
                            if hexBox then local r,g,b = toRGB255(slots[index].color); hexBox.Text = rgbToHex(r,g,b) end
                            if setCheckbox then local slot = slots[index]; setCheckbox(slot.rainbow); setPulseCheckbox(slot.pulse) end
                            return
                        end
                        open = true; anim = true; activeIndex = index
                        if not panel then
                            panel = Create("TextButton", {AutoButtonColor = false, Text = "", BackgroundColor3 = Theme.Bg, BorderSizePixel = 0, Visible = false, Size = UDim2.fromOffset(0,0), ZIndex = 12000, Parent = RootGui}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                                -- Main holder outline (panel)
                                Create("UIStroke", {Name = "Stroke", ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})
                            })
                            local shadow = Create("ImageLabel", {BackgroundTransparency = 1, Image = "rbxassetid://4996891970", ImageColor3 = Theme.Bg, ImageTransparency = 0.85, Size = UDim2.fromScale(1,1), ZIndex = panel.ZIndex - 1, Parent = panel})
                            shadow.ScaleType = Enum.ScaleType.Slice; shadow.SliceCenter = Rect.new(20,20,280,280)

                            -- content
                            local pad = 6
                            -- Main inner container (the frame that holds SV, inputs, and hue/checkbox)
                            local container = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-pad*2,1,-pad*2), Position = UDim2.fromOffset(pad,pad), ZIndex = panel.ZIndex + 1, Parent = panel}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,4)})
                            })
                            local content = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromScale(1,1), ZIndex = container.ZIndex + 1, Parent = container}, {
                                Create("UIListLayout", {Padding = UDim.new(0,2), FillDirection = Enum.FillDirection.Horizontal, SortOrder = Enum.SortOrder.LayoutOrder})
                            })
                            -- (Removed overlay border; using panel's own stroke so it outlines the true main holder)
                            -- Left: SV square (S across X, V across Y), base hue set by slider; plus RGB/Hex inputs
                            local leftCol = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(210, 210), ZIndex = content.ZIndex + 1, Parent = content})
                            sv = Create("Frame", {Active = true, BackgroundTransparency = 0, BackgroundColor3 = Color3.fromHSV(0,1,1), Size = UDim2.fromOffset(180, 150), ZIndex = leftCol.ZIndex + 1, Parent = leftCol})
                            Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = sv})
                            Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3, Parent = sv})
                            -- White overlay: left side white (S=0) to right transparent (S=1)
                            svWhite = Create("Frame", {Active = true, BackgroundTransparency = 0, BackgroundColor3 = Color3.fromRGB(255,255,255), Size = UDim2.fromScale(1,1), ZIndex = sv.ZIndex + 1, Parent = sv})
                            local gWhite = Instance.new("UIGradient"); gWhite.Rotation = 0; gWhite.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(1,1)}); gWhite.Parent = svWhite
                            -- Black overlay: top transparent (V=1) to bottom black (V=0)
                            svBlack = Create("Frame", {Active = true, BackgroundTransparency = 0, BackgroundColor3 = Color3.fromRGB(0,0,0), Size = UDim2.fromScale(1,1), ZIndex = sv.ZIndex + 2, Parent = sv})
                            local gBlack = Instance.new("UIGradient"); gBlack.Rotation = 90; gBlack.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1), NumberSequenceKeypoint.new(1,0)}); gBlack.Parent = svBlack
                            -- Cursor
                            svCursor = Create("Frame", {BackgroundColor3 = Theme.Bg, Size = UDim2.fromOffset(10,10), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.fromOffset(0,0), ZIndex = sv.ZIndex + 3, Parent = sv}, {Create("UICorner", {CornerRadius = UDim.new(1,0)}), Create("UIStroke", {Color = Theme.Accent, Thickness = 1, Transparency = 0})})

                            rgbBox = Create("TextBox", {BackgroundColor3 = Theme.Button, ClearTextOnFocus = false, Text = "", PlaceholderText = "R, G, B", Font = Fonts.Regular, TextSize = 12, TextColor3 = Theme.Text, PlaceholderColor3 = Theme.SubText, Size = UDim2.fromOffset(180, 22), Position = UDim2.fromOffset(0, 160), ZIndex = leftCol.ZIndex + 1, Parent = leftCol}, {Create("UICorner", {CornerRadius = UDim.new(0,3)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.55}), Create("UIPadding", {PaddingLeft = UDim.new(0,6), PaddingRight = UDim.new(0,6)})})
                            hexBox = Create("TextBox", {BackgroundColor3 = Theme.Button, ClearTextOnFocus = false, Text = "", PlaceholderText = "#FFFFFF", Font = Fonts.Regular, TextSize = 12, TextColor3 = Theme.Text, PlaceholderColor3 = Theme.SubText, Size = UDim2.fromOffset(180, 22), Position = UDim2.fromOffset(0, 186), ZIndex = leftCol.ZIndex + 1, Parent = leftCol}, {Create("UICorner", {CornerRadius = UDim.new(0,3)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.55}), Create("UIPadding", {PaddingLeft = UDim.new(0,6), PaddingRight = UDim.new(0,6)})})

                            -- Right: Hue slider + rainbow toggle
                            local HUE_W, HUE_H = 26, 150
                            local rightCol = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(52, 210), ZIndex = content.ZIndex + 1, Parent = content})
                            -- Make the hue slider background opaque white so the UIGradient is visible and vibrant
                            -- Position slider slightly more left to align above the checkbox box itself
                            hueSlider = Create("Frame", {Active = true, BackgroundTransparency = 0, BackgroundColor3 = Color3.fromRGB(255,255,255), BorderSizePixel = 0, Size = UDim2.fromOffset(HUE_W, HUE_H), Position = UDim2.fromOffset(-7, 0), ZIndex = rightCol.ZIndex + 1, Parent = rightCol}, {Create("UICorner", {CornerRadius = UDim.new(0,4)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})})
                            local hueGrad = Instance.new("UIGradient")
                            hueGrad.Color = ColorSequence.new({
                                ColorSequenceKeypoint.new(0.00, Color3.fromHSV(0/6,1,1)),
                                ColorSequenceKeypoint.new(0.17, Color3.fromHSV(1/6,1,1)),
                                ColorSequenceKeypoint.new(0.33, Color3.fromHSV(2/6,1,1)),
                                ColorSequenceKeypoint.new(0.50, Color3.fromHSV(3/6,1,1)),
                                ColorSequenceKeypoint.new(0.67, Color3.fromHSV(4/6,1,1)),
                                ColorSequenceKeypoint.new(0.83, Color3.fromHSV(5/6,1,1)),
                                ColorSequenceKeypoint.new(1.00, Color3.fromHSV(1,1,1)),
                            })
                            hueGrad.Rotation = 90; hueGrad.Parent = hueSlider
                            hueGrab = Create("Frame", {Active = true, BackgroundColor3 = Theme.Bg, Size = UDim2.fromOffset(HUE_W, 4), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.fromOffset(math.floor(HUE_W/2), 0), ZIndex = hueSlider.ZIndex + 1, Parent = hueSlider}, {Create("UIStroke", {Color = Theme.Accent, Thickness = 1, Transparency = 0})})

                            -- RGB checkbox + label centered between RGB textbox end and frame boundary
                            local cbRow = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = "", Size = UDim2.fromOffset(40, 22), Position = UDim2.fromOffset(197, 160), ZIndex = leftCol.ZIndex + 1, Parent = leftCol})
                            local cbBox = Create("Frame", {BackgroundColor3 = Theme.Button, Size = UDim2.fromOffset(12,12), Position = UDim2.fromOffset(0,5), ZIndex = cbRow.ZIndex + 1, Parent = cbRow}, {Create("UICorner", {CornerRadius = UDim.new(0,2)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})})
                            local cbMark = Create("Frame", {BackgroundColor3 = Theme.Text, Size = UDim2.fromOffset(8,8), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.fromOffset(6,6), Visible = false, ZIndex = cbBox.ZIndex + 1, Parent = cbBox}, {Create("UICorner", {CornerRadius = UDim.new(0,2)})})
                            Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.fromOffset(24,22), Position = UDim2.fromOffset(16,0), Text = "RGB", Font = Fonts.Regular, TextSize = 10, TextColor3 = Theme.SubText, TextXAlignment = Enum.TextXAlignment.Left, ZIndex = cbRow.ZIndex + 1, Parent = cbRow})
                            
                            -- Pulse RGB checkbox + label positioned at hex textbox Y level, same X as RGB checkbox
                            local pulseRow = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = "", Size = UDim2.fromOffset(50, 22), Position = UDim2.fromOffset(197, 186), ZIndex = leftCol.ZIndex + 1, Parent = leftCol})
                            local pulseBox = Create("Frame", {BackgroundColor3 = Theme.Button, Size = UDim2.fromOffset(12,12), Position = UDim2.fromOffset(0,5), ZIndex = pulseRow.ZIndex + 1, Parent = pulseRow}, {Create("UICorner", {CornerRadius = UDim.new(0,2)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})})
                            local pulseMark = Create("Frame", {BackgroundColor3 = Theme.Text, Size = UDim2.fromOffset(8,8), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.fromOffset(6,6), Visible = false, ZIndex = pulseBox.ZIndex + 1, Parent = pulseBox}, {Create("UICorner", {CornerRadius = UDim.new(0,2)})})
                            Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.fromOffset(34,22), Position = UDim2.fromOffset(16,0), Text = "Pulse", Font = Fonts.Regular, TextSize = 10, TextColor3 = Theme.SubText, TextXAlignment = Enum.TextXAlignment.Left, ZIndex = pulseRow.ZIndex + 1, Parent = pulseRow})
                            local function setCheckbox(on)
                                cbMark.Visible = on and true or false
                            end
                            local function setPulseCheckbox(on)
                                pulseMark.Visible = on and true or false
                            end
                            setCheckbox(false)
                            setPulseCheckbox(false)

                            -- interactions: SV drag (S across X, V across Y)
                            local function getScreenPos()
                                local inset = game:GetService("GuiService"):GetGuiInset()
                                local m = UserInputService:GetMouseLocation()
                                return Vector2.new(m.X - inset.X, m.Y - inset.Y)
                            end
                            local svDragging = false
                            local svDragIndex = nil
                            local function handleSVDown(inp)
                                if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
                                    svDragging = true
                                    svDragIndex = activeIndex
                                    -- pause rainbow for this slot while dragging, if active
                                    local slot = slots[svDragIndex]
                                    if slot and slot.rainbow and slot.rainbowHook then
                                        rainbowRemove(slot.rainbowHook)
                                        slot._resumeRainbow = true
                                        slot.rainbowHook = nil
                                    end
                                    local p = getScreenPos()
                                    local rel = Vector2.new(p.X - sv.AbsolutePosition.X, p.Y - sv.AbsolutePosition.Y)
                                    local s = clamp01(rel.X / math.max(1, sv.AbsoluteSize.X))
                                    local v = 1 - clamp01(rel.Y / math.max(1, sv.AbsoluteSize.Y))
                                    svCursor.Position = UDim2.fromOffset(math.clamp(rel.X,0,sv.AbsoluteSize.X), math.clamp(rel.Y,0,sv.AbsoluteSize.Y))
                                    setHSV(svDragIndex, nil, s, v)
                                end
                            end
                            table.insert(conns, sv.InputBegan:Connect(handleSVDown))
                            table.insert(conns, svWhite.InputBegan:Connect(handleSVDown))
                            table.insert(conns, svBlack.InputBegan:Connect(handleSVDown))
                            table.insert(conns, UserInputService.InputChanged:Connect(function(inp)
                                if svDragging and (inp.UserInputType == Enum.UserInputType.MouseMovement or inp.UserInputType == Enum.UserInputType.Touch) then
                                    local p = getScreenPos()
                                    local rel = Vector2.new(p.X - sv.AbsolutePosition.X, p.Y - sv.AbsolutePosition.Y)
                                    local s = clamp01(rel.X / math.max(1, sv.AbsoluteSize.X))
                                    local v = 1 - clamp01(rel.Y / math.max(1, sv.AbsoluteSize.Y))
                                    svCursor.Position = UDim2.fromOffset(math.clamp(rel.X,0,sv.AbsoluteSize.X), math.clamp(rel.Y,0,sv.AbsoluteSize.Y))
                                    setHSV(svDragIndex or activeIndex, nil, s, v)
                                end
                            end))
                            table.insert(conns, UserInputService.InputEnded:Connect(function(inp)
                                if svDragging and (inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch) then
                                    svDragging = false
                                    local dragIndex = svDragIndex or activeIndex
                                    -- resume rainbow if it was paused
                                    local slot = slots[dragIndex]
                                    if slot and slot._resumeRainbow and slot.rainbow and not slot.rainbowHook then
                                        slot.rainbowHook = attachRainbow(dragIndex)
                                        slot._resumeRainbow = nil
                                    end
                                    svDragIndex = nil
                                end
                            end))

                            -- hue drag
                            local hueDragging = false
                            local hueDragIndex = nil
                            local function handleHueDown(inp)
                                if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
                                    hueDragging = true
                                    hueDragIndex = activeIndex
                                    -- pause rainbow for this slot while dragging, if active
                                    local slot = slots[hueDragIndex]
                                    if slot and slot.rainbow and slot.rainbowHook then
                                        rainbowRemove(slot.rainbowHook)
                                        slot._resumeRainbow = true
                                        slot.rainbowHook = nil
                                    end
                                    local p = getScreenPos()
                                    local relY = math.clamp(p.Y - hueSlider.AbsolutePosition.Y, 0, hueSlider.AbsoluteSize.Y)
                                    hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), relY)
                                    local h = clamp01(relY / math.max(1, hueSlider.AbsoluteSize.Y))
                                    setHSV(hueDragIndex, h, nil, nil); updateSVBackground(h)
                                end
                            end
                            table.insert(conns, hueSlider.InputBegan:Connect(handleHueDown))
                            table.insert(conns, hueGrab.InputBegan:Connect(handleHueDown))
                            table.insert(conns, UserInputService.InputChanged:Connect(function(inp)
                                if hueDragging and (inp.UserInputType == Enum.UserInputType.MouseMovement or inp.UserInputType == Enum.UserInputType.Touch) then
                                    local p = getScreenPos()
                                    local relY = math.clamp(p.Y - hueSlider.AbsolutePosition.Y, 0, hueSlider.AbsoluteSize.Y)
                                    hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), relY)
                                    local h = clamp01(relY / math.max(1, hueSlider.AbsoluteSize.Y))
                                    setHSV(hueDragIndex or activeIndex, h, nil, nil); updateSVBackground(h)
                                end
                            end))
                            table.insert(conns, UserInputService.InputEnded:Connect(function(inp)
                                if hueDragging and (inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch) then
                                    hueDragging = false
                                    local dragIndex = hueDragIndex or activeIndex
                                    -- resume rainbow if it was paused
                                    local slot = slots[dragIndex]
                                    if slot and slot._resumeRainbow and slot.rainbow and not slot.rainbowHook then
                                        slot.rainbowHook = attachRainbow(dragIndex)
                                        slot._resumeRainbow = nil
                                    end
                                    hueDragIndex = nil
                                end
                            end))

                            -- inputs
                            rgbBox.FocusLost:Connect(function()
                                local r,g,b = parseRGBText(rgbBox.Text or "")
                                if r then
                                    r,g,b = math.clamp(r,0,255), math.clamp(g,0,255), math.clamp(b,0,255)
                                    local c = Color3.fromRGB(r,g,b)
                                    local h,s,v = Color3.toHSV(c)
                                    slots[activeIndex].hsv = {h,s,v}
                                    updateSVBackground(h)
                                    -- update cursors
                                    svCursor.Position = UDim2.fromOffset(s*sv.AbsoluteSize.X, (1-v)*sv.AbsoluteSize.Y)
                                    hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), h*hueSlider.AbsoluteSize.Y)
                                    applyColorFromHSV(activeIndex)
                                else
                                    local c = slots[activeIndex].color
                                    local rr,gg,bb = toRGB255(c)
                                    rgbBox.Text = string.format("%d, %d, %d", rr,gg,bb)
                                end
                            end)
                            hexBox.FocusLost:Connect(function()
                                local r,g,b = hexToRGB(hexBox.Text or "")
                                if r then
                                    local c = Color3.fromRGB(r,g,b)
                                    local h,s,v = Color3.toHSV(c)
                                    slots[activeIndex].hsv = {h,s,v}
                                    updateSVBackground(h)
                                    svCursor.Position = UDim2.fromOffset(s*sv.AbsoluteSize.X, (1-v)*sv.AbsoluteSize.Y)
                                    hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), h*hueSlider.AbsoluteSize.Y)
                                    applyColorFromHSV(activeIndex)
                                else
                                    local c = slots[activeIndex].color
                                    hexBox.Text = (function() local r,g,b = toRGB255(c); return rgbToHex(r,g,b) end)()
                                end
                            end)

                            -- rainbow checkbox logic
                            cbRow.MouseButton1Click:Connect(function()
                                local idx = activeIndex
                                local slot = slots[idx]
                                slot.rainbow = not slot.rainbow
                                setCheckbox(slot.rainbow)
                                if slot.rainbow then
                                    if slot.rainbowHook then rainbowRemove(slot.rainbowHook); slot.rainbowHook = nil end
                                    slot.rainbowHook = attachRainbow(idx)
                                    -- Disable pulse if rainbow is enabled
                                    if slot.pulseHook then rainbowRemove(slot.pulseHook); slot.pulseHook = nil end
                                    slot.pulse = false
                                    setPulseCheckbox(false)
                                else
                                    if slot.rainbowHook then rainbowRemove(slot.rainbowHook); slot.rainbowHook = nil end
                                    slot._resumeRainbow = nil
                                end
                            end)
                            
                            -- pulse RGB checkbox logic
                            pulseRow.MouseButton1Click:Connect(function()
                                local idx = activeIndex
                                local slot = slots[idx]
                                slot.pulse = not slot.pulse
                                setPulseCheckbox(slot.pulse)
                                if slot.pulse then
                                    if slot.pulseHook then rainbowRemove(slot.pulseHook); slot.pulseHook = nil end
                                    slot.pulseHook = rainbowAdd(function(t)
                                        local phase = (math.sin(t * 6) + 1) / 2 -- Pulse between 0 and 1
                                        local h = (t * 0.5) % 1 -- Cycle through hue
                                        local s, v = slot.hsv[2], slot.hsv[3]
                                        -- Mix between base color and rainbow hue based on pulse
                                        local baseH = slot.hsv[1]
                                        local finalH = baseH + (h - baseH) * phase
                                        local pulsedColor = Color3.fromHSV(finalH, s, v)
                                        slot.color = pulsedColor
                                        slot.fill.BackgroundColor3 = pulsedColor
                                        if type(cb) == "function" then pcall(cb, pulsedColor, idx) end
                                    end)
                                    -- Disable rainbow if pulse is enabled
                                    if slot.rainbowHook then rainbowRemove(slot.rainbowHook); slot.rainbowHook = nil end
                                    slot.rainbow = false
                                    setCheckbox(false)
                                else
                                    if slot.pulseHook then rainbowRemove(slot.pulseHook); slot.pulseHook = nil end
                                end
                            end)
                        end

                        -- position panel near btnFor (above/right)
                        panel.Visible = true; panel.ClipsDescendants = true
                        -- Create a blocker to intercept outside clicks and block underlying UI
                        if panelBlocker and panelBlocker.Parent then pcall(function() panelBlocker:Destroy() end) end
                        panelBlocker = Create("TextButton", {AutoButtonColor = false, Modal = false, BackgroundTransparency = 1, Text = "", Size = UDim2.fromScale(1,1), Position = UDim2.fromOffset(0,0), ZIndex = (panel.ZIndex or 1) - 1, Parent = RootGui})
                        -- Close any other open color panel globally
                        local function closePanel()
                            if not panel or not panel.Visible then return end
                            panel.Visible = false; open=false; anim=false; disconnectAll()
                            if panelBlocker and panelBlocker.Parent then pcall(function() panelBlocker:Destroy() end) end
                            panelBlocker = nil
                            if Library._openColorPanelClose == closePanel then Library._openColorPanelClose = nil end
                        end
                        if Library._openColorPanelClose and Library._openColorPanelClose ~= closePanel then pcall(Library._openColorPanelClose) end
                        if Library._openColorCtxClose then pcall(Library._openColorCtxClose); Library._openColorCtxClose = nil end
                        Library._openColorPanelClose = closePanel

                        local tAbs, tSz = btnFor.AbsolutePosition, btnFor.AbsoluteSize
                        local rootAbs, rootSz = root.AbsolutePosition, root.AbsoluteSize
                        local width, height = 260, 220
                        -- compute desired position in root-space, then convert to screen-space for RootGui
                        -- Open above-right: align panel's right edge to swatch right, with 6px gap
                        local pxRoot = (tAbs.X - rootAbs.X) + tSz.X - width
                        local pyRoot = (tAbs.Y - rootAbs.Y) - height
                        pxRoot = math.clamp(pxRoot, 4, rootSz.X - width - 4)
                        local px = rootAbs.X + pxRoot
                        local py = rootAbs.Y + pyRoot
                        panel.Position = UDim2.fromOffset(px, py)
                        panel.Size = UDim2.fromOffset(width, 0)

                        -- set UI to current slot
                        local h,s,v = table.unpack(slots[index].hsv)
                        updateSVBackground(h)
                        if svCursor and sv then svCursor.Position = UDim2.fromOffset(s*(sv.AbsoluteSize.X), (1-v)*(sv.AbsoluteSize.Y)) end
                        if hueGrab and hueSlider then hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), h*(hueSlider.AbsoluteSize.Y)) end
                        if rgbBox then local r,g,b = toRGB255(slots[index].color); rgbBox.Text = string.format("%d, %d, %d", r,g,b) end
                        if hexBox then local r,g,b = toRGB255(slots[index].color); hexBox.Text = rgbToHex(r,g,b) end
                        if setCheckbox then -- reflect slot state
                            local slot = slots[index]
                            if slot.rainbow and not slot.rainbowHook then
                                slot.rainbowHook = attachRainbow(index)
                            end
                        end

                        -- Swallow background clicks on the panel itself so blocker doesn't see them
                        table.insert(conns, panel.InputBegan:Connect(function() end))
                        local tw = T(panel,0.18,{Size = UDim2.fromOffset(width, height)})
                        tw:Play(); tw.Completed:Connect(function() anim=false end)
                        anim=false
                        local justOpened = true; task.defer(function() justOpened = false end)
                        -- outside close / esc
                        -- close when clicking on blocker
                        if panelBlocker then
                            table.insert(conns, panelBlocker.MouseButton1Click:Connect(function() closePanel() end))
                            table.insert(conns, panelBlocker.MouseButton2Click:Connect(function() closePanel() end))
                            table.insert(conns, panelBlocker.TouchTap:Connect(function() closePanel() end))
                        end
                    end

                    -- open/ctx events per slot
                    for i,slot in ipairs(slots) do
                        slot.btn.MouseButton1Click:Connect(function() openPanel(slot.btn, i) end)
                        slot.btn.MouseButton2Click:Connect(function()
                            activeIndex = i
                            if Library._openColorCtxClose and Library._openColorCtxClose ~= closeCtx then pcall(Library._openColorCtxClose) end
                            openCtx(slot.btn)
                            Library._openColorCtxClose = function() closeCtx(); if Library._openColorCtxClose then Library._openColorCtxClose = nil end end
                        end)
                        slot.btn.InputBegan:Connect(function(inp)
                            if inp.UserInputType == Enum.UserInputType.MouseButton2 then
                                activeIndex = i
                                if Library._openColorCtxClose and Library._openColorCtxClose ~= closeCtx then pcall(Library._openColorCtxClose) end
                                openCtx(slot.btn)
                                Library._openColorCtxClose = function() closeCtx(); if Library._openColorCtxClose then Library._openColorCtxClose = nil end end
                            end
                        end)
                    end

                    -- public API
                    local Colorpicker = { id = id, _slots = slots }
                    function Colorpicker:Get(index)
                        if index then return self._slots[index] and self._slots[index].color end
                        if #self._slots == 1 then return self._slots[1].color end
                        local arr = {}
                        for i,s in ipairs(self._slots) do arr[i] = s.color end
                        return arr
                    end
                    function Colorpicker:Set(value, index, silent)
                        local function setOne(i, c)
                            local h,s,v = Color3.toHSV(c)
                            self._slots[i].hsv = {h,s,v}
                            self._slots[i].color = c
                            self._slots[i].fill.BackgroundColor3 = c
                            if not silent and type(cb)=="function" then pcall(cb, c, i) end
                        end
                        if index then
                            local c = colorFromAny(value)
                            setOne(index, c)
                        else
                            if type(value) == "table" and #value > 0 then
                                for i=1, math.min(#value, #self._slots) do setOne(i, colorFromAny(value[i])) end
                            else
                                local c = colorFromAny(value)
                                for i=1, #self._slots do setOne(i, c) end
                            end
                        end
                    end
                    function Colorpicker:SetRainbow(on, index)
                        local function setOne(i, onv)
                            local slot = self._slots[i]
                            slot.rainbow = (onv == true)
                            if slot.rainbow then
                                -- Disable pulse if rainbow is enabled
                                if slot.pulseHook then rainbowRemove(slot.pulseHook); slot.pulseHook = nil end
                                slot.pulse = false
                                if slot.rainbowHook then rainbowRemove(slot.rainbowHook); slot.rainbowHook = nil end
                                -- reuse attachRainbow if available in scope; otherwise, fallback to basic hook
                                if type(attachRainbow) == "function" then
                                    slot.rainbowHook = attachRainbow(i)
                                else
                                    slot.rainbowHook = rainbowAdd(function(h)
                                        local s,v = slot.hsv[2], slot.hsv[3]
                                        slot.hsv = {h,s,v}
                                        local c = hsvToColor(slot.hsv)
                                        slot.color = c
                                        slot.fill.BackgroundColor3 = c
                                        if type(cb) == "function" then pcall(cb, c, i) end
                                    end)
                                end
                            else
                                if slot.rainbowHook then rainbowRemove(slot.rainbowHook); slot.rainbowHook = nil end
                                slot._resumeRainbow = nil
                            end
                        end
                        if index then setOne(index, on) else for i=1,#self._slots do setOne(i, on) end end
                    end
                    function Colorpicker:SetPulse(on, index)
                        local function setOne(i, onv)
                            local slot = self._slots[i]
                            slot.pulse = (onv == true)
                            if slot.pulse then
                                -- Disable rainbow if pulse is enabled
                                if slot.rainbowHook then rainbowRemove(slot.rainbowHook); slot.rainbowHook = nil end
                                slot.rainbow = false
                                slot._resumeRainbow = nil
                                if slot.pulseHook then rainbowRemove(slot.pulseHook); slot.pulseHook = nil end
                                slot.pulseHook = rainbowAdd(function(t)
                                    local phase = (math.sin(t * 6) + 1) / 2 -- Pulse between 0 and 1
                                    local h = (t * 0.5) % 1 -- Cycle through hue
                                    local s, v = slot.hsv[2], slot.hsv[3]
                                    -- Mix between base color and rainbow hue based on pulse
                                    local baseH = slot.hsv[1]
                                    local finalH = baseH + (h - baseH) * phase
                                    local pulsedColor = Color3.fromHSV(finalH, s, v)
                                    slot.color = pulsedColor
                                    slot.fill.BackgroundColor3 = pulsedColor
                                    if type(cb) == "function" then pcall(cb, pulsedColor, i) end
                                end)
                            else
                                if slot.pulseHook then rainbowRemove(slot.pulseHook); slot.pulseHook = nil end
                            end
                        end
                        if index then setOne(index, on) else for i=1,#self._slots do setOne(i, on) end end
                    end

                    -- apply defaults & optional rainbow
                    for i=1,#slots do
                        local h,s,v = Color3.toHSV(slots[i].color)
                        slots[i].hsv = {h,s,v}
                        -- Rainbow default is always off
                    end

                    Library:_registerControl(Colorpicker)
                    table.insert(Group._controls, Colorpicker)
                    registerSearch(label)
                    return Colorpicker
                end
                return Group
            end
            table.insert(Category._pages, Page)
            if not Category._selectedPage then Page:Select() end
            return Page
        end
        Category._btn = btn
        Category._label = lbl
        Category._indicator = catInd
        Category._icon = iconImg
        Category._container = catContainer
        table.insert(Window._categories, Category)
        if not Window._selectedCategory then Category:Select() end
        return Category
    end
    -- enhanced mobile toggle (glow + status + hold-to-drag)
    if showMobileBtn then
        local presetColor = Theme.Accent
        local container = Create("Frame", {Name = "MobileToggleContainer", BackgroundTransparency = 1, Position = UDim2.new(1, -80, 0, 120), Size = UDim2.new(0, 70, 0, 70), ZIndex = 1, Parent = RootGui})
        local toggleFrame = Create("Frame", {Name = "MobileToggle", BackgroundColor3 = Color3.fromRGB(27,27,27), BorderSizePixel = 0, Position = UDim2.new(0,10,0,10), Size = UDim2.new(0,50,0,50), ClipsDescendants = false, ZIndex = 2, Parent = container})
        Create("UICorner", {CornerRadius = UDim.new(0,12), Parent = toggleFrame})
        local stroke = Create("UIStroke", {ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = presetColor, Thickness = 2, Transparency = 0.3, Parent = toggleFrame})
        local glow = Create("ImageLabel", {Name = "Glow", BackgroundTransparency = 1, Position = UDim2.new(0.5,-30,0.5,-30), Size = UDim2.new(0,60,0,60), Image = "rbxassetid://4996891970", ImageColor3 = presetColor, ImageTransparency = 0.7, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(20,20,280,280), ZIndex = 1, Parent = toggleFrame})
        local button = Create("TextButton", {Name = "ToggleButton", BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Font = Fonts.Medium, Text = "", TextTransparency = 1, AutoButtonColor = false, ZIndex = 3, Parent = toggleFrame})
        local iconContainer = Create("Frame", {Name = "IconContainer", BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), ZIndex = 3, Parent = button})
        local icon = Create("ImageLabel", {Name = "ToggleIcon", BackgroundTransparency = 1, AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.new(0.5,0,0.5,0), Size = UDim2.new(0,24,0,24), Image = "rbxassetid://109809645126775", ImageColor3 = Color3.fromRGB(255,255,255), ZIndex = 3, Parent = iconContainer})
        local status = Create("Frame", {Name = "StatusIndicator", BackgroundColor3 = Color3.fromRGB(255,85,85), BorderSizePixel = 0, Position = UDim2.new(1,-12,0,4), Size = UDim2.new(0,8,0,8), ZIndex = 4, Parent = toggleFrame})
        Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = status})
        local open = true
        local holding, dragging = false, false
        local holdStart, dragStart
        local function updateState()
            if open then
                status.BackgroundColor3 = Color3.fromRGB(85,255,127)
                T(toggleFrame,0.3,{BackgroundColor3 = Color3.fromRGB(32,42,32)}):Play()
                T(stroke,0.3,{Transparency = 0.1}):Play()
            else
                status.BackgroundColor3 = Color3.fromRGB(255,85,85)
                T(toggleFrame,0.3,{BackgroundColor3 = Color3.fromRGB(27,27,27)}):Play()
                T(stroke,0.3,{Transparency = 0.3}):Play()
            end
        end
        updateState()
        task.spawn(function()
            while toggleFrame.Parent do
                stroke.Color = presetColor
                glow.ImageColor3 = presetColor
                task.wait()
            end
        end)
        -- Improved drag: start when movement passes threshold; quick tap toggles
        local pressPos
        local dragOffset
        local pressTime
        local DRAG_THRESHOLD = 6
        button.MouseButton1Down:Connect(function()
            holding = true; pressTime = tick(); dragging = false
            local mouse = UserInputService:GetMouseLocation()
            pressPos = Vector2.new(mouse.X, mouse.Y)
            local abs = container.AbsolutePosition
            dragOffset = Vector2.new(mouse.X - abs.X, mouse.Y - abs.Y)
            T(toggleFrame,0.1,{Size = UDim2.new(0,46,0,46), Position = UDim2.new(0,12,0,12)}):Play()
            T(icon,0.1,{Size = UDim2.new(0,20,0,20)}):Play()
        end)
        button.MouseButton1Up:Connect(function()
            local wasTap = holding and (tick() - pressTime) < 0.4 and not dragging
            holding = false
            T(toggleFrame,0.2,{Size = UDim2.new(0,50,0,50), Position = UDim2.new(0,10,0,10)}):Play()
            T(icon,0.2,{Size = UDim2.new(0,24,0,24)}):Play()
            if wasTap then
                open = not open
                root.Visible = open
                updateState()
            end
            dragging = false
            pressPos = nil; dragOffset = nil
        end)
        UserInputService.InputChanged:Connect(function(inp)
            if holding and pressPos and (inp.UserInputType == Enum.UserInputType.MouseMovement or inp.UserInputType == Enum.UserInputType.Touch) then
                local mouse = UserInputService:GetMouseLocation()
                if not dragging then
                    local dx = mouse.X - pressPos.X
                    local dy = mouse.Y - pressPos.Y
                    if (dx*dx + dy*dy) > (DRAG_THRESHOLD*DRAG_THRESHOLD) then
                        dragging = true
                    end
                end
                if dragging and dragOffset then
                    local viewport = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920,1080)
                    local newX = mouse.X - dragOffset.X
                    local newY = mouse.Y - dragOffset.Y
                    newX = math.max(0, math.min(viewport.X - container.AbsoluteSize.X, newX))
                    newY = math.max(0, math.min(viewport.Y - container.AbsoluteSize.Y, newY))
                    container.Position = UDim2.new(0, newX, 0, newY)
                end
            end
        end)
        UserInputService.InputEnded:Connect(function(inp)
            if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
                if holding then
                    -- emulate release logic if MouseButton1Up missed (e.g., pointer left button area)
                    local wasTap = holding and not dragging and (tick() - (pressTime or tick())) < 0.4
                    holding = false
                    T(toggleFrame,0.2,{Size = UDim2.new(0,50,0,50), Position = UDim2.new(0,10,0,10)}):Play()
                    T(icon,0.2,{Size = UDim2.new(0,24,0,24)}):Play()
                    if wasTap then
                        open = not open
                        root.Visible = open
                        updateState()
                    end
                end
                dragging = false
                pressPos = nil
                dragOffset = nil
            end
        end)
        button.TouchTap:Connect(function()
            if not dragging and not holding then
                open = not open
                root.Visible = open
                updateState()
            end
        end)
        task.spawn(function()
            while toggleFrame.Parent do
                if not open then
                    T(glow,1.5,{ImageTransparency = 0.5}):Play(); task.wait(1.5)
                    T(glow,1.5,{ImageTransparency = 0.7}):Play(); task.wait(1.5)
                else
                    task.wait(0.5)
                end
            end
        end)
    end
    Window.AddTab = Window.AddCategory
    -- enhanced search with fuzzy matching and ranking
    function Window:Search(term, suppressHighlight)
        term = tostring(term or ""):lower():gsub("%s+", " "):gsub("^%s*(.-)%s*$", "%1") -- trim whitespace
        if term == "" then return end
        
        local matches = {}
        local exactMatches = {}
        local fuzzyMatches = {}
        
        for _, entry in ipairs(Library._searchEntries) do
            local text = entry.textLower
            local score = 0
            
            -- Exact matches (highest priority)
            if text == term then
                score = 1000
                exactMatches[#exactMatches + 1] = {entry = entry, score = score}
            -- Starts with term (high priority)  
            elseif text:find("^" .. term:gsub("[%-%^%$%(%)%%%.%[%]%*%+%?]", "%%%1")) then
                score = 800 + (100 - #text) -- shorter matches rank higher
                exactMatches[#exactMatches + 1] = {entry = entry, score = score}
            -- Contains term (medium priority)
            elseif text:find(term, 1, true) then
                score = 600 + (100 - #text)
                matches[#matches + 1] = {entry = entry, score = score}
            else
                -- Fuzzy matching - check if all characters of term exist in order
                local termChars = {}
                for i = 1, #term do termChars[i] = term:sub(i,i) end
                
                local textPos = 1
                local matchedChars = 0
                for _, char in ipairs(termChars) do
                    local found = text:find(char, textPos, true)
                    if found then
                        textPos = found + 1
                        matchedChars = matchedChars + 1
                    else
                        break
                    end
                end
                
                if matchedChars == #termChars and #termChars >= 3 then -- min 3 chars for fuzzy
                    score = 300 + matchedChars * 10
                    fuzzyMatches[#fuzzyMatches + 1] = {entry = entry, score = score}
                end
            end
        end
        
        -- Combine and sort all matches by score
        local allMatches = {}
        for _, match in ipairs(exactMatches) do allMatches[#allMatches + 1] = match end
        for _, match in ipairs(matches) do allMatches[#allMatches + 1] = match end  
        for _, match in ipairs(fuzzyMatches) do allMatches[#allMatches + 1] = match end
        
        table.sort(allMatches, function(a, b) return a.score > b.score end)
        
        local match = allMatches[1] and allMatches[1].entry
        if not match then return nil end
        -- select category & page
        if Window._selectedCategory ~= match.category then match.category:Select() end
        if match.category._selectedPage ~= match.page then match.page:Select() end
        -- defer scroll/highlight until UI is visible
        task.defer(function()
            if not match.groupFrame or not match.groupFrame.Parent then return end
            local col = match.groupFrame.Parent
            if col and col:IsA("ScrollingFrame") then
                local absPos = match.groupFrame.AbsolutePosition.Y
                local colAbs = col.AbsolutePosition.Y
                local offset = absPos - colAbs - 6
                if offset < 0 then offset = 0 end
                col.CanvasPosition = Vector2.new(0, offset)
            end
            if not suppressHighlight then
                -- single outline pulse on search call without suppression
                local stroke = nil
                for _, child in ipairs(match.groupFrame:GetChildren()) do if child:IsA("UIStroke") then stroke = child break end end
                if stroke then
                    local origColor, origThick = stroke.Color, stroke.Thickness
                    stroke.Color = Theme.Accent
                    T(stroke,0.15,{Thickness = 3}):Play()
                    task.delay(0.45, function()
                        if stroke and stroke.Parent then
                            T(stroke,0.30,{Thickness = origThick, Color = origColor}):Play()
                        end
                    end)
                end
            end
        end)
        return match
    end
    return Window
end
function Library:MakeWindow(o) return self:CreateLibrary(o) end
function Library:NewWindow(o) return self:CreateLibrary(o) end
function Library:SetTheme(t) for k, v in pairs(t or {}) do if Theme[k] ~= nil then Theme[k] = v end end end
function Library:SetFonts(f) for k, v in pairs(f or {}) do if Fonts[k] ~= nil then Fonts[k] = v end end end
function Library:GetFlag(name)
    return (self.Flags and self.Flags[name]) or self._controls[name]
end
function Library:SetFlag(name, value, silent)
    local c = (self.Flags and self.Flags[name]) or self._controls[name]
    if c and c.Set then c:Set(value, silent) end
end
return Library
