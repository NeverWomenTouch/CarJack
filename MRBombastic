if not game:IsLoaded() then game.Loaded:Wait() end
------------------- Adonis Bypass
loadstring("\108\111\99\97\108\32\103\101\116\103\99\32\61\32\103\101\116\103\99\10\108\111\99\97\108\32\114\97\119\103\101\116\32\61\32\114\97\119\103\101\116\10\108\111\99\97\108\32\116\121\112\101\32\61\32\116\121\112\101\111\102\10\108\111\99\97\108\32\104\111\111\107\102\117\110\99\116\105\111\110\32\61\32\104\111\111\107\102\117\110\99\116\105\111\110\10\108\111\99\97\108\32\112\99\97\108\108\32\61\32\112\99\97\108\108\10\108\111\99\97\108\32\119\97\114\110\32\61\32\119\97\114\110\10\108\111\99\97\108\32\98\32\61\32\102\97\108\115\101\10\108\111\99\97\108\32\99\32\61\32\123\125\10\108\111\99\97\108\32\100\10\102\117\110\99\116\105\111\110\32\115\97\102\101\72\111\111\107\40\102\117\110\99\44\32\104\97\110\100\108\101\114\41\10\32\32\32\32\108\111\99\97\108\32\115\117\99\99\101\115\115\44\32\114\101\115\117\108\116\32\61\32\112\99\97\108\108\40\104\111\111\107\102\117\110\99\116\105\111\110\44\32\102\117\110\99\44\32\104\97\110\100\108\101\114\41\10\32\32\32\32\105\102\32\110\111\116\32\115\117\99\99\101\115\115\32\116\104\101\110\10\32\32\32\32\32\32\32\32\119\97\114\110\40\34\70\97\105\108\101\100\32\116\111\32\104\111\111\107\32\102\117\110\99\116\105\111\110\58\32\34\32\46\46\32\116\111\115\116\114\105\110\103\40\114\101\115\117\108\116\41\41\10\32\32\32\32\101\110\100\10\32\32\32\32\114\101\116\117\114\110\32\114\101\115\117\108\116\32\32\32\32\10\101\110\100\10\102\111\114\32\102\44\32\103\32\105\110\32\103\101\116\103\99\40\116\114\117\101\41\32\100\111\10\32\32\32\32\105\102\32\116\121\112\101\40\103\41\32\61\61\32\34\116\97\98\108\101\34\32\116\104\101\110\10\32\32\32\32\32\32\32\32\108\111\99\97\108\32\104\32\61\32\114\97\119\103\101\116\40\103\44\32\34\68\101\116\101\99\116\101\100\34\41\10\32\32\32\32\32\32\32\32\10\32\32\32\32\32\32\32\32\105\102\32\116\121\112\101\40\104\41\32\61\61\32\34\102\117\110\99\116\105\111\110\34\32\97\110\100\32\110\111\116\32\100\32\116\104\101\110\10\32\32\32\32\32\32\32\32\32\32\32\32\100\32\61\32\104\10\32\32\32\32\32\32\32\32\32\32\32\32\108\111\99\97\108\32\106\32\61\32\115\97\102\101\72\111\111\107\40\100\44\32\102\117\110\99\116\105\111\110\40\107\44\32\108\44\32\109\41\10\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\105\102\32\107\32\126\61\32\34\95\34\32\116\104\101\110\10\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\105\102\32\98\32\116\104\101\110\10\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\101\110\100\10\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\101\110\100\10\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\114\101\116\117\114\110\32\116\114\117\101\10\32\32\32\32\32\32\32\32\32\32\32\32\101\110\100\41\10\32\32\32\32\32\32\32\32\32\32\32\32\105\102\32\106\32\116\104\101\110\10\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\116\97\98\108\101\46\105\110\115\101\114\116\40\99\44\32\100\41\10\32\32\32\32\32\32\32\32\32\32\32\32\101\110\100\10\32\32\32\32\32\32\32\32\101\110\100\10\32\32\32\32\101\110\100\10\101\110\100\10\108\111\99\97\108\32\112\10\112\32\61\32\115\97\102\101\72\111\111\107\40\103\101\116\114\101\110\118\40\41\46\100\101\98\117\103\46\105\110\102\111\44\32\102\117\110\99\116\105\111\110\40\46\46\46\41\10\32\32\32\32\108\111\99\97\108\32\113\32\61\32\46\46\46\10\32\32\32\32\105\102\32\100\32\97\110\100\32\113\32\61\61\32\100\32\116\104\101\110\10\32\32\32\32\32\32\32\32\105\102\32\98\32\116\104\101\110\10\32\32\32\32\32\32\32\32\101\110\100\10\32\32\32\32\32\32\32\32\114\101\116\117\114\110\32\99\111\114\111\117\116\105\110\101\46\121\105\101\108\100\40\99\111\114\111\117\116\105\110\101\46\114\117\110\110\105\110\103\40\41\41\10\32\32\32\32\101\110\100\10\32\32\32\32\114\101\116\117\114\110\32\112\40\46\46\46\41\10\101\110\100\41\10\10")()
---------------------- END OF ADONIS BYPASSER
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/NeverWomenTouch/brainaintbraining/refs/heads/main/.md"))()
local Window = Library:CreateLibrary({
    Name = "Dendrite.cc",
    LibraryName = "DendriteTest",
    TitleMode = "Type", -- or "Type" for typewriter effect
    ConfigFolder = "DendriteZeehood",
    Size = UDim2.fromOffset(600, 540),
    ShowMobileButton = false,
    AutoDeviceCheck = true
})
local MainTab = Window:AddCategory({
    Name = "Main"
})
local VisualsTab = Window:AddCategory({
    Name = "Visuals"
})
local MainSection = MainTab:AddSection({
    Name = "Main",
    Columns = 2 -- 1-3 columns supported
})
local VisualsSection = VisualsTab:AddSection({
    Name = "Visuals",
    Columns = 2 -- 1-3 columns supported
})
local ESPGroup = VisualsSection:AddPage({
    Name = "Visuals",
    Side = 1
})
local MainGroup = MainSection:AddPage({
    Name = "Main",
    Side = 1
})


------------------- VISUALS
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = game:GetService("Workspace").CurrentCamera
local ESPInstances = {}
local Config = {
    Esp = {
        Box = false,
        BoxOutline = false,
        BoxColor = Color3.fromRGB(255, 255, 255),
        BoxOutlineColor = Color3.fromRGB(0, 0, 0),
        HealthBar = false,
        HealthBarSide = "Left", 
        Names = false,
        Nametext = "None",
        NamesOutline = false,
        NamesColor = Color3.fromRGB(255, 255, 255),
        NamesOutlineColor = Color3.fromRGB(0, 0, 0),
        NamesFont = 2,
        NamesSize = 15,
        Weapon = false,
        Weapontext = "Weapon: None",
        WeaponOutline = false,
        WeaponColor = Color3.fromRGB(255, 255, 255),
        WeaponOutlineColor = Color3.fromRGB(0, 0, 0),
        WeaponFont = 2,
        WeaponSize = 15
    }
}

function CleanupESP(Player)
    if ESPInstances[Player] then
        for _, drawing in pairs(ESPInstances[Player].drawings) do
            if drawing and drawing.__OBJECT_EXISTS then
                drawing:Remove()
            end
        end
        if ESPInstances[Player].connection then
            ESPInstances[Player].connection:Disconnect()
        end
        ESPInstances[Player] = nil
    end
end

function CreateEsp(Player)
    if not Player then return end
    CleanupESP(Player)

    local Box, BoxOutline, Name, Weapon, HealthBar, HealthBarOutline = Drawing.new("Square"), Drawing.new("Square"), Drawing.new("Text"), Drawing.new("Text"), Drawing.new("Square"), Drawing.new("Square")
    
    ESPInstances[Player] = {
        drawings = {Box, BoxOutline, Name, Weapon, HealthBar, HealthBarOutline},
        connection = nil
    }

    local Updater = RunService.RenderStepped:Connect(function()
        local humanoid = Player:FindFirstChild("Humanoid")
        if Player and Player.Parent and Player:FindFirstChild("HumanoidRootPart") and humanoid then
            local Target2dPosition, IsVisible = Camera:WorldToViewportPoint(Player.HumanoidRootPart.Position)
            local scale_factor = 1 / (Target2dPosition.Z * math.tan(math.rad(Camera.FieldOfView * 0.5)) * 2) * 100
            local width, height = math.floor(40 * scale_factor), math.floor(60 * scale_factor)

            if humanoid.Health <= 0 then
                CleanupESP(Player)
                return
            end

            if Config.Esp.Box then
                Box.Visible = IsVisible
                Box.Color = Config.Esp.BoxColor
                Box.Size = Vector2.new(width, height)
                Box.Position = Vector2.new(Target2dPosition.X - Box.Size.X / 2, Target2dPosition.Y - Box.Size.Y / 2)
                Box.Filled = false
                Box.Thickness = 1
                Box.ZIndex = 69
                if Config.Esp.BoxOutline then
                    BoxOutline.Visible = IsVisible
                    BoxOutline.Color = Config.Esp.BoxOutlineColor
                    BoxOutline.Size = Box.Size
                    BoxOutline.Position = Box.Position
                    BoxOutline.Filled = false
                    BoxOutline.Thickness = 3
                    BoxOutline.ZIndex = 1
                else
                    BoxOutline.Visible = false
                end
            else
                Box.Visible = false
                BoxOutline.Visible = false
            end

            if Config.Esp.Names then
                Name.Visible = IsVisible
                Name.Color = Config.Esp.NamesColor
                Name.Text = Player.Name
                Name.Center = true
                Name.Outline = Config.Esp.NamesOutline
                Name.OutlineColor = Config.Esp.NamesOutlineColor
                Name.Position = Vector2.new(Target2dPosition.X, Target2dPosition.Y - height * 0.5 - 15)
                Name.Font = Config.Esp.NamesFont
                Name.Size = Config.Esp.NamesSize
            else
                Name.Visible = false
            end

            if Config.Esp.Weapon then
                Weapon.Visible = IsVisible
                Weapon.Color = Config.Esp.WeaponColor
                Weapon.Text = Config.Esp.Weapontext
                Weapon.Center = true
                Weapon.Outline = Config.Esp.WeaponOutline
                Weapon.OutlineColor = Config.Esp.WeaponOutlineColor
                Weapon.Position = Vector2.new(Target2dPosition.X, Target2dPosition.Y + height * 0.5 + 3)
                Weapon.Font = Config.Esp.WeaponFont
                Weapon.Size = Config.Esp.WeaponSize
                local tool = Player:FindFirstChildOfClass("Tool")
                Weapon.Text = tool and tool.Name or Config.Esp.Weapontext
            else
                Weapon.Visible = false
            end

            if Config.Esp.HealthBar then
                HealthBarOutline.Visible = IsVisible
                HealthBarOutline.Color = Color3.fromRGB(0, 0, 0)
                HealthBarOutline.Filled = true
                HealthBarOutline.ZIndex = 1
                HealthBar.Visible = IsVisible
                HealthBar.Color = Color3.fromRGB(255, 0, 0):lerp(Color3.fromRGB(0, 255, 0), humanoid.Health / humanoid.MaxHealth)
                HealthBar.Thickness = 1
                HealthBar.Filled = true
                HealthBar.ZIndex = 69
                if Config.Esp.HealthBarSide == "Left" then
                    HealthBarOutline.Size = Vector2.new(2, height)
                    HealthBarOutline.Position = Box.Position + Vector2.new(-3, 0)
                    HealthBar.Size = Vector2.new(1, -(HealthBarOutline.Size.Y - 2) * (humanoid.Health / humanoid.MaxHealth))
                    HealthBar.Position = HealthBarOutline.Position + Vector2.new(1, HealthBarOutline.Size.Y - 1)
                elseif Config.Esp.HealthBarSide == "Bottom" then
                    HealthBarOutline.Size = Vector2.new(width, 3)
                    HealthBarOutline.Position = Box.Position + Vector2.new(0, height + 2)
                    HealthBar.Size = Vector2.new((HealthBarOutline.Size.X - 2) * (humanoid.Health / humanoid.MaxHealth), 1)
                    HealthBar.Position = HealthBarOutline.Position + Vector2.new(1, 1)
                elseif Config.Esp.HealthBarSide == "Right" then
                    HealthBarOutline.Size = Vector2.new(2, height)
                    HealthBarOutline.Position = Box.Position + Vector2.new(width + 1, 0)
                    HealthBar.Size = Vector2.new(1, -(HealthBarOutline.Size.Y - 2) * (humanoid.Health / humanoid.MaxHealth))
                    HealthBar.Position = HealthBarOutline.Position + Vector2.new(1, HealthBarOutline.Size.Y - 1)
                end
            else
                HealthBar.Visible = false
                HealthBarOutline.Visible = false
            end
        else
            Box.Visible = false
            BoxOutline.Visible = false
            Name.Visible = false
            Weapon.Visible = false
            HealthBar.Visible = false
            HealthBarOutline.Visible = false
        end
    end)

    ESPInstances[Player].connection = Updater
end

for _, player in pairs(Players:GetPlayers()) do
    if player ~= Players.LocalPlayer then
        if player.Character then
            CreateEsp(player.Character)
        end
        player.CharacterAdded:Connect(CreateEsp)
        player.CharacterRemoving:Connect(CleanupESP)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= Players.LocalPlayer then
        if player.Character then
            CreateEsp(player.Character)
        end
        player.CharacterAdded:Connect(CreateEsp)
        player.CharacterRemoving:Connect(CleanupESP)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if player.Character then
        CleanupESP(player.Character)
    end
end)
-----visuals toggles and etc
local Namestosg = ESPGroup:AddToggle({
    Name = "Names",
    Default = false,
    Flag = "namesesp",
    Callback = function(v)
        Config.Esp.Names = v
    end
})
local Namesoutlinestosg = ESPGroup:AddToggle({
    Name = "Names Outlines",
    Default = false,
    Flag = "namesoutlinesesp",
    Callback = function(v)
        Config.Esp.NamesOutlines = v
    end
})
local NamesColorPicker = ESPGroup:AddColorpicker({
    Name = "Names Color",
    Amount = 1,
    Default = Color3.fromRGB(255, 255, 255),
    Flag = "NamesColor",
    Callback = function(v)
       Config.Esp.NamesColor = v
    end
})
local Namestosg = ESPGroup:AddToggle({
    Name = "Boxes",
    Default = false,
    Flag = "boxes",
    Callback = function(v)
        Config.Esp.Box = v
    end
})
local Namesoutlinestosg = ESPGroup:AddToggle({
    Name = "Boxes Outlines",
    Default = false,
    Flag = "boxesoutlines",
    Callback = function(v)
        Config.Esp.BoxOutline = v
    end
})
local BoxesColorPicker = ESPGroup:AddColorpicker({
    Name = "Boxes Color",
    Amount = 1,
    Default = Color3.fromRGB(255, 255, 255),
    Flag = "BoxesColor",
    Callback = function(v)
       Config.Esp.BoxColor = v
    end
})
local healthss = ESPGroup:AddToggle({
    Name = "Health Bars",
    Default = false,
    Flag = "healthbars",
    Callback = function(v)
        Config.Esp.HealthBar = v
    end
})
local weaponss = ESPGroup:AddToggle({
    Name = "Weapons",
    Default = false,
    Flag = "weaponsesp",
    Callback = function(v)
        Config.Esp.Weapon = v
    end
})
local weaponssoutlines = ESPGroup:AddToggle({
    Name = "Weapons Outlines",
    Default = false,
    Flag = "weaponsoutlinesesp",
    Callback = function(v)
        Config.Esp.WeaponOutline = v
    end
})
local weaponoclors = ESPGroup:AddColorpicker({
    Name = "Weapons Color",
    Amount = 1,
    Default = Color3.fromRGB(255, 255, 255),
    Flag = "WeaponsColor",
    Callback = function(v)
       Config.Esp.WeaponColor = v
    end
})



----------- MainTab
SAS = {
    Enabled = false,
    TeamCheck = false,
    VisibleCheck = false, 
    TargetPart = "Head",
    SilentAimMethod = "Raycast",
    FOVRadius = 130,
    FOVColor = Color3.fromRGB(255, 255, 255),
    FOVVisible = false,
    ShowSnapLine = false, 
    SnapColor = Color3.fromRGB(255, 255, 255),
    HitChance = 100,
    WallbangEnabled = false
}
local next = next
local pcall = pcall
local Vector2New = Vector2.new
local Color3FromRGB = Color3.fromRGB
local RayNew = Ray.new
local mathFloor = math.floor
local mathRandom = math.random
local tableUnpack = unpack or table.unpack 
getgenv().SAS = SAS
Camera = workspace.CurrentCamera
Players = game:GetService("Players")
RunService = game:GetService("RunService")
UserInputService = game:GetService("UserInputService")
LocalPlayer = Players.LocalPlayer
Mouse = LocalPlayer:GetMouse()
GetChildren = game.GetChildren
GetPlayers = Players.GetPlayers
WorldToScreen = Camera.WorldToScreenPoint
WorldToViewportPoint = Camera.WorldToViewportPoint
GetPartsObscuringTarget = Camera.GetPartsObscuringTarget
FindFirstChild = game.FindFirstChild
RenderStepped = RunService.RenderStepped
GetMouseLocation = UserInputService.GetMouseLocation
ValidTargetParts = {"Head", "HumanoidRootPart"}
local fov_circle = Drawing.new("Circle")
fov_circle.Thickness = 1
fov_circle.NumSides = 100
fov_circle.Radius = SAS.FOVRadius
fov_circle.Filled = false
fov_circle.Visible = SAS.FOVVisible
fov_circle.ZIndex = 999
fov_circle.Transparency = 1
fov_circle.Color = SAS.FOVColor
local snaps = Drawing.new("Line")
snaps.Visible = SAS.ShowSnapLine
snaps.ZIndex = 999 
snaps.Color = SAS.SnapColor
snaps.Thickness = 1
local EA = {
    Raycast = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Vector3", "Vector3", "RaycastParams"
        }
    }
}
function CalculateChance(Percentage)
    Percentage = math.floor(Percentage)
    local chance = math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100) / 100
    return chance <= Percentage / 100
end
function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToScreen(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end
function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then
        return false
    end
    for Pos, Argument in next, Args do
        if typeof(Argument) == RayMethod.Args[Pos] then
            Matches = Matches + 1
        end
    end
    return Matches >= RayMethod.ArgCountRequired
end
function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end
function getMousePosition()
    return GetMouseLocation(UserInputService)
end
function IsPlayerVisible(Player)
    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character
    if not (PlayerCharacter or LocalPlayerCharacter) then return end 
    local PlayerRoot = FindFirstChild(PlayerCharacter, SAS.TargetPart) or FindFirstChild(PlayerCharacter, "HumanoidRootPart")
    if not PlayerRoot then return end 
    local CastPoints, IgnoreList = {PlayerRoot.Position, LocalPlayerCharacter, PlayerCharacter}, {LocalPlayerCharacter, PlayerCharacter}
    local ObscuringObjects = #GetPartsObscuringTarget(Camera, CastPoints, IgnoreList)
    return ((ObscuringObjects == 0 and true) or (ObscuringObjects > 0 and false))
end
function getClosestPlayer()
    if not SAS.TargetPart then return nil end
    local Closest = nil
    local DistanceToMouse = nil
    local CurrentMousePos = getMousePosition()
    local FOVRadius = tonumber(SAS.FOVRadius) or 2000
    local TeamCheck = SAS.TeamCheck
    local VisibleCheck = SAS.VisibleCheck
    local TargetPart = SAS.TargetPart
    for _, Player in next, GetPlayers(Players) do
        if Player == LocalPlayer then continue end
        if TeamCheck and Player.Team == LocalPlayer.Team then continue end
        if not Player.Character then continue end
        local Character = Player.Character
        if not Character then continue end
        if VisibleCheck and not IsPlayerVisible(Player) then continue end
        local HumanoidRootPart = FindFirstChild(Character, "HumanoidRootPart")
        local Humanoid = FindFirstChild(Character, "Humanoid")
        if not HumanoidRootPart or not Humanoid or Humanoid and Humanoid.Health <= 0 then 
            continue 
        end
        local ScreenPosition, OnScreen = getPositionOnScreen(HumanoidRootPart.Position)
        if not OnScreen then continue end
        local Distance = (CurrentMousePos - ScreenPosition).Magnitude
        if Distance <= (tonumber(DistanceToMouse) or FOVRadius) then
            if TargetPart == "Random" then
                local randomIndex = mathRandom(1, #ValidTargetParts)
                local partName = ValidTargetParts[randomIndex]
                Closest = Character[partName]
            else
                Closest = Character[TargetPart]
                if not Closest then
                    Closest = HumanoidRootPart
                end
            end
            DistanceToMouse = Distance
        end
    end
    return Closest
end
local lastUpdate = tick()
local updateInterval = 0.01
local cachedMousePos = getMousePosition()
RunService.RenderStepped:Connect(function(deltaTime)
    local currentTime = tick()
    if currentTime - lastUpdate < updateInterval then return end
    lastUpdate = currentTime
    cachedMousePos = getMousePosition()
    fov_circle.Position = cachedMousePos
    fov_circle.Radius = SAS.FOVRadius
    fov_circle.Color = SAS.FOVColor
    snaps.Color = SAS.SnapColor
    fov_circle.Visible = SAS.FOVVisible
    if SAS.ShowSnapLine and SAS.Enabled then
        local Target = getClosestPlayer()
        if Target then 
            local Root = Target.Parent.PrimaryPart or Target
            local _, IsOnScreen = nil, false
            pcall(function()
                local RootToViewportPoint
                RootToViewportPoint, IsOnScreen = WorldToViewportPoint(Camera, Root.Position)
                if IsOnScreen then
                    snaps.From = Vector2.new(cachedMousePos.X, cachedMousePos.Y)
                    snaps.To = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                end
                snaps.Visible = IsOnScreen
            end)
        else
            snaps.Visible = false
        end
    else
        snaps.Visible = false
    end
end)
local lastWallbangTime = 0
local wallbangCooldown = 0.005
function GetWallbangableTable(Target)
    if not Target or not Target.Parent then return {} end
    local Character = Target.Parent
    local HumanoidRootPart = FindFirstChild(Character, "HumanoidRootPart")
    if not HumanoidRootPart then return {} end
    return {Character}
end
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]
    local chance = CalculateChance(SAS.HitChance)
    if SAS.Enabled and self == workspace and not checkcaller() and chance == true then
        if Method == "Raycast" and SAS.SilentAimMethod == Method then
            if ValidateArguments(Arguments, EA.Raycast) then
                local A_Origin = Arguments[2]
                local HitPart = getClosestPlayer()
                if HitPart then
                    Arguments[3] = getDirection(A_Origin, HitPart.Position)
                    if SAS.WallbangEnabled and tick() - lastWallbangTime > wallbangCooldown then
                        lastWallbangTime = tick()
                        local params = RaycastParams.new()
                        params.FilterType = Enum.RaycastFilterType.Include
                        params.IgnoreWater = true
                        params.RespectCanCollide = false
                        params.FilterDescendantsInstances = GetWallbangableTable(HitPart)
                        Arguments[4] = params
                    end
                    return oldNamecall(unpack(Arguments))
                end
            end
        end
    end
    return oldNamecall(unpack(Arguments))
end))

local mainsil = MainGroup:AddToggle({
    Name = "Silent Aim",
    Default = false,
    Flag = "silentaim",
    Callback = function(brd)
        SAS.Enabled = brd
    end
})

local hitchance = MainGroup:AddSlider({
    Name = "Hitchance",
    Min = 0,
    Max = 100,
    Default = 100,
    Step = 1,
    Precise = false,
    Flag = "hitchance",
    Callback = function(value)
       SAS.HitChance = value
    end
})

local manip = MainGroup:AddToggle({
    Name = "Manipulation",
    Default = false,
    Flag = "manipulation",
    Callback = function(brd)
        SAS.WallbangEnabled = brd
    end
})

local fover = MainGroup:AddToggle({
    Name = "FOV",
    Default = false,
    Flag = "fov",
    Callback = function(brd)
        SAS.FOVVisible = brd
    end
})

local snap = MainGroup:AddToggle({
    Name = "Snap Line",
    Default = false,
    Flag = "snapline",
    Callback = function(brd)
        SAS.ShowSnapLine = brd
    end
})

local maincolorpicker = MainGroup:AddColorpicker({
    Name = "Fov Color",
    Amount = 1,
    Default = Color3.fromRGB(255, 255, 255),
    Flag = "FovColor",
    Callback = function(brd)
       SAS.FOVColor = brd
    end
})

local maincolorpiSNAPcker = MainGroup:AddColorpicker({
    Name = "Snap Line Color",
    Amount = 1,
    Default = Color3.fromRGB(255, 255, 255),
    Flag = "SnapLineColor",
    Callback = function(brd)
       SAS.SnapColor = brd
    end
})

local FOVSlider = MainGroup:AddSlider({
    Name = "FOV Size",
    Min = 0,
    Max = 500,
    Default = 130,
    Step = 1,
    Precise = false,
    Flag = "FOVSize",
    Callback = function(value)
        SAS.FOVRadius = value
    end
})

local teamcheck = MainGroup:AddToggle({
    Name = "Team Check",
    Default = false,
    Flag = "teamcheck",
    Callback = function(brd)
        SAS.TeamCheck = brd
    end
})

local visiblecheck = MainGroup:AddToggle({
    Name = "Visible Check",
    Default = false,
    Flag = "visiblecheck",
    Callback = function(brd)
        SAS.VisibleCheck = brd
    end
})

local targetpart = MainGroup:AddDropdown({
    Name = "Target Part",
    Options = {"Head", "HumanoidRootPart", "Random"},
    Default = "Head",
    Flag = "targetpart",
    Callback = function(value)
        SAS.TargetPart = value
    end
})
