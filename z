--!nocheck
-- luacheck: globals cloneref isfile isfolder makefolder writefile readfile listfiles delfile Color3 Enum game UDim2 Vector2 Rect workspace
local cloneref = cloneref or function(x) return x end
local function SRV(name) return cloneref(game:GetService(name)) end
local CoreGui = SRV("CoreGui")
local TweenService = SRV("TweenService")
local TextService = SRV("TextService")
local UserInputService = SRV("UserInputService")
local ContextActionService = SRV("ContextActionService")
local HttpService = SRV("HttpService")
local MarketplaceService = SRV("MarketplaceService")
local _isfile = (isfile or function() return false end)
local _isfolder = (isfolder or function() return false end)
local _makefolder = (makefolder or function() end)
local _writefile = (writefile or function() end)
local _readfile = (readfile or function() return "" end)
local _listfiles = (listfiles or function() return {} end)
local _delfile = (delfile or function() end)
local function Create(className, props, children)
    local inst = Instance.new(className)
    if props then for k, v in pairs(props) do inst[k] = v end end
    if children then for _, c in ipairs(children) do c.Parent = inst end end
    return inst
end
-- Convert a string like "Keypad5", "KeypadFive", "Mouse1" to Enum.KeyCode/UserInputType
local function ParseKeyFromString(name)
    if type(name) ~= "string" then return nil end
    local s = name
    local lower = s:lower()
    -- Mouse buttons
    if lower == "mouse1" or lower == "mb1" or lower == "mousebutton1" then return Enum.UserInputType.MouseButton1 end
    if lower == "mouse2" or lower == "mb2" or lower == "mousebutton2" then return Enum.UserInputType.MouseButton2 end
    -- Common aliases for special/lock keys
    if lower == "backquote" or lower == "grave" or s == "`" or lower == "tilde" or s == "~" then return Enum.KeyCode.Backquote end
    if lower == "printscreen" or lower == "prtsc" or lower == "prtscr" or lower == "print" then return Enum.KeyCode.Print end
    if lower == "scrolllock" or lower == "scrlk" or lower == "scroll" then return Enum.KeyCode.ScrollLock end
    if lower == "pause" or lower == "break" or lower == "pausebreak" then return Enum.KeyCode.Pause end
    if lower == "numlock" or lower == "num" then return Enum.KeyCode.NumLock end
    -- Punctuation/symbol keys
    if lower == "minus" then return Enum.KeyCode.Minus end
    if lower == "equals" or s == "=" then return Enum.KeyCode.Equals end
    if lower == "leftbracket" or lower == "lbracket" or s == "[" then return Enum.KeyCode.LeftBracket end
    if lower == "rightbracket" or lower == "rbracket" or s == "]" then return Enum.KeyCode.RightBracket end
    if lower == "backslash" or s == "\\" then return Enum.KeyCode.BackSlash end
    if lower == "semicolon" or s == ";" then return Enum.KeyCode.Semicolon end
    if lower == "quote" or s == "'" then return Enum.KeyCode.Quote end
    if lower == "comma" or s == "," then return Enum.KeyCode.Comma end
    if lower == "period" then return Enum.KeyCode.Period end
    if lower == "slash" then return Enum.KeyCode.Slash end
    -- Exact Enum name
    if Enum.KeyCode[s] then return Enum.KeyCode[s] end
    -- Keypad numbers as digits -> map to Enum names KeypadZero..KeypadNine
    local d = s:match("^Keypad(%d)$")
    if d then
        local digitToWord = { ["0"]="Zero", ["1"]="One", ["2"]="Two", ["3"]="Three", ["4"]="Four", ["5"]="Five", ["6"]="Six", ["7"]="Seven", ["8"]="Eight", ["9"]="Nine" }
        local word = digitToWord[d]
        if word and Enum.KeyCode["Keypad" .. word] then
            return Enum.KeyCode["Keypad" .. word]
        end
    end
    -- Keypad spelled numbers (e.g., KeypadFive)
    local cap = s:match("^Keypad(%a+)$")
    if cap and Enum.KeyCode["Keypad" .. cap] then return Enum.KeyCode["Keypad" .. cap] end
    -- Operators
    if s == "KeypadPlus" or s == "+" then return Enum.KeyCode.KeypadPlus end
    if s == "KeypadMinus" or s == "-" then return Enum.KeyCode.KeypadMinus end
    if s == "KeypadMultiply" or lower == "keypadmul" or s == "*" then return Enum.KeyCode.KeypadMultiply end
    if s == "KeypadDivide" or lower == "keypaddiv" or s == "/" then return Enum.KeyCode.KeypadDivide end
    if s == "KeypadPeriod" or lower == "keypaddot" or lower == "keypaddecimal" or s == "." then return Enum.KeyCode.KeypadPeriod end
    if s == "KeypadEnter" then return Enum.KeyCode.KeypadEnter end
    -- Common names
    if lower == "enter" then return Enum.KeyCode.Return end
    if lower == "esc" or lower == "escape" then return Enum.KeyCode.Escape end
    if lower == "space" or lower == "spacebar" then return Enum.KeyCode.Space end
    -- Fallback: try raw
    if Enum.KeyCode[s] then return Enum.KeyCode[s] end
    return nil
end

-- Pretty-print key names consistently across the library (declare locally, bind to Library later)
local function FormatKeyName(key)
    -- Accepts EnumItem (KeyCode/UserInputType) or string
    if typeof(key) == "EnumItem" then
        local s = tostring(key):gsub("^Enum%.[^%.]+%.", "")
        local shortcuts = {
            MouseButton1 = "Mouse1", MouseButton2 = "Mouse2", MouseButton3 = "Mouse3",
            ButtonR2 = "R2", ButtonL2 = "L2", ButtonR1 = "R1", ButtonL1 = "L1",
            ButtonA = "A", ButtonB = "B", ButtonX = "X", ButtonY = "Y",
            DPadUp = "DPad↑", DPadDown = "DPad↓", DPadLeft = "DPad←", DPadRight = "DPad→",
            Thumbstick1 = "StickL", Thumbstick2 = "StickR",
            Backspace = "Bksp", Return = "Enter", Space = "Space", Tab = "Tab", Escape = "Esc",
            LeftShift = "LShift", RightShift = "RShift", LeftControl = "LCtrl", RightControl = "RCtrl",
            LeftAlt = "LAlt", RightAlt = "RAlt", CapsLock = "Caps", Insert = "Ins", Delete = "Del",
            Home = "Home", End = "End", PageUp = "PgUp", PageDown = "PgDn",
            Up = "↑", Down = "↓", Left = "←", Right = "→",
            F1 = "F1", F2 = "F2", F3 = "F3", F4 = "F4", F5 = "F5", F6 = "F6", F7 = "F7", F8 = "F8", F9 = "F9", F10 = "F10", F11 = "F11", F12 = "F12"
        }
        -- Additional lock and punctuation keys
        shortcuts["Backquote"] = "`"
        shortcuts["Print"] = "PrtSc"
        shortcuts["ScrollLock"] = "ScrLk"
        shortcuts["Pause"] = "Pause"
        shortcuts["NumLock"] = "Num"
        shortcuts["Minus"] = "-"
        shortcuts["Equals"] = "="
        shortcuts["LeftBracket"] = "["
        shortcuts["RightBracket"] = "]"
        shortcuts["BackSlash"] = "\\"
        shortcuts["Semicolon"] = ";"
        shortcuts["Quote"] = "'"
        shortcuts["Comma"] = ","
        shortcuts["Period"] = "."
        shortcuts["Slash"] = "/"
        -- Keypad digits: convert KeypadZero..KeypadNine -> Keypad0..Keypad9 for compact display
        local wordToDigit = { Zero = "0", One = "1", Two = "2", Three = "3", Four = "4", Five = "5", Six = "6", Seven = "7", Eight = "8", Nine = "9" }
        local cap = s:match("^Keypad(%a+)$")
        if cap and wordToDigit[cap] then
            return "Keypad" .. wordToDigit[cap]
        end
        -- Operators / misc
        shortcuts["KeypadEnter"] = "KeypadEnter"
        shortcuts["KeypadPlus"] = "Keypad+"
        shortcuts["KeypadMinus"] = "Keypad-"
        shortcuts["KeypadMultiply"] = "Keypad*"
        shortcuts["KeypadDivide"] = "Keypad/"
        shortcuts["KeypadPeriod"] = "Keypad."
        return shortcuts[s] or s
    elseif type(key) == "string" then
        -- Normalize string names and aliases
        local k = key
        local lower = k:lower()
        -- Mouse
        if lower == "mouse1" or lower == "mb1" or lower == "mousebutton1" then return "Mouse1" end
        if lower == "mouse2" or lower == "mb2" or lower == "mousebutton2" then return "Mouse2" end
        -- Locks and special
        if lower == "backquote" or lower == "grave" or k == "`" or lower == "tilde" or k == "~" then return "`" end
        if lower == "printscreen" or lower == "prtsc" or lower == "prtscr" or lower == "print" then return "PrtSc" end
        if lower == "scrolllock" or lower == "scrlk" or lower == "scroll" then return "ScrLk" end
        if lower == "pause" or lower == "break" or lower == "pausebreak" then return "Pause" end
        if lower == "numlock" or lower == "num" then return "Num" end
        -- Common keys
        if lower == "backspace" then return "Bksp" end
        if lower == "tab" then return "Tab" end
        if lower == "return" or lower == "enter" then return "Enter" end
        if lower == "escape" or lower == "esc" then return "Esc" end
        if lower == "space" or lower == "spacebar" then return "Space" end
        if lower == "insert" then return "Ins" end
        if lower == "delete" or lower == "del" then return "Del" end
        if lower == "home" then return "Home" end
        if lower == "end" then return "End" end
        if lower == "pageup" or lower == "pgup" then return "PgUp" end
        if lower == "pagedown" or lower == "pgdn" then return "PgDn" end
        if lower == "up" then return "↑" end
        if lower == "down" then return "↓" end
        if lower == "left" then return "←" end
        if lower == "right" then return "→" end
        -- Punctuation/symbol names
        if lower == "minus" or k == "-" then return "-" end
        if lower == "equals" or k == "=" then return "=" end
        if lower == "leftbracket" or lower == "lbracket" or k == "[" then return "[" end
        if lower == "rightbracket" or lower == "rbracket" or k == "]" then return "]" end
        if lower == "backslash" or k == "\\" then return "\\" end
        if lower == "semicolon" or k == ";" then return ";" end
        if lower == "quote" or k == "'" then return "'" end
        if lower == "comma" or k == "," then return "," end
        if lower == "period" or k == "." then return "." end
        if lower == "slash" or k == "/" then return "/" end
        -- Keypad spelled digits to compact
        local wordToDigit = { Zero = "0", One = "1", Two = "2", Three = "3", Four = "4", Five = "5", Six = "6", Seven = "7", Eight = "8", Nine = "9" }
        local cap = k:match("^Keypad(%a+)$")
        if cap and wordToDigit[cap] then return "Keypad" .. wordToDigit[cap] end
        if k:match("^Keypad%d$") then return k end
        -- Operators
        if k == "KeypadPlus" or k == "+" then return "Keypad+" end
        if k == "KeypadMinus" or k == "-" then return "Keypad-" end
        if k == "KeypadMultiply" or lower == "keypadmul" or k == "*" then return "Keypad*" end
        if k == "KeypadDivide" or lower == "keypaddiv" or k == "/" then return "Keypad/" end
        if k == "KeypadPeriod" or lower == "keypaddot" or lower == "keypaddecimal" or k == "." then return "Keypad." end
        if k == "KeypadEnter" then return "KeypadEnter" end
        -- Modifier abbreviations
        if lower == "leftshift" then return "LShift" end
        if lower == "rightshift" then return "RShift" end
        if lower == "leftcontrol" or lower == "lctrl" then return "LCtrl" end
        if lower == "rightcontrol" or lower == "rctrl" then return "RCtrl" end
        if lower == "leftalt" or lower == "lalt" then return "LAlt" end
        if lower == "rightalt" or lower == "ralt" then return "RAlt" end
        if lower == "capslock" then return "Caps" end
        return key
    end
    return "?"
end
local function Round(num, inc) inc = inc or 1 return math.floor(num / inc + 0.5) * inc end
local function Clamp(v, a, b) return (v < a and a) or (v > b and b) or v end
-- Fix math.clamp compatibility
if not math.clamp then
    math.clamp = Clamp
end
local Theme = {
    Bg = Color3.fromRGB(12, 14, 13),
    Panel = Color3.fromRGB(18, 20, 19),
    Stroke = Color3.fromRGB(34, 38, 36),
    Accent = Color3.fromRGB(0, 255, 170),
    Accent2 = Color3.fromRGB(0, 220, 150),
    Text = Color3.fromRGB(235, 238, 236),
    SubText = Color3.fromRGB(158, 165, 160),
    Hover = Color3.fromRGB(32, 36, 34),
    Button = Color3.fromRGB(26, 28, 27),
    Good = Color3.fromRGB(0, 255, 170),
    Warn = Color3.fromRGB(240, 180, 70),
    Bad = Color3.fromRGB(235, 80, 90),
    Scrollbar = Color3.fromRGB(50, 54, 52),
}
local Fonts = {
    Regular = Enum.Font.Gotham,
    Medium = Enum.Font.GothamMedium,
    Bold = Enum.Font.GothamBold,
}
local function T(i, t, p) return TweenService:Create(i, TweenInfo.new(t, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), p) end
-- Global sanitize function for library naming and config paths
local function sanitize(s) s = tostring(s or "Game"); s = s:gsub("[^%w%s%-_]", "_"); s = s:gsub("%s+", "_"); return s end
-- Config system will be created per library instance
local function Signal()
    local h = {}
    return {
        Connect = function(_, fn)
            local c = {Connected = true}
            h[#h+1] = {fn = fn, c = c}
            function c:Disconnect() self.Connected = false end
            return c
        end,
        Fire = function(_, ...)
            for i=1,#h do local x=h[i]; if x.c.Connected then coroutine.wrap(x.fn)(...) end end
        end
    }
end
local Library = { _windows = {}, _controls = {}, _theme = Theme, _fonts = Fonts, _version = "3.1.0", _searchEntries = {}, Flags = {} }
-- Bind previously declared helpers to Library now that it exists
Library.FormatKeyName = FormatKeyName

-- Watermark system
do
    Library._watermark = nil
    Library._watermarkText = ""
    Library._watermarkVisible = true
    Library._watermarkTextColor = Color3.fromRGB(255, 255, 255) -- Default white text
    Library._watermarkBackgroundColor = Theme.Bg
    Library._watermarkAccentColor = Theme.Accent
    Library._watermarkFont = Fonts.Medium
    Library._watermarkFontSize = 13
    Library._watermarkTransparency = 0
    
    -- Watermark position persistence (can be saved/loaded with configs)
    Library._watermarkPosition = Library._watermarkPosition or {
        X = 1, -- Scale
        XOffset = -260, -- Offset
        Y = 0, -- Scale  
        YOffset = 10 -- Offset
    }
    
    -- Create optimized watermark GUI
    local function createWatermark()
        -- Clean up existing watermarks
        if Library._watermark then
            pcall(function() Library._watermark:Destroy() end)
        end
        
        -- Find library ScreenGui for proper parenting
        local libraryGui = nil
        for _, gui in pairs(CoreGui:GetChildren()) do
            if gui:IsA("ScreenGui") and gui.DisplayOrder == 999999 then
                libraryGui = gui
                break
            end
        end
        
        -- Create watermark GUI parented to library
        local watermarkGui = Create("ScreenGui", {
            Name = "Watermark",
            ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
            IgnoreGuiInset = true,
            ResetOnSpawn = false,
            DisplayOrder = 999998,
            Parent = libraryGui or CoreGui -- Parent to library GUI or fallback to CoreGui
        })
        
        -- Calculate proper frame size based on text
        local textService = game:GetService("TextService")
        local tempTextSize = textService:GetTextSize(
            Library._watermarkText or "Watermark", 
            Library._watermarkFontSize, 
            Library._watermarkFont, 
            Vector2.new(math.huge, 30)
        )
        local frameWidth = math.max(tempTextSize.X + 20, 160) -- Ensure minimum width
        
        -- Watermark frame with proper sizing
        local watermarkFrame = Create("TextButton", {
            Name = "WatermarkFrame",
            BackgroundColor3 = Theme.Bg,
            AutoButtonColor = false,
            BorderSizePixel = 0,
            Size = UDim2.fromOffset(frameWidth, 30),
            Position = UDim2.new(
                Library._watermarkPosition.X, 
                Library._watermarkPosition.XOffset,
                Library._watermarkPosition.Y,
                Library._watermarkPosition.YOffset
            ),
            AnchorPoint = Vector2.new(0, 0),
            ZIndex = 1000,
            Text = "",
            Parent = watermarkGui
        })
        
        -- Rounded corners
        Create("UICorner", {CornerRadius = UDim.new(0, 4), Parent = watermarkFrame})
        
        -- Outer border (main outline)
        local outerBorder = Create("UIStroke", {
            Color = Theme.Stroke,
            Thickness = 1.5,
            Transparency = 0.2,
            Parent = watermarkFrame
        })
        
        -- Accent border (inner outline)
        local accentBorder = Create("Frame", {
            BackgroundTransparency = 1,
            Size = UDim2.new(1, -2, 1, -2),
            Position = UDim2.fromOffset(1, 1),
            ZIndex = watermarkFrame.ZIndex + 1,
            Parent = watermarkFrame
        })
        Create("UICorner", {CornerRadius = UDim.new(0, 3), Parent = accentBorder})
        Create("UIStroke", {
            Color = Library._watermarkAccentColor,
            Thickness = 1,
            Transparency = 0.4,
            Parent = accentBorder
        })
        
        -- Inner frame for more detail
        local innerFrame = Create("Frame", {
            BackgroundColor3 = Theme.Panel,
            BackgroundTransparency = 0.7,
            Size = UDim2.new(1, -6, 1, -6),
            Position = UDim2.fromOffset(3, 3),
            ZIndex = watermarkFrame.ZIndex + 2,
            Parent = watermarkFrame
        })
        Create("UICorner", {CornerRadius = UDim.new(0, 2), Parent = innerFrame})
        Create("UIStroke", {
            Color = Theme.Stroke,
            Thickness = 0.5,
            Transparency = 0.6,
            Parent = innerFrame
        })
        
        -- Text label with proper layering
        local watermarkLabel = Create("TextLabel", {
            BackgroundTransparency = 1,
            Size = UDim2.new(1, -12, 1, 0),
            Position = UDim2.fromOffset(6, 0),
            Text = Library._watermarkText,
            Font = Library._watermarkFont,
            TextSize = Library._watermarkFontSize,
            TextColor3 = Library._watermarkTextColor,
            TextTransparency = Library._watermarkTransparency,
            TextXAlignment = Enum.TextXAlignment.Center,
            TextYAlignment = Enum.TextYAlignment.Center,
            TextScaled = false,
            TextWrapped = false,
            ZIndex = watermarkFrame.ZIndex + 10,
            Parent = watermarkFrame,
            TextStrokeTransparency = 0.8,
            TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        })
        
        -- Proper auto-resize function that always fits text
        local function updateSize()
            local textService = game:GetService("TextService")
            local textSize = textService:GetTextSize(
                watermarkLabel.Text, 
                Library._watermarkFontSize, 
                Library._watermarkFont, 
                Vector2.new(math.huge, 30)
            )
            local newWidth = math.max(textSize.X + 20, 160) -- Proper padding to ensure text fits
            
            -- Update frame size immediately
            watermarkFrame.Size = UDim2.fromOffset(newWidth, 30)
            
            -- If watermark is positioned at top-right, adjust X offset to keep it anchored
            if Library._watermarkPosition.X == 1 and Library._watermarkPosition.XOffset < 0 then
                Library._watermarkPosition.XOffset = -(newWidth + 10)
                watermarkFrame.Position = UDim2.new(
                    Library._watermarkPosition.X,
                    Library._watermarkPosition.XOffset,
                    Library._watermarkPosition.Y,
                    Library._watermarkPosition.YOffset
                )
            end
        end
        
        -- Function to save current position
        local function savePosition()
            Library._watermarkPosition = {
                X = watermarkFrame.Position.X.Scale,
                XOffset = watermarkFrame.Position.X.Offset,
                Y = watermarkFrame.Position.Y.Scale,
                YOffset = watermarkFrame.Position.Y.Offset
            }
        end
        
        -- Update functions
        local function updateText(text)
            watermarkLabel.Text = text or ""
            updateSize()
        end
        
        local function updateTextColor(color)
            T(watermarkLabel, 0.15, {TextColor3 = color}):Play()
        end
        
        local function updateAccentColor(color)
            if accentBorder:FindFirstChild("UIStroke") then
                T(accentBorder.UIStroke, 0.15, {Color = color}):Play()
            end
        end
        
        -- Simple watermark dragging - fixed version
        local dragging = false
        local dragStart = Vector2.new(0, 0)
        local frameStart = Vector2.new(0, 0)
        local dragOffset = Vector2.new(0, 0)
        
        -- Helper to get mouse/touch position in GUI space (accounts for top inset)
        local function getMouseGuiPos(input)
            local pos
            if input and input.UserInputType == Enum.UserInputType.Touch then
                -- Touch positions are already in GUI space; do not subtract inset
                pos = Vector2.new(input.Position.X, input.Position.Y)
            else
                -- Mouse location includes top inset; subtract it to align with AbsolutePosition
                pos = UserInputService:GetMouseLocation()
                local ok, inset = pcall(function()
                    return game:GetService("GuiService"):GetGuiInset()
                end)
                if ok and typeof(inset) == "Vector2" then
                    pos = Vector2.new(pos.X, pos.Y - inset.Y)
                end
            end
            return pos
        end
        
        watermarkFrame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                
                -- Get start position
                dragStart = getMouseGuiPos(input)
                frameStart = Vector2.new(watermarkFrame.AbsolutePosition.X, watermarkFrame.AbsolutePosition.Y)
                dragOffset = dragStart - frameStart
                
                -- Visual feedback
                T(outerBorder, 0.1, {Color = Library._watermarkAccentColor, Thickness = 2}):Play()
                if accentBorder:FindFirstChild("UIStroke") then
                    T(accentBorder.UIStroke, 0.1, {Transparency = 0.2}):Play()
                end
            end
        end)
        
        UserInputService.InputChanged:Connect(function(input)
            if not dragging then return end
            
            local currentPos
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                currentPos = getMouseGuiPos(input)
            else
                return
            end
            
            -- Calculate new position using grab offset and parent-relative coordinates
            local parentAbs = Vector2.new(0, 0)
            if watermarkFrame.Parent and watermarkFrame.Parent.AbsolutePosition then
                parentAbs = Vector2.new(watermarkFrame.Parent.AbsolutePosition.X, watermarkFrame.Parent.AbsolutePosition.Y)
            end
            local relX = currentPos.X - parentAbs.X
            local relY = currentPos.Y - parentAbs.Y
            local newX = relX - dragOffset.X
            local newY = relY - dragOffset.Y
            
            -- Bounds from parent size (fallback to viewport if missing)
            local containerW, containerH = 0, 0
            if watermarkFrame.Parent and watermarkFrame.Parent.AbsoluteSize then
                containerW = watermarkFrame.Parent.AbsoluteSize.X
                containerH = watermarkFrame.Parent.AbsoluteSize.Y
            else
                local vp = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920, 1080)
                containerW, containerH = vp.X, vp.Y
            end
            local frameSize = watermarkFrame.AbsoluteSize
            newX = math.clamp(newX, 0, math.max(0, containerW - frameSize.X))
            newY = math.clamp(newY, 0, math.max(0, containerH - frameSize.Y))
            
            watermarkFrame.Position = UDim2.fromOffset(newX, newY)
        end)
        
        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                if dragging then
                    dragging = false
                    
                    -- Save position
                    savePosition()
                    
                    -- Reset visual feedback
                    T(outerBorder, 0.15, {Color = Theme.Stroke, Thickness = 1.5}):Play()
                    if accentBorder:FindFirstChild("UIStroke") then
                        T(accentBorder.UIStroke, 0.15, {Transparency = 0.4}):Play()
                    end
                end
            end
        end)
        
        -- Hover effects for PC (no glow)
        if not (UserInputService.TouchEnabled and not UserInputService.MouseEnabled) then
            watermarkFrame.MouseEnter:Connect(function()
                if not dragging then
                    T(outerBorder, 0.15, {Transparency = 0.1}):Play()
                    if accentBorder:FindFirstChild("UIStroke") then
                        T(accentBorder.UIStroke, 0.15, {Transparency = 0.3}):Play()
                    end
                    T(innerFrame, 0.15, {BackgroundTransparency = 0.5}):Play()
                end
            end)
            
            watermarkFrame.MouseLeave:Connect(function()
                if not dragging then
                    T(outerBorder, 0.15, {Transparency = 0.2}):Play()
                    if accentBorder:FindFirstChild("UIStroke") then
                        T(accentBorder.UIStroke, 0.15, {Transparency = 0.4}):Play()
                    end
                    T(innerFrame, 0.15, {BackgroundTransparency = 0.7}):Play()
                end
            end)
        end
        
        -- Store references
        Library._watermark = watermarkGui
        Library._watermarkFrame = watermarkFrame
        Library._watermarkLabel = watermarkLabel
        Library._outerBorder = outerBorder
        Library._accentBorder = accentBorder
        Library._innerFrame = innerFrame
        Library._saveWatermarkPosition = savePosition
        Library._updateWatermarkText = updateText
        Library._updateWatermarkTextColor = updateTextColor
        Library._updateWatermarkAccentColor = updateAccentColor
        
        -- Initialize
        updateText(Library._watermarkText)
        updateTextColor(Library._watermarkTextColor)
        updateAccentColor(Library._watermarkAccentColor)
        updateSize()
        
        -- Set initial visibility
        watermarkGui.Enabled = Library._watermarkVisible
        
        return watermarkGui
    end
    
    -- Public functions
    function Library:SetWatermark(text)
        self._watermarkText = tostring(text or "")
        
        -- Create watermark if it doesn't exist
        if not self._watermark or not self._watermark.Parent then
            createWatermark()
        end
        
        -- Update text
        if self._updateWatermarkText then
            self._updateWatermarkText(self._watermarkText)
        end
    end
    
    function Library:SetWatermarkVisibility(visible)
        self._watermarkVisible = (visible == true)
        
        -- Create watermark if it doesn't exist and should be visible
        if self._watermarkVisible then
            if not self._watermark or not self._watermark.Parent then
                createWatermark()
            else
                self._watermark.Enabled = true
            end
        else
            -- Hide existing watermark
            if self._watermark and self._watermark.Parent then
                self._watermark.Enabled = false
            end
        end
    end
    
    function Library:GetWatermarkVisibility()
        return self._watermarkVisible
    end
    
    -- Get watermark position (for saving in configs)
    function Library:GetWatermarkPosition()
        return self._watermarkPosition
    end
    
    -- Set watermark position (for loading from configs)
    function Library:SetWatermarkPosition(position)
        if position and type(position) == "table" then
            self._watermarkPosition = {
                X = position.X or 1,
                XOffset = position.XOffset or -260,
                Y = position.Y or 0,
                YOffset = position.YOffset or 10
            }
            
            -- Update frame position if watermark exists
            if self._watermarkFrame then
                self._watermarkFrame.Position = UDim2.new(
                    self._watermarkPosition.X,
                    self._watermarkPosition.XOffset,
                    self._watermarkPosition.Y,
                    self._watermarkPosition.YOffset
                )
            end
        end
    end
    
    -- Advanced customization functions
    function Library:SetWatermarkTextColor(color)
        self._watermarkTextColor = color or Color3.fromRGB(255, 255, 255)
        if self._updateWatermarkTextColor then
            self._updateWatermarkTextColor(self._watermarkTextColor)
        end
    end
    
    function Library:SetWatermarkAccentColor(color)
        self._watermarkAccentColor = color or Theme.Accent
        if self._updateWatermarkAccentColor then
            self._updateWatermarkAccentColor(self._watermarkAccentColor)
        end
    end
    
    function Library:SetWatermarkBackgroundColor(color)
        self._watermarkBackgroundColor = color or Theme.Bg
        if self._updateWatermarkBackgroundColor then
            self._updateWatermarkBackgroundColor(self._watermarkBackgroundColor)
        end
    end
    
    function Library:SetWatermarkFont(font, size)
        self._watermarkFont = font or Fonts.Medium
        self._watermarkFontSize = size or 13
        
        if self._watermarkLabel then
            self._watermarkLabel.Font = self._watermarkFont
            self._watermarkLabel.TextSize = self._watermarkFontSize
            if self._textShadow then
                self._textShadow.Font = self._watermarkFont
                self._textShadow.TextSize = self._watermarkFontSize
            end
            -- Re-trigger size update
            if self._updateWatermarkText then
                self._updateWatermarkText(self._watermarkText)
            end
        end
    end
    
    function Library:SetWatermarkTransparency(transparency)
        self._watermarkTransparency = math.clamp(transparency or 0, 0, 1)
        if self._watermarkLabel then
            T(self._watermarkLabel, 0.2, {TextTransparency = self._watermarkTransparency}):Play()
        end
    end
    
    -- Get current watermark properties
    function Library:GetWatermarkTextColor()
        return self._watermarkTextColor
    end
    
    function Library:GetWatermarkAccentColor()
        return self._watermarkAccentColor
    end
    
    function Library:GetWatermarkBackgroundColor()
        return self._watermarkBackgroundColor
    end
end

-- Keybind List System - Completely Rewritten
do
    Library._keybindList = nil
    Library._keybindListVisible = false
    Library._keybinds = {}
    Library._keybindListTransparency = 0 -- 0 = opaque, 1 = fully transparent
    
    -- Initialize keybind list system
    function Library:InitializeKeybindList()
        self._keybinds = {}
        self._keybindList = nil
        self._keybindListVisible = false
        self._keybindScrollFrame = nil
        self._keybindListTransparency = 0
    end
    
    -- Create beautiful keybind entry
    function Library:_createKeybindEntry(keybindData, layoutOrder)
        local entry = Create("Frame", {
            Name = "KeybindEntry",
            Size = UDim2.new(1, 0, 0, 32),
            BackgroundColor3 = Theme.Panel,
            BackgroundTransparency = self._keybindListTransparency or 0,
            BorderSizePixel = 0,
            LayoutOrder = layoutOrder,
            Parent = self._keybindScrollFrame
        })
        
        Create("UICorner", {CornerRadius = UDim.new(0, 6), Parent = entry})
        Create("UIStroke", {
            Color = Theme.Stroke,
            Thickness = 1,
            Transparency = 0.4,
            Parent = entry
        })
        
        -- Keybind name (left side)
        local nameLabel = Create("TextLabel", {
            Name = "NameLabel",
            Size = UDim2.new(0.4, -8, 1, 0),
            Position = UDim2.fromOffset(12, 0),
            BackgroundTransparency = 1,
            Text = keybindData.name,
            TextColor3 = Theme.Text,
            TextSize = 12,
            Font = Fonts.Medium,
            TextXAlignment = Enum.TextXAlignment.Left,
            TextTruncate = Enum.TextTruncate.AtEnd,
            Parent = entry
        })
        
        -- Key display (center)
        local keyContainer = Create("Frame", {
            Name = "KeyContainer",
            Size = UDim2.new(0, 45, 0, 20),
            Position = UDim2.new(0.4, 5, 0.5, -10),
            BackgroundColor3 = Theme.Bg,
            BackgroundTransparency = math.clamp((self._keybindListTransparency or 0) * 0.8, 0, 1),
            BorderSizePixel = 0,
            Parent = entry
        })
        
        Create("UICorner", {CornerRadius = UDim.new(0, 4), Parent = keyContainer})
        Create("UIStroke", {
            Color = Theme.Accent,
            Thickness = 1,
            Transparency = 0.3,
            Parent = keyContainer
        })
        
        local function formatKeyShortcut(key)
            return Library.FormatKeyName(key)
        end
        local keyLabel = Create("TextLabel", {
            Name = "KeyLabel",
            Size = UDim2.new(1, 0, 1, 0),
            BackgroundTransparency = 1,
            Text = formatKeyShortcut(keybindData.key),
            TextColor3 = Theme.Accent,
            TextSize = 10,
            Font = Fonts.Bold,
            TextXAlignment = Enum.TextXAlignment.Center,
            Parent = keyContainer
        })
        
        -- Status indicator (right side)
        -- Use unified 'active' flag for both Keybind and ToggleKeybind entries
        local isActive = keybindData.active and true or false
        
        local statusColor = isActive and Theme.Good or Theme.Bad
        local statusText = isActive and "ON" or "OFF"
        
        local statusContainer = Create("Frame", {
            Name = "StatusContainer",
            Size = UDim2.new(0, 32, 0, 18),
            Position = UDim2.new(1, -38, 0.5, -9),
            BackgroundColor3 = statusColor,
            BorderSizePixel = 0,
            Parent = entry
        })
        
        Create("UICorner", {CornerRadius = UDim.new(0, 3), Parent = statusContainer})
        
        local statusLabel = Create("TextLabel", {
            Name = "StatusLabel",
            Size = UDim2.new(1, 0, 1, 0),
            BackgroundTransparency = 1,
            Text = statusText,
            TextColor3 = Color3.fromRGB(255, 255, 255),
            TextSize = 9,
            Font = Fonts.Bold,
            TextXAlignment = Enum.TextXAlignment.Center,
            Parent = statusContainer
        })
        
        -- Note: Do not attach custom fields to Instances (Roblox userdata).
        -- If metadata is needed later, store it in a separate Lua table keyed by 'entry'.
        -- For now, no external references are required for updates.

        return entry
    end

    -- Apply transparency to existing keybind list UI
    function Library:_applyKeybindListTransparency(alpha, tweenTime)
        self._keybindListTransparency = math.clamp(tonumber(alpha) or 0, 0, 1)
        local tt = tonumber(tweenTime) or 0.15
        if not self._keybindList then return end
        local mainFrame = self._keybindList:FindFirstChild("MainFrame")
        if mainFrame then
            T(mainFrame, tt, {BackgroundTransparency = self._keybindListTransparency}):Play()
            -- Title bar
            local titleBar = mainFrame:FindFirstChild("TitleBar")
            if titleBar then
                T(titleBar, tt, {BackgroundTransparency = self._keybindListTransparency}):Play()
            end
        end
        -- Entries
        if self._keybindScrollFrame then
            for _, child in ipairs(self._keybindScrollFrame:GetChildren()) do
                if child:IsA("Frame") and child.Name == "KeybindEntry" then
                    T(child, tt, {BackgroundTransparency = self._keybindListTransparency}):Play()
                    local keyContainer = child:FindFirstChild("KeyContainer")
                    if keyContainer then
                        T(keyContainer, tt, {BackgroundTransparency = math.clamp(self._keybindListTransparency * 0.8, 0, 1)}):Play()
                    end
                end
            end
        end
    end

    function Library:SetKeybindListTransparency(alpha, tweenTime)
        self:_applyKeybindListTransparency(alpha, tweenTime)
    end

    function Library:GetKeybindListTransparency()
        return self._keybindListTransparency or 0
    end
    
    function Library:ResetKeybindListTransparency(tweenTime)
        self:_applyKeybindListTransparency(0, tweenTime)
    end
    
    -- Update keybind display
    function Library:_updateKeybindDisplay()
        if not self._keybindScrollFrame then return end
        
        -- Clear existing entries
        for _, child in pairs(self._keybindScrollFrame:GetChildren()) do
            if child:IsA("Frame") and child.Name == "KeybindEntry" then
                child:Destroy()
            end
        end
        

        
        local layoutOrder = 1
        
        -- Process all tracked keybinds
        for id, keybindData in pairs(self._keybinds) do
            local shouldShow = false
            
            if keybindData.type == "Keybind" then
                -- AddKeybind: show if user added it to list
                shouldShow = keybindData.showInList
            elseif keybindData.type == "ToggleKeybind" then
                -- AddToggleKeybind: show whenever its toggle is enabled, regardless of list toggle
                -- (per requirement: appears only when toggle is enabled and shows when turned on)
                if keybindData.keybindObject and keybindData.keybindObject.GetToggle then
                    local ok, toggled = pcall(function()
                        return keybindData.keybindObject:GetToggle()
                    end)
                    shouldShow = ok and (toggled == true) or false
                else
                    shouldShow = keybindData.toggleEnabled == true
                end
            end
            
            if shouldShow then
                -- Get current state from the keybind object
                if keybindData.keybindObject then
                    if keybindData.type == "Keybind" then
                        -- Regular keybind: reflect mode-specific active state tracked on the object
                        keybindData.active = keybindData.keybindObject._isActive and true or false
                    elseif keybindData.type == "ToggleKeybind" then
                        -- Toggle keybind: pull toggle + active + key name via Get()
                        local info = nil
                        local ok, res = pcall(function()
                            return keybindData.keybindObject:Get()
                        end)
                        if ok then info = res end
                        if info then
                            keybindData.toggleEnabled = info.Toggle and true or false
                            keybindData.active = info.Active and true or false
                            if info.KeyName then keybindData.key = info.KeyName end
                        else
                            -- Fallbacks
                            local ok2, toggled = pcall(function()
                                return keybindData.keybindObject:GetToggle()
                            end)
                            keybindData.toggleEnabled = ok2 and (toggled == true) or false
                            keybindData.active = keybindData.toggleEnabled
                        end
                    end
                end
                -- Create UI entry
                self:_createKeybindEntry(keybindData, layoutOrder)
                layoutOrder = layoutOrder + 1
            end
        end
    end
    
    -- New keybind list dragging system
    function Library:_setupKeybindListDragging(frame, strokeElement)
        local isDragging = false
        local startPos = Vector2.new(0, 0)
        local frameStartPos = Vector2.new(0, 0)
        local dragOffset = Vector2.new(0, 0)
        local parentAbsAtStart = Vector2.new(0, 0)
        
        -- Helper to get mouse/touch position in GUI space (accounts for top inset)
        local function getMouseGuiPos(input)
            local pos
            if input and input.UserInputType == Enum.UserInputType.Touch then
                -- Touch already uses GUI coordinate space in AbsolutePosition terms
                pos = Vector2.new(input.Position.X, input.Position.Y)
            else
                pos = UserInputService:GetMouseLocation()
                local ok, inset = pcall(function()
                    return game:GetService("GuiService"):GetGuiInset()
                end)
                if ok and typeof(inset) == "Vector2" then
                    pos = Vector2.new(pos.X, pos.Y - inset.Y)
                end
            end
            return pos
        end
        
        frame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                isDragging = true
                
                -- Record starting positions
                startPos = getMouseGuiPos(input)
                frameStartPos = Vector2.new(frame.AbsolutePosition.X, frame.AbsolutePosition.Y)
                -- Capture the offset between the cursor and the frame's top-left so it stays under the mouse
                dragOffset = startPos - frameStartPos
                -- Capture parent's absolute position at start for consistent relative calculations
                if frame.Parent and frame.Parent.AbsolutePosition then
                    parentAbsAtStart = Vector2.new(frame.Parent.AbsolutePosition.X, frame.Parent.AbsolutePosition.Y)
                else
                    parentAbsAtStart = Vector2.new(0, 0)
                end
                
                -- Visual feedback
                T(strokeElement, 0.15, {Color = Theme.Accent, Thickness = 2}):Play()
            end
        end)
        
        UserInputService.InputChanged:Connect(function(input)
            if not isDragging then return end
            
            local currentPos
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                currentPos = getMouseGuiPos(input)
            elseif input.UserInputType == Enum.UserInputType.Touch then
                currentPos = getMouseGuiPos(input)
            else
                return
            end
            
            -- Calculate new position using parent-relative coordinates and the initial grab offset
            local parentAbsNow = Vector2.new(0, 0)
            if frame.Parent and frame.Parent.AbsolutePosition then
                parentAbsNow = Vector2.new(frame.Parent.AbsolutePosition.X, frame.Parent.AbsolutePosition.Y)
            end
            -- Cursor position relative to parent
            local relX = currentPos.X - parentAbsNow.X
            local relY = currentPos.Y - parentAbsNow.Y
            -- New top-left by subtracting the grab offset
            local newX = relX - dragOffset.X
            local newY = relY - dragOffset.Y

            -- Bounds using parent's size for robustness
            local containerW, containerH = 0, 0
            if frame.Parent and frame.Parent.AbsoluteSize then
                containerW = frame.Parent.AbsoluteSize.X
                containerH = frame.Parent.AbsoluteSize.Y
            else
                local vp = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920, 1080)
                containerW, containerH = vp.X, vp.Y
            end
            local frameSize = frame.AbsoluteSize
            newX = math.clamp(newX, 0, math.max(0, containerW - frameSize.X))
            newY = math.clamp(newY, 0, math.max(0, containerH - frameSize.Y))

            -- Apply new position
            frame.Position = UDim2.fromOffset(newX, newY)
        end)
        
        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                if isDragging then
                    isDragging = false
                    T(strokeElement, 0.2, {Color = Theme.Stroke, Thickness = 1}):Play()
                end
            end
        end)
    end
    
    -- Create the main keybind list GUI
    function Library:_createKeybindList()
        if self._keybindList then
            pcall(function() self._keybindList:Destroy() end)
        end
        
        -- Find the library's ScreenGui
        local libraryGui = nil
        for _, gui in pairs(CoreGui:GetChildren()) do
            if gui:IsA("ScreenGui") and gui.DisplayOrder == 999999 then
                libraryGui = gui
                break
            end
        end
        
        if not libraryGui then
            warn("Could not find library GUI for keybind list")
            return
        end
        
        -- Create keybind list ScreenGui
        self._keybindList = Create("ScreenGui", {
            Name = "KeybindList",
            Parent = libraryGui,
            IgnoreGuiInset = true,
            ResetOnSpawn = false,
            DisplayOrder = 999998
        })
        
        -- Main frame
        local mainFrame = Create("TextButton", {
            Name = "MainFrame",
            Size = UDim2.fromOffset(240, 300),
            Position = UDim2.new(0, 16, 0.5, -150), -- middle-left (height 300 => offset -150)
            BackgroundColor3 = Theme.Bg,
            AutoButtonColor = false,
            BorderSizePixel = 0,
            Text = "",
            Parent = self._keybindList
        })
        
        Create("UICorner", {CornerRadius = UDim.new(0, 8), Parent = mainFrame})
        
        -- Outer border
        local outerStroke = Create("UIStroke", {
            Color = Theme.Stroke,
            Thickness = 1,
            Transparency = 0.2,
            Parent = mainFrame
        })
        
        -- Accent glow effect
        local accentFrame = Create("Frame", {
            Size = UDim2.new(1, -2, 1, -2),
            Position = UDim2.fromOffset(1, 1),
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            Parent = mainFrame
        })
        
        Create("UICorner", {CornerRadius = UDim.new(0, 7), Parent = accentFrame})
        Create("UIStroke", {
            Color = Theme.Accent,
            Thickness = 1,
            Transparency = 0.7,
            Parent = accentFrame
        })
        
        -- Title bar
        local titleBar = Create("Frame", {
            Name = "TitleBar",
            Size = UDim2.new(1, 0, 0, 36),
            BackgroundColor3 = Theme.Panel,
            BorderSizePixel = 0,
            Parent = mainFrame
        })
        
        Create("UICorner", {CornerRadius = UDim.new(0, 8), Parent = titleBar})
        Create("UIStroke", {
            Color = Theme.Stroke,
            Thickness = 1,
            Transparency = 0.5,
            Parent = titleBar
        })
        
        -- Title text
        Create("TextLabel", {
            Name = "TitleText",
            Size = UDim2.new(1, -16, 1, 0),
            Position = UDim2.fromOffset(16, 0),
            BackgroundTransparency = 1,
            Text = "Keybind List",
            TextColor3 = Theme.Text,
            TextSize = 14,
            Font = Fonts.Bold,
            TextXAlignment = Enum.TextXAlignment.Left,
            Parent = titleBar
        })
        
        -- Scrolling frame for entries
        self._keybindScrollFrame = Create("ScrollingFrame", {
            Name = "ScrollingFrame",
            Size = UDim2.new(1, -12, 1, -48),
            Position = UDim2.fromOffset(6, 42),
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            ScrollBarThickness = 6,
            ScrollBarImageColor3 = Theme.Accent,
            ScrollBarImageTransparency = 0.4,
            CanvasSize = UDim2.fromOffset(0, 0),
            AutomaticCanvasSize = Enum.AutomaticSize.Y,
            Parent = mainFrame
        })
        
        -- Layout for entries
        Create("UIListLayout", {
            SortOrder = Enum.SortOrder.LayoutOrder,
            Padding = UDim.new(0, 4),
            Parent = self._keybindScrollFrame
        })
        
        -- Add padding to center entries within the frame
        Create("UIPadding", {
            PaddingLeft = UDim.new(0, 8),
            PaddingRight = UDim.new(0, 8),
            PaddingTop = UDim.new(0, 4),
            PaddingBottom = UDim.new(0, 4),
            Parent = self._keybindScrollFrame
        })
        
        -- Simple and reliable keybind list dragging
        self:_setupKeybindListDragging(mainFrame, outerStroke)
        
    -- Initial update
        self:_updateKeybindDisplay()
    -- Apply current transparency to freshly created UI
    self:_applyKeybindListTransparency(self._keybindListTransparency or 0, 0)
        
        -- Real-time updates
        task.spawn(function()
            while self._keybindList and self._keybindList.Parent do
                task.wait(0.3)
                if self._keybindListVisible then
                    self:_updateKeybindDisplay()
                    -- re-apply transparency to any new entries
                    self:_applyKeybindListTransparency(self._keybindListTransparency, 0)
                end
            end
        end)
    end
    
    -- Keybind tracking functions
    function Library:_addKeybind(name, key, type, data)
        local id = name .. "_" .. (key or "None") .. "_" .. type
        self._keybinds[id] = {
            name = name,
            key = key,
            type = type,
            active = data.active or false,
            toggleEnabled = data.toggleEnabled or false,
            showInList = data.showInList ~= false,
            keybindObject = data.keybindObject
        }
        return id
    end
    
    function Library:_updateKeybind(id, updates)
        if self._keybinds[id] then
            for k, v in pairs(updates) do
                self._keybinds[id][k] = v
            end
        end
    end
    
    function Library:_toggleKeybindInList(id)
        if self._keybinds[id] then
            self._keybinds[id].showInList = not self._keybinds[id].showInList
            return self._keybinds[id].showInList
        end
        return false
    end
    
    function Library:_removeKeybind(id)
        if self._keybinds[id] then
            self._keybinds[id] = nil
        end
    end
    
    -- Public visibility functions
    function Library:ShowKeybindList(visible)
        self._keybindListVisible = (visible == true)
        
        if self._keybindListVisible then
            if not self._keybindList or not self._keybindList.Parent then
                self:_createKeybindList()
            else
                self._keybindList.Enabled = true
            end
        else
            if self._keybindList and self._keybindList.Parent then
                self._keybindList.Enabled = false
            end
        end
    end
    
    function Library:GetKeybindListVisibility()
        return self._keybindListVisible
    end
    
    function Library:ToggleKeybindList()
        self:ShowKeybindList(not self._keybindListVisible)
    end
end

-- RootGui will be created per library instance with custom name
function Library:_registerControl(c)
    self._controls[c.id] = c
    -- If the control id is a simple flag (no path separators), expose via Library.Flags
    if type(c.id) == "string" and not string.find(c.id, "/", 1, true) then
        self.Flags[c.id] = c
    end
end
function Library:_setValue(id, v, s) local c = self._controls[id]; if c and c.Set then c:Set(v, s) end end
function Library:_getSnapshot() local d = {} for id, c in pairs(self._controls) do if c.Get then d[id] = c:Get() end end return d end
-- Config functions will be added to Window instance in CreateLibrary

function Library:CreateLibrary(opts)
    -- destroy previous instance windows if any (singleton behavior)
    if self._singletonRoot and self._singletonRoot.Parent then
        pcall(function()
            for _, child in ipairs(self._singletonRoot:GetChildren()) do child:Destroy() end
            self._singletonRoot:Destroy()
        end)
    end
    -- reset search entries on new window
    self._searchEntries = {}
    -- reset public Flags mapping for the new UI instance
    self.Flags = {}
    -- Initialize keybind list system
    self:InitializeKeybindList()
    opts = opts or {}
    local title = tostring(opts.Name or "Dendrite UI")
    local libraryName = tostring(opts.LibraryName or "Dendrite UI")
    local titleMode = tostring(opts.TitleMode or "Static"):lower() -- static | type
    
    -- Create Config system for this library instance
    local Config = {}
    do
        local function gameKey()
            local ok, info = pcall(function() return MarketplaceService:GetProductInfo(game.PlaceId) end)
            if ok and info and info.Name and #info.Name > 0 then return sanitize(info.Name) end
            return "Place_" .. tostring(game.PlaceId)
        end
        local Base = sanitize(libraryName)
        -- Build a per-game subfolder key (sanitized name + place id). Fallbacks ensure it works everywhere.
        local function getGameFolder()
            local placeId = 0
            local okPlace, pid = pcall(function() return game.PlaceId end)
            if okPlace and tonumber(pid) then placeId = tonumber(pid) end
            local placeName = nil
            local okName, info = pcall(function()
                if placeId and placeId ~= 0 then
                    return MarketplaceService:GetProductInfo(placeId)
                end
                return nil
            end)
            if okName and type(info) == "table" and info.Name then
                placeName = tostring(info.Name)
            end
            local namePart = sanitize(placeName or "Game")
            local idPart = tostring(placeId or 0)
            return ("%s_%s"):format(namePart, idPart)
        end
        local Folder = Base .. "/" .. getGameFolder()
        function Config.Ensure() if not _isfolder(Base) then _makefolder(Base) end if not _isfolder(Folder) then _makefolder(Folder) end end
        function Config.Path(n) Config.Ensure() return Folder .. "/" .. sanitize(n) .. ".json" end

        -- JSON-safe serialization helpers
        local function serialize(val)
            local t = typeof(val)
            if t == "nil" or t == "number" or t == "boolean" or t == "string" then
                return val
            elseif t == "Color3" then
                return { __t = "c3", r = math.floor(val.R*255+0.5), g = math.floor(val.G*255+0.5), b = math.floor(val.B*255+0.5) }
            elseif t == "EnumItem" then
                local et = val.EnumType and val.EnumType.Name or nil
                local vn = val.Name
                return { __t = "enum", e = et, v = vn }
            elseif t == "UDim2" then
                return { __t = "ud2", xs = val.X.Scale, xo = val.X.Offset, ys = val.Y.Scale, yo = val.Y.Offset }
            elseif t == "Vector2" then
                return { __t = "v2", x = val.X, y = val.Y }
            elseif t == "table" then
                local out = {}
                for k, v in pairs(val) do out[k] = serialize(v) end
                return out
            else
                -- Fallback to string (e.g., unknown userdata) to avoid encode failure
                return tostring(val)
            end
        end
        local function deserialize(val)
            local t = typeof(val)
            if t ~= "table" then return val end
            if val.__t == "c3" then
                local r,g,b = tonumber(val.r) or 255, tonumber(val.g) or 255, tonumber(val.b) or 255
                return Color3.fromRGB(r,g,b)
            elseif val.__t == "enum" then
                local eName, vName = tostring(val.e or ""), tostring(val.v or "")
                if Enum[eName] and Enum[eName][vName] then return Enum[eName][vName] end
                -- KeyCode/UserInputType special case via parser
                local parsed = ParseKeyFromString(vName)
                return parsed or vName
            elseif val.__t == "ud2" then
                return UDim2.new(val.xs or 0, val.xo or 0, val.ys or 0, val.yo or 0)
            elseif val.__t == "v2" then
                return Vector2.new(val.x or 0, val.y or 0)
            end
            local out = {}
            for k, v in pairs(val) do out[k] = deserialize(v) end
            return out
        end

        function Config.Save(n, d)
            local p = Config.Path(n)
            local ok, j = pcall(function() return HttpService:JSONEncode(serialize(d or {})) end)
            if ok then _writefile(p, j) end
            return ok
        end
        function Config.Load(n)
            local p = Config.Path(n)
            if _isfile(p) then
                local ok, t = pcall(function() return HttpService:JSONDecode(_readfile(p)) end)
                if ok and type(t) == "table" then return deserialize(t) end
            end
            return {}
        end
        function Config.List()
            Config.Ensure()
            local r = {}
            for _, f in ipairs(_listfiles(Folder) or {}) do
                local n = f:match("([^/\\]+)$") or f
                -- skip meta file
                if n ~= "__meta.json" then
                    n = n:gsub("%.json$", "")
                    table.insert(r, n)
                end
            end
            table.sort(r)
            return r
        end
        function Config.Delete(n) local p = Config.Path(n) if _isfile(p) then _delfile(p) end end

        -- Meta persistence for autoload flags and last-saved timestamps
        local function MetaPath() Config.Ensure() return Folder .. "/__meta.json" end
        local function LoadMeta()
            local p = MetaPath()
            if _isfile(p) then
                local ok, t = pcall(function() return HttpService:JSONDecode(_readfile(p)) end)
                if ok and type(t) == "table" then
                    t.autoload = t.autoload or {}
                    t.lastSaved = t.lastSaved or {}
                    return t
                end
            end
            return { autoload = {}, lastSaved = {} }
        end
        local function SaveMeta(m)
            local p = MetaPath()
            local ok, j = pcall(function() return HttpService:JSONEncode(m or {autoload = {}, lastSaved = {}}) end)
            if ok then _writefile(p, j) end
            return ok
        end
        function Config.SetAutoLoad(name, on)
            if not name or name == "" then return end
            local m = LoadMeta()
            m.autoload[sanitize(name)] = (on == true) or nil -- nil removes key
            -- if enabling autoload and no timestamp yet, seed it so MostRecent works
            if on == true then
                local key = sanitize(name)
                m.lastSaved[key] = m.lastSaved[key] or os.time()
            end
            SaveMeta(m)
        end
        function Config.GetAutoLoad(name)
            if not name or name == "" then return false end
            local m = LoadMeta()
            return m.autoload[sanitize(name)] == true
        end
        function Config.RecordSave(name)
            if not name or name == "" then return end
            local m = LoadMeta()
            local key = sanitize(name)
            -- Only persist meta if this config is autoloaded (avoid creating __meta until needed)
            if m.autoload[key] then
                m.lastSaved[key] = os.time()
                SaveMeta(m)
            end
        end
        function Config.ClearMeta(name)
            if not name or name == "" then return end
            local key = sanitize(name)
            local m = LoadMeta()
            m.autoload[key] = nil
            m.lastSaved[key] = nil
            SaveMeta(m)
        end
        function Config.MostRecentAutoLoad()
            local m = LoadMeta()
            local newest, newestT = nil, -math.huge
            for n, on in pairs(m.autoload) do
                if on then
                    local t = tonumber(m.lastSaved[n] or 0) or 0
                    if t > newestT then newestT, newest = t, n end
                end
            end
            return newest
        end
    end
    
    -- Create ScreenGui with custom name
    local screenGuiName = sanitize(libraryName)
    -- Remove any existing ScreenGui with this name
    for _, child in ipairs(CoreGui:GetChildren()) do
        if child:IsA("ScreenGui") and child.Name == screenGuiName then
            pcall(function() child:Destroy() end)
        end
    end
    local RootGui = Create("ScreenGui", {Name = screenGuiName, ZIndexBehavior = Enum.ZIndexBehavior.Sibling, IgnoreGuiInset = true, ResetOnSpawn = false, DisplayOrder = 999999, Parent = CoreGui})
    -- Removed TitleTypeConfig: using fixed tuned timings
    local autoDevice = opts.AutoDeviceCheck == true
    local forceShowMobileBtn = opts.ShowMobileButton == true -- new option: show mobile toggle even on PC
    local size = opts.Size or UDim2.fromOffset(600, 540)
    local closeCb = opts.CloseCallback
    local Window = { Name = title, _categories = {}, _selectedCategory = nil }
    local z = 100
    local rootStroke = Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})
    -- device adapt
    local isMobile = (UserInputService.TouchEnabled and not UserInputService.MouseEnabled) or (UserInputService.KeyboardEnabled == false)
    if isMobile and autoDevice then
        size = UDim2.fromOffset(math.clamp(size.X.Offset, 480, 560), math.clamp(size.Y.Offset, 360, 420))
    end
    local showMobileBtn = isMobile or forceShowMobileBtn
    local root = Create("Frame", {Name = "Window", Size = size, BackgroundColor3 = Theme.Panel, BorderSizePixel = 0, Position = UDim2.fromScale(0.5, 0.5), AnchorPoint = Vector2.new(0.5, 0.5), ZIndex = z, Parent = RootGui}, {
        rootStroke,
        -- added gentle rounding (was square); adjust 12 -> different look if needed
        Create("UICorner", {CornerRadius = UDim.new(0,12)})
    })
    self._singletonRoot = root
    -- Simplified header: clean bar + single accent line
    -- header color lightened (was Theme.Bg) to match panel tone for preview
    local header = Create("Frame", {Name = "Header", Size = UDim2.new(1, 0, 0, 42), BackgroundColor3 = Theme.Panel, BorderSizePixel = 0, ZIndex = z + 1, Parent = root}, {
        Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.25}),
        -- mirror rounding so top edge matches window curvature (bottom stays visually seamless)
        Create("UICorner", {CornerRadius = UDim.new(0,12)})
    })
    -- removed accent line per request
    local titleLabel = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1, -160, 1, 0), Position = UDim2.fromOffset(12, 0), Text = title:upper(), TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Font = Fonts.Bold, TextSize = 16, ZIndex = z + 2, Parent = header})
    -- Title animation: only Static or looping Type
    if titleMode == "type" then
        task.spawn(function()
            local function animateText(display, text, delay)
                if not display then return end
                local animatedRandom = "1234567890"
                for i = 1, #text do
                    local revealChar = text:sub(i, i)
                    local displayText = text:sub(1, i - 1)
                    for _ = 1, math.random(1, 6) do
                        local random = math.random(1, #animatedRandom)
                        local randomChar = animatedRandom:sub(random, random)
                        display.Text = displayText .. randomChar
                        task.wait(delay)
                    end
                    display.Text = displayText .. revealChar
                    task.wait(delay)
                end
                task.wait(5)
            end
            local upper = title:upper()
            while true do
                titleLabel.Text = ""
                animateText(titleLabel, upper, 0.045)
            end
        end)
    else
        titleLabel.Text = title:upper()
    end
    local btnCluster = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(108, 32), Position = UDim2.new(1, -8, 0.5, 0), AnchorPoint = Vector2.new(1,0.5), Parent = header})
    local clusterLayout = Create("UIListLayout", {FillDirection = Enum.FillDirection.Horizontal, HorizontalAlignment = Enum.HorizontalAlignment.Right, VerticalAlignment = Enum.VerticalAlignment.Center, Padding = UDim.new(0,4)}) clusterLayout.Parent = btnCluster
    local function makeHeaderBtn(iconChar)
        local b = Create("TextButton", {Size = UDim2.fromOffset(32,32), BackgroundColor3 = Theme.Button, AutoButtonColor = false, Text = iconChar, Font = Fonts.Medium, TextSize = 18, TextColor3 = Theme.Text, ZIndex = z + 3, Parent = btnCluster}, {
            Create("UICorner", {CornerRadius = UDim.new(0,5)}),
            Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})
        })
        b.MouseEnter:Connect(function() T(b,0.12,{BackgroundColor3 = Theme.Hover}):Play() end)
        b.MouseLeave:Connect(function() T(b,0.12,{BackgroundColor3 = Theme.Button}):Play() end)
        return b
    end
    local closeBtn = makeHeaderBtn("X")
    local fsBtn = makeHeaderBtn("")
    local minBtn = makeHeaderBtn("–")
    -- reposition cluster order: minimize, fullscreen, close (already appended; adjust layout order)
    minBtn.LayoutOrder = 1 fsBtn.LayoutOrder = 2 closeBtn.LayoutOrder = 3
    -- custom fullscreen icon (aggressive corners)
    local fsIcon = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(16,16), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.fromScale(0.5,0.5), Parent = fsBtn})
    local function makeCorner(ax, ay)
        local c = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(7,7), AnchorPoint = Vector2.new(ax,ay), Position = UDim2.new(ax, ax==1 and -1 or 1, ay, ay==1 and -1 or 1), Parent = fsIcon})
    Create("Frame", {BackgroundColor3 = Theme.Text, BorderSizePixel = 0, Size = UDim2.fromOffset(7,2), Position = UDim2.new(ax==1 and 1 or 0, ax==1 and -7 or 0, ay==1 and 1 or 0, ay==1 and -2 or 0), Parent = c})
    Create("Frame", {BackgroundColor3 = Theme.Text, BorderSizePixel = 0, Size = UDim2.fromOffset(2,7), Position = UDim2.new(ax==1 and 1 or 0, ax==1 and -2 or 0, ay==1 and 1 or 0, ay==1 and -7 or 0), Parent = c})
        return c
    end
    local fsCorners = {makeCorner(0,0), makeCorner(1,0), makeCorner(0,1), makeCorner(1,1)}
    closeBtn.MouseEnter:Connect(function() T(closeBtn, 0.12, {BackgroundColor3 = Theme.Bad}):Play() end)
    closeBtn.MouseLeave:Connect(function() T(closeBtn, 0.16, {BackgroundColor3 = Theme.Button}):Play() end)
    closeBtn.MouseButton1Click:Connect(function() root.Visible = false if type(closeCb) == "function" then pcall(closeCb) end end)
    minBtn.MouseEnter:Connect(function() T(minBtn, 0.12, {BackgroundColor3 = Theme.Hover}):Play() end)
    minBtn.MouseLeave:Connect(function() T(minBtn, 0.12, {BackgroundColor3 = Theme.Button}):Play() end)
    fsBtn.MouseEnter:Connect(function() T(fsBtn, 0.12, {BackgroundColor3 = Theme.Hover}):Play() end)
    fsBtn.MouseLeave:Connect(function() T(fsBtn, 0.12, {BackgroundColor3 = Theme.Button}):Play() end)
    local minimized, prevSize, prevPos = false, root.Size, root.Position
    local fullscreen, fsPrevSize, fsPrevPos = false, nil, nil
    local windowStateChanging = false -- Flag to prevent search interference during window state changes
    
    -- Forward declarations for resize management
    local allGrips = {} -- Store all resize grips for management
    local resizing = false
    local setResizeEnabled -- Forward declaration
    
    -- Function to enable/disable resize functionality
    setResizeEnabled = function(enabled)
        for _, grip in pairs(allGrips) do
            grip.Active = enabled
            grip.Visible = enabled
        end
        if not enabled then
            -- Force end any active resize
            resizing = false
            -- Reset visual effects will be handled in the resize section
        end
    end
    
    minBtn.MouseButton1Click:Connect(function()
        windowStateChanging = true -- Lock search system during state change
        if fullscreen then
            -- exit fullscreen first
            T(root, 0.18, {Size = fsPrevSize, Position = fsPrevPos}):Play()
            fullscreen = false
            setResizeEnabled(true) -- Re-enable resize grips when exiting fullscreen
        end
        minimized = not minimized
        if minimized then
            prevSize = root.Size; prevPos = root.Position
            setResizeEnabled(false) -- Disable resize grips when minimized
            for _, child in ipairs(root:GetChildren()) do if child ~= header and child:IsA("GuiObject") then child.Visible = false end end
            T(root, 0.18, {Size = UDim2.new(prevSize.X.Scale, prevSize.X.Offset, 0, header.Size.Y.Offset)}):Play()
        else
            for _, child in ipairs(root:GetChildren()) do if child ~= header and child:IsA("GuiObject") then child.Visible = true end end
            T(root, 0.18, {Size = prevSize, Position = prevPos}):Play()
            setResizeEnabled(true) -- Re-enable resize grips when restored
        end
        -- Non-blocking unlock after animation completes
        task.spawn(function()
            task.wait(0.25)
            windowStateChanging = false
        end)
    end)
    fsBtn.MouseButton1Click:Connect(function()
        windowStateChanging = true -- Lock search system during state change
        if minimized then
            -- restore from minimized before fullscreen
            minimized = false
            for _, child in ipairs(root:GetChildren()) do if child ~= header and child:IsA("GuiObject") then child.Visible = true end end
            T(root, 0.12, {Size = prevSize, Position = prevPos}):Play()
        end
        if not fullscreen then
            fsPrevSize, fsPrevPos = root.Size, root.Position
            setResizeEnabled(false) -- Disable resize grips in fullscreen
            T(root, 0.22, {Size = UDim2.new(1, -20, 1, -20), Position = UDim2.fromScale(0.5, 0.5)}):Play()
            fullscreen = true
        else
            T(root, 0.22, {Size = fsPrevSize, Position = fsPrevPos}):Play()
            fullscreen = false
            setResizeEnabled(true) -- Re-enable resize grips when exiting fullscreen
        end
        -- Non-blocking unlock after animation completes
        task.spawn(function()
            task.wait(0.3) -- Fullscreen takes longer
            windowStateChanging = false
        end)
    end)
    local body = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1, -12, 1, -(46 + 12)), Position = UDim2.fromOffset(6, 46 + 6), ZIndex = z, Parent = root})
    local sidebar = Create("ScrollingFrame", {Name = "Sidebar", BackgroundColor3 = Theme.Panel, BorderSizePixel = 0, Size = UDim2.new(0, 100, 1, 0), ScrollBarThickness = 0, ScrollBarImageColor3 = Color3.fromRGB(0,0,0), ScrollBarImageTransparency = 1, CanvasSize = UDim2.fromOffset(0,0), AutomaticCanvasSize = Enum.AutomaticSize.Y, ScrollingDirection = Enum.ScrollingDirection.Y, ZIndex = z + 1, Parent = body}, {Create("UICorner", {CornerRadius = UDim.new(0, 4)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3}), Create("UIListLayout", {Padding = UDim.new(0, 6), SortOrder = Enum.SortOrder.LayoutOrder}), Create("UIPadding", {PaddingTop = UDim.new(0, 6), PaddingLeft = UDim.new(0, 6), PaddingRight = UDim.new(0, 6), PaddingBottom = UDim.new(0, 6)})})
    local content = Create("Frame", {Name = "Content", BackgroundColor3 = Theme.Panel, BorderSizePixel = 0, ClipsDescendants = true, Size = UDim2.new(1, -(100 + 6), 1, 0), Position = UDim2.new(0, 100 + 6, 0, 0), ZIndex = z, Parent = body}, {Create("UICorner", {CornerRadius = UDim.new(0, 4)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})})
    do
        -- Smooth, resilient dragging (supports mouse & touch) without stutter.
    local dragging = false
    local dragStart
    local frameStart
        local lastInput
        local RS = game:GetService("RunService")
        local function update()
            if not dragging or not lastInput then return end
            local curPos = (lastInput.UserInputType == Enum.UserInputType.Touch) and lastInput.Position or UserInputService:GetMouseLocation()
            local delta = curPos - dragStart
            root.Position = UDim2.new(frameStart.X.Scale, frameStart.X.Offset + delta.X, frameStart.Y.Scale, frameStart.Y.Offset + delta.Y)
        end
        header.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                lastInput = input
                dragStart = (input.UserInputType == Enum.UserInputType.Touch) and input.Position or UserInputService:GetMouseLocation()
                frameStart = root.Position
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)
        header.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                lastInput = input
            end
        end)
        UserInputService.InputChanged:Connect(function(input)
            if not dragging then return end
            if input == lastInput then
                update()
            end
        end)
        RS.RenderStepped:Connect(update)
        local resizingCount = 0
        local sizeLabel = Create("TextLabel", {BackgroundTransparency = 0.25, BackgroundColor3 = Theme.Bg, Size = UDim2.fromOffset(110, 20), AnchorPoint = Vector2.new(1,1), Position = UDim2.new(1, -8, 1, -8), Text = "", Font = Fonts.Medium, TextSize = 12, TextColor3 = Theme.Text, Visible = false, Parent = root}, {Create("UICorner", {CornerRadius = UDim.new(0, 4)}), Create("UIStroke", {Color = Theme.Accent, Thickness = 1, Transparency = 0.4})})
        
        -- Update the setResizeEnabled function to handle resize-specific cleanup
        local originalSetResizeEnabled = setResizeEnabled
        setResizeEnabled = function(enabled)
            originalSetResizeEnabled(enabled)
            if not enabled then
                -- Additional resize-specific cleanup
                resizingCount = 0
                sizeLabel.Visible = false
                -- Reset stroke to normal
                T(rootStroke, 0.15, {Thickness = 1, Transparency = 0.3}):Play()
            end
        end
        local function resizeStartEffect()
            T(rootStroke, 0.15, {Thickness = 2, Transparency = 0.15}):Play()
        end
        local function resizeEndEffect()
            local tw = T(rootStroke, 0.18, {Thickness = 3, Transparency = 0.05})
            tw:Play()
            tw.Completed:Connect(function()
                T(rootStroke, 0.25, {Thickness = 1, Transparency = 0.3}):Play()
            end)
        end
        local function updateSizeLabel()
            local sz = root.AbsoluteSize
            sizeLabel.Text = ("%d x %d"):format(sz.X, sz.Y)
        end
        local function addCornerGrip(mode, showVisual)
            local gp = {tl = Vector2.new(0,0), tr = Vector2.new(1,0), bl = Vector2.new(0,1), br = Vector2.new(1,1)}
            local ap = gp[mode] or gp.br
            local grip = Create("Frame", {Name = "Grip_"..mode, BackgroundTransparency = 1, Size = UDim2.fromOffset(26,26), Position = UDim2.new(ap.X, ap.X==1 and 0 or 0, ap.Y, ap.Y==1 and 0 or 0), AnchorPoint = ap, ZIndex = z + 3, Parent = root})
            table.insert(allGrips, grip) -- Store reference for management
            if showVisual then
                -- Clean resize grip with diagonal dot pattern
                local gripRoot = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(16,16), AnchorPoint = Vector2.new(1,1), Position = UDim2.new(1,-4,1,-4), ZIndex = z + 4, Parent = grip})
                
                -- Create a proper diagonal grip pattern using small squares
                local gripElements = {}
                local dotSize = 2
                local spacing = 4
                
                -- Create diagonal rows of dots pointing toward bottom-right corner
                local dotPositions = {
                    -- First diagonal line (1 dot) - closest to corner
                    {x = 12, y = 12},
                    -- Second diagonal line (2 dots)  
                    {x = 8, y = 12},
                    {x = 12, y = 8},
                    -- Third diagonal line (3 dots) - furthest from corner
                    {x = 4, y = 12},
                    {x = 8, y = 8}, 
                    {x = 12, y = 4}
                }
                
                for i, pos in ipairs(dotPositions) do
                    local dot = Create("Frame", {
                        BackgroundColor3 = Theme.Accent,
                        BackgroundTransparency = 0.4,
                        BorderSizePixel = 0,
                        Size = UDim2.fromOffset(dotSize, dotSize),
                        Position = UDim2.fromOffset(pos.x, pos.y),
                        ZIndex = z + 5 + i,
                        Parent = gripRoot
                    }, {
                        Create("UICorner", {CornerRadius = UDim.new(0, 1)}) -- Slightly rounded
                    })
                    
                    gripElements[#gripElements + 1] = {dot = dot, originalPos = pos}
                end
                
                -- Smooth hover effects
                local function hover(on)
                    for i, entry in ipairs(gripElements) do
                        local dot = entry.dot
                        
                        if on then
                            -- Make dots more visible and slightly bigger
                            T(dot, 0.15, {
                                BackgroundTransparency = 0.1,
                                Size = UDim2.fromOffset(dotSize + 1, dotSize + 1)
                            }):Play()
                        else
                            -- Return to normal
                            T(dot, 0.2, {
                                BackgroundTransparency = 0.4,
                                Size = UDim2.fromOffset(dotSize, dotSize)
                            }):Play()
                        end
                    end
                end
                
                grip.MouseEnter:Connect(function() hover(true) end)
                grip.MouseLeave:Connect(function() hover(false) end)
            end
            local resizing = false
            local startMouse, startAbsPos, startAbsSize, parentAbs
            local minW, minH = 520, 380
            grip.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    if fullscreen then return end -- Prevent resizing in fullscreen mode
                    resizing = true
                    resizingCount = resizingCount + 1
                    if resizingCount == 1 then resizeStartEffect() end
                    sizeLabel.Visible = true
                    local pos = (input.UserInputType == Enum.UserInputType.Touch) and input.Position or UserInputService:GetMouseLocation()
                    startMouse = Vector2.new(pos.X, pos.Y)
                    startAbsPos = root.AbsolutePosition
                    startAbsSize = root.AbsoluteSize
                    parentAbs = root.Parent.AbsolutePosition
                    input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then resizing = false end end)
                end
            end)
            UserInputService.InputChanged:Connect(function(input)
                if not resizing then return end
                if input.UserInputType ~= Enum.UserInputType.MouseMovement and input.UserInputType ~= Enum.UserInputType.Touch then return end
                local pos = (input.UserInputType == Enum.UserInputType.Touch) and input.Position or UserInputService:GetMouseLocation()
                local dx = pos.X - startMouse.X
                local dy = pos.Y - startMouse.Y
                local left, top = startAbsPos.X, startAbsPos.Y
                local right, bottom = startAbsPos.X + startAbsSize.X, startAbsPos.Y + startAbsSize.Y
                if mode == "br" then right = right + dx bottom = bottom + dy end
                if mode == "bl" then left = left + dx bottom = bottom + dy end
                if mode == "tr" then right = right + dx top = top + dy end
                if mode == "tl" then left = left + dx top = top + dy end
                local newW = math.max(minW, right - left)
                local newH = math.max(minH, bottom - top)
                -- recompute left/top if min constraints clipped
                if mode == "bl" then left = right - newW end
                if mode == "tr" then top = bottom - newH end
                if mode == "tl" then left = right - newW top = bottom - newH end
                local centerX = left + newW/2
                local centerY = top + newH/2
                root.Size = UDim2.fromOffset(newW, newH)
                root.Position = UDim2.fromOffset(centerX - parentAbs.X, centerY - parentAbs.Y)
                updateSizeLabel()
            end)
            grip.InputEnded:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    if resizing then
                        resizing = false
                        resizingCount = math.max(0, resizingCount - 1)
                        if resizingCount == 0 then
                            resizeEndEffect()
                            task.delay(0.6, function() if resizingCount == 0 then sizeLabel.Visible = false end end)
                        end
                    end
                end
            end)
        end
        addCornerGrip("br", true)
        addCornerGrip("bl", false)
        addCornerGrip("tr", false)
        addCornerGrip("tl", false)
    end
    function Window:AddCategory(o)
        o = o or {}
        local name = tostring(o.Name or "Category")
        local icon = o.Icon
        local Category = { Name = name, _pages = {}, _selectedPage = nil }
        local btn = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = "", Size = UDim2.new(1, 0, 0, 38), ZIndex = z + 2, Parent = sidebar})
        local inner = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1, -2, 1, -2), Position = UDim2.fromOffset(1,1), Parent = btn})
        local iconImg
        -- unified layout: reserve 18px slot at left; text always starts after it
        if icon then
            if type(icon) == "number" or tostring(icon):match("^%d+$") then icon = "rbxassetid://" .. tostring(icon) end
            iconImg = Create("ImageLabel", {BackgroundTransparency = 1, Size = UDim2.fromOffset(16,16), Position = UDim2.fromOffset(4, 11), Image = icon, ImageColor3 = Theme.SubText, ZIndex = z + 3, Parent = inner})
        end
        local lbl = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1, -10, 1, 0), Position = UDim2.fromOffset( (icon and 24) or 24, 0), Text = name, Font = Fonts.Medium, TextSize = 14, TextColor3 = Theme.SubText, TextXAlignment = Enum.TextXAlignment.Left, TextTruncate = Enum.TextTruncate.AtEnd, ZIndex = z + 3, Parent = inner})
        -- Dynamically shrink category label text to fit sidebar
        do
            local ts = game:GetService("TextService")
            local function fitCategoryLabel()
                local leftPad = (icon and 24) or 24
                local avail = (inner.AbsoluteSize.X or 100) - leftPad - 10
                if not avail or avail <= 0 then return end
                local size = 14
                while size >= 12 do
                    local tb = ts:GetTextSize(name or "", size, Fonts.Medium, Vector2.new(1000, 38))
                    if tb.X <= avail then break end
                    size = size - 1
                end
                lbl.TextSize = size
            end
            task.defer(fitCategoryLabel)
            btn:GetPropertyChangedSignal("AbsoluteSize"):Connect(fitCategoryLabel)
        end
        local catInd = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0,0,0,2), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,0,1,0), Visible = false, ZIndex = z + 3, Parent = inner})
        btn.MouseEnter:Connect(function() if Window._selectedCategory ~= Category then T(lbl, 0.12, {TextColor3 = Theme.Text}):Play() if iconImg then T(iconImg, 0.12, {ImageColor3 = Theme.Text}):Play() end end end)
        btn.MouseLeave:Connect(function() if Window._selectedCategory ~= Category then T(lbl, 0.12, {TextColor3 = Theme.SubText}):Play() if iconImg then T(iconImg, 0.12, {ImageColor3 = Theme.SubText}):Play() end end end)
        local catContainer = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromScale(1,1), Visible = false, Parent = content})
    local subBar = Create("ScrollingFrame", {BackgroundTransparency = 1, BorderSizePixel = 0, Size = UDim2.new(1, -10, 0, 24), Position = UDim2.fromOffset(5, 5), ScrollBarThickness = 0, ScrollBarImageTransparency = 1, CanvasSize = UDim2.fromOffset(0,0), AutomaticCanvasSize = Enum.AutomaticSize.X, ScrollingDirection = Enum.ScrollingDirection.X, ZIndex = z + 1, Parent = catContainer}, {Create("UIListLayout", {FillDirection = Enum.FillDirection.Horizontal, Padding = UDim.new(0, 8), VerticalAlignment = Enum.VerticalAlignment.Center, HorizontalAlignment = Enum.HorizontalAlignment.Left})})
    -- search popup + button (only create once for the entire window)
    if not Window._globalSearchCreated then
        Window._globalSearchCreated = true
    Window._globalSearchPopup = Create("Frame", {BackgroundColor3 = Theme.Bg, BorderSizePixel = 0, Visible = false, Size = UDim2.fromOffset(210, 30), Position = UDim2.fromOffset(0,0), AnchorPoint = Vector2.new(0,0), ZIndex = z + 500, Parent = root}, {
            Create("UICorner", {CornerRadius = UDim.new(0,6)}),
            Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.4}),
            Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,8), PaddingTop = UDim.new(0,4), PaddingBottom = UDim.new(0,4)})
        })
        Window._globalSearchBox = Create("TextBox", {BackgroundTransparency = 1, ClearTextOnFocus = false, Text = "", PlaceholderText = "Search...", PlaceholderColor3 = Theme.SubText, TextColor3 = Theme.Text, Font = Fonts.Medium, TextSize = 13, Size = UDim2.new(1,0,1,0), TextXAlignment = Enum.TextXAlignment.Left, Parent = Window._globalSearchPopup})
        
        -- Global search state
        Window._filteredPage = nil
        Window._activeHighlightStroke = nil
        Window._activeStrokeOrigColor = nil
        Window._activeStrokeOrigThickness = nil
        Window._activeStrokeOrigTrans = nil
        
        function Window:RestoreColumns()
            if self._filteredPage and self._filteredPage._columnsFrames then
                for _, cfr in ipairs(self._filteredPage._columnsFrames) do cfr.Visible = true end
            end
            self._filteredPage = nil
            if self._activeHighlightStroke and self._activeHighlightStroke.Parent then
                self._activeHighlightStroke.Color = self._activeStrokeOrigColor or self._activeHighlightStroke.Color
                self._activeHighlightStroke.Thickness = self._activeStrokeOrigThickness or 1
                self._activeHighlightStroke.Transparency = self._activeStrokeOrigTrans or self._activeHighlightStroke.Transparency
            end
            self._activeHighlightStroke = nil
        end
        
        function Window:ToggleSearch(show)
            -- Prevent search from toggling during window state changes
            if windowStateChanging then return end
            
            show = (show == nil) and (not self._globalSearchPopup.Visible) or show
            if show then
                -- Prevent immediate reopen if we just closed from the same button
                if self._searchForceClosedUntil and os.clock() < (self._searchForceClosedUntil or 0) then
                    if self._currentSearchBtn and self._searchForceClosedSource and self._currentSearchBtn == self._searchForceClosedSource then
                        return
                    end
                end
                -- If already open with same owner, just reposition and return
                if self._globalSearchPopup.Visible and self._searchOwner and self._searchOwner == self._currentSearchBtn then
                    if self._currentSearchBtn and self._currentSearchBtn.Parent then
                        local btnAbs = self._currentSearchBtn.AbsolutePosition
                        local rootAbs = root.AbsolutePosition
                        local btnSize = self._currentSearchBtn.AbsoluteSize
                        local popupW = 210
                        local px = btnAbs.X - rootAbs.X
                        local maxX = root.AbsoluteSize.X - popupW - 4
                        if px < 4 then px = 4 elseif px > maxX then px = maxX end
                        local py = btnAbs.Y - rootAbs.Y + btnSize.Y + 6
                        self._globalSearchPopup.Position = UDim2.fromOffset(px, py)
                    end
                    return
                end
                self._globalSearchPopup.Visible = true
        -- Remember which button owns this open instance
        self._searchOwner = self._currentSearchBtn
                -- Clear any stale force-close guard now that we opened intentionally
                self._searchForceClosedUntil = nil
                self._searchForceClosedSource = nil
                -- Position popup relative to current search button
                if Window._currentSearchBtn then
                    local btnAbs = Window._currentSearchBtn.AbsolutePosition
                    local rootAbs = root.AbsolutePosition
                    local btnSize = Window._currentSearchBtn.AbsoluteSize
                    local popupW = 210
                    -- align popup's left edge with button's left edge
                    local px = btnAbs.X - rootAbs.X
                    local maxX = root.AbsoluteSize.X - popupW - 4
                    if px < 4 then px = 4 elseif px > maxX then px = maxX end
                    local py = btnAbs.Y - rootAbs.Y + btnSize.Y + 6
                    self._globalSearchPopup.Position = UDim2.fromOffset(px, py)
                end
                
                -- Animation
                local stroke = self._globalSearchPopup:FindFirstChild("Stroke")
                if stroke then stroke.Thickness = 2.2 stroke.Transparency = 0.75 end
                self._globalSearchPopup.BackgroundTransparency = 1
                self._globalSearchPopup.Size = UDim2.fromOffset(0,0)
                T(self._globalSearchPopup,0.22,{Size = UDim2.fromOffset(210,30)}):Play()
                T(self._globalSearchPopup,0.25,{BackgroundTransparency = 0}):Play()
                if stroke then T(stroke,0.35,{Thickness = 1, Transparency = 0.4}):Play() end
                task.defer(function() pcall(function() self._globalSearchBox:CaptureFocus() end) end)
            else
                self._globalSearchPopup.Visible = false
                self._globalSearchBox.Text = ""
                self:RestoreColumns()
                self._searchOwner = nil
                -- Set a short guard to avoid accidental reopen from the same button within the same click frame
                self._searchForceClosedUntil = os.clock() + 0.25
                self._searchForceClosedSource = self._currentSearchBtn or self._searchOwner
            end
        end
        
        function Window:ApplySearchFilter()
            local term = self._globalSearchBox.Text or ""
            if term == "" then
                self:RestoreColumns()
                return
            end
            local match = self:Search(term, true)
            if match and match.page and match.groupFrame then
                local wasSearchOpen = self._globalSearchPopup.Visible
                
                -- Switch to correct category if needed
                if self._selectedCategory ~= match.category then
                    match.category:Select()
                end
                if match.category._selectedPage ~= match.page then
                    match.page:Select()
                end
                
                -- If search was open and we switched categories, keep it open and reposition
                if wasSearchOpen then
                    self._globalSearchPopup.Visible = true
                    -- Ensure current button points to the matched category's search button
                    self._currentSearchBtn = match.category and match.category._searchBtn or self._currentSearchBtn
                    -- Reposition popup relative to current category's search button aligned to right edge
                    if self._currentSearchBtn and self._currentSearchBtn.Parent then
                        -- Update owner to the active category's button
                        self._searchOwner = self._currentSearchBtn
                        local btnAbs = self._currentSearchBtn.AbsolutePosition
                        local rootAbs = root.AbsolutePosition
                        local btnSize = self._currentSearchBtn.AbsoluteSize
                        local popupW = 210
                        -- align popup's left edge with button's left edge
                        local px = btnAbs.X - rootAbs.X
                        local maxX = root.AbsoluteSize.X - popupW - 4
                        if px < 4 then px = 4 elseif px > maxX then px = maxX end
                        local py = btnAbs.Y - rootAbs.Y + btnSize.Y + 6
                        self._globalSearchPopup.Position = UDim2.fromOffset(px, py)
                    end
                end
                
                -- Hide other columns in that page
                local page = match.page
                if page._columnsFrames then
                    self._filteredPage = page
                    for _, cfr in ipairs(page._columnsFrames) do
                        cfr.Visible = (cfr == match.groupFrame.Parent)
                    end
                end
                
                -- Highlight the found element
                local stroke = nil
                for _, child in ipairs(match.groupFrame:GetChildren()) do
                    if child:IsA("UIStroke") then stroke = child break end
                end
                if stroke then
                    if self._activeHighlightStroke ~= stroke then
                        if self._activeHighlightStroke and self._activeHighlightStroke.Parent then
                            self._activeHighlightStroke.Color = self._activeStrokeOrigColor or self._activeHighlightStroke.Color
                            self._activeHighlightStroke.Thickness = self._activeStrokeOrigThickness or 1
                            self._activeHighlightStroke.Transparency = self._activeStrokeOrigTrans or self._activeHighlightStroke.Transparency
                        end
                        self._activeHighlightStroke = stroke
                        self._activeStrokeOrigColor = stroke.Color
                        self._activeStrokeOrigThickness = stroke.Thickness
                        self._activeStrokeOrigTrans = stroke.Transparency
                    end
                    stroke.Color = Theme.Accent
                    stroke.Transparency = 0.15
                    T(stroke,0.35,{Thickness = 2}):Play()
                end
            end
        end
        
        -- Global search event handlers
        local lastChange = 0
        Window._globalSearchBox:GetPropertyChangedSignal("Text"):Connect(function()
            if not Window._globalSearchPopup.Visible then return end
            if Window._globalSearchBox.Text == "" then Window:RestoreColumns() return end
            lastChange = lastChange + 1
            local version = lastChange
            task.delay(0.15, function() if version == lastChange then Window:ApplySearchFilter() end end)
        end)
        
        Window._globalSearchBox.FocusLost:Connect(function(enter)
            if enter then Window:ApplySearchFilter() end
        end)
        
        Window._globalSearchBox.ReturnPressedFromOnScreenKeyboard:Connect(function() Window:ApplySearchFilter() end)
        
        UserInputService.InputBegan:Connect(function(inp)
            if Window._globalSearchPopup.Visible and (inp.KeyCode == Enum.KeyCode.Escape) then Window:ToggleSearch(false) end
        end)
        
        UserInputService.InputBegan:Connect(function(inp)
            if not Window._globalSearchPopup.Visible then return end
            -- Prevent search from closing during window state changes
            if windowStateChanging then return end
            if inp.UserInputType == Enum.UserInputType.MouseButton1 then
                local pos = UserInputService:GetMouseLocation()

                -- Check if click is inside search popup
                local searchAbs = Window._globalSearchPopup.AbsolutePosition
                local searchSz = Window._globalSearchPopup.AbsoluteSize
                local insideSearch = pos.X >= searchAbs.X and pos.X <= searchAbs.X+searchSz.X and pos.Y >= searchAbs.Y and pos.Y <= searchAbs.Y+searchSz.Y

                -- Check if click is inside ANY category's search button
                local insideAnyBtn = false
                for _, cat in ipairs(Window._categories or {}) do
                    local b = cat._searchBtn
                    if b and b.Parent then
                        local bAbs = b.AbsolutePosition
                        local bSz = b.AbsoluteSize
                        if pos.X >= bAbs.X and pos.X <= bAbs.X+bSz.X and pos.Y >= bAbs.Y and pos.Y <= bAbs.Y+bSz.Y then
                            insideAnyBtn = true
                            break
                        end
                    end
                end

                -- Close search if clicking anywhere except search popup or any search button
                if not insideSearch and not insideAnyBtn then
                    Window:ToggleSearch(false)
                end
            end
        end)
    end
    
    -- Create search button for this category
    local searchBtn = Create("TextButton", {BackgroundColor3 = Theme.Button, AutoButtonColor = false, Size = UDim2.fromOffset(32,22), Text = "🔍", Font = Fonts.Medium, TextSize = 14, TextColor3 = Theme.Text, ZIndex = z + 2, Parent = subBar}, {
        Create("UICorner", {CornerRadius = UDim.new(0,5)}),
        Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.45})
    })
    Category._searchBtn = searchBtn
    
    searchBtn.MouseEnter:Connect(function() T(searchBtn,0.12,{BackgroundColor3 = Theme.Hover}):Play() end)
    searchBtn.MouseLeave:Connect(function() T(searchBtn,0.12,{BackgroundColor3 = Theme.Button}):Play() end)
    searchBtn.MouseButton1Click:Connect(function()
        -- Prevent search from opening during window state changes
        if windowStateChanging then return end
        
        local isOpen = Window._globalSearchPopup and Window._globalSearchPopup.Visible
        local owner = Window._searchOwner
        if isOpen and owner == searchBtn then
            -- Same button while open -> close
            Window:ToggleSearch(false)
            return
        end
        if isOpen and owner ~= searchBtn then
            -- Different button while open -> keep open and reposition
            Window._currentSearchBtn = searchBtn
            Window:ToggleSearch(true)
            return
        end
        -- Was closed -> open under this button
        Window._currentSearchBtn = searchBtn
        Window:ToggleSearch(true)
    end)
    local pageArea = Create("Frame", {BackgroundTransparency = 1, ClipsDescendants = true, Size = UDim2.new(1, -10, 1, -(24 + 10 + 6)), Position = UDim2.fromOffset(5, 24 + 9), Parent = catContainer})
        function Category:Select()
            if Window._selectedCategory and Window._selectedCategory._label then
                T(Window._selectedCategory._label, 0.12, {TextColor3 = Theme.SubText}):Play()
                if Window._selectedCategory._indicator then Window._selectedCategory._indicator.Visible = false Window._selectedCategory._indicator.Size = UDim2.fromOffset(0,2) end
                if Window._selectedCategory._icon then T(Window._selectedCategory._icon, 0.12, {ImageColor3 = Theme.SubText}):Play() end
            end
            Window._selectedCategory = Category
            -- update current search button so global search can reposition correctly
            Window._currentSearchBtn = Category._searchBtn or Window._currentSearchBtn
            for _, f in ipairs(content:GetChildren()) do if f:IsA("Frame") then f.Visible = false end end
            catContainer.Visible = true
            T(lbl, 0.12, {TextColor3 = Theme.Text}):Play()
            if iconImg then T(iconImg, 0.12, {ImageColor3 = Theme.Text}):Play() end
            catInd.Visible = true
            -- underline now expands full inner width (minus padding) for aggressive look
            T(catInd, 0.2, {Size = UDim2.new(1, -8, 0, 2), Position = UDim2.new(0,4,1,0)}):Play()
            if not Category._selectedPage and #Category._pages > 0 then Category._pages[1]:Select() end
        end
        btn.MouseButton1Click:Connect(function() Category:Select() end)
    function Category:AddSection(p)
            p = p or {}
            local pname = tostring(p.Name or "Page")
            local Page = { Name = pname, _blocks = {}, _columns = Clamp(tonumber(p.Columns) or 2, 1, 3) }
            local tb = TextService:GetTextSize(pname, 12, Fonts.Medium, Vector2.new(1000, 22))
            -- Keep original size, but clamp max width reasonably and truncate to avoid spill
            local maxWidth = math.min(tb.X + 16, 140)
            local subBtn = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = pname, TextColor3 = Theme.SubText, Font = Fonts.Medium, TextSize = 12, Size = UDim2.fromOffset(maxWidth, 22), TextTruncate = Enum.TextTruncate.AtEnd, ZIndex = z + 2, Parent = subBar})
            local subInd = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0,0,0,2), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,4,1,0), Visible = false, ZIndex = z + 3, Parent = subBtn})
            subBtn.MouseEnter:Connect(function() if Category._selectedPage ~= Page then T(subBtn, 0.12, {TextColor3 = Theme.Text}):Play() end end)
            subBtn.MouseLeave:Connect(function() if Category._selectedPage ~= Page then T(subBtn, 0.12, {TextColor3 = Theme.SubText}):Play() end end)
            local pageFrame = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromScale(1,1), Visible = false, Parent = pageArea})
            local cols = {}
            do
            local pad = 4
                local cw = 1 / Page._columns
                for i=1, Page._columns do
                local col = Create("ScrollingFrame", {BackgroundTransparency = 1, ClipsDescendants = true, Size = UDim2.new(cw, -(pad * (Page._columns + 1)) / Page._columns, 1, -2), Position = UDim2.new((i-1)*cw, pad * i - (pad / Page._columns), 0, 1), ScrollBarThickness = 2, ScrollBarImageColor3 = Theme.Accent, ScrollBarImageTransparency = 0.2, BorderSizePixel = 0, CanvasSize = UDim2.fromOffset(0,0), AutomaticCanvasSize = Enum.AutomaticSize.Y, ScrollingDirection = Enum.ScrollingDirection.Y, Parent = pageFrame}, {Create("UIListLayout", {Padding = UDim.new(0, 3), HorizontalAlignment = Enum.HorizontalAlignment.Center, SortOrder = Enum.SortOrder.LayoutOrder}), Create("UIPadding", {PaddingLeft = UDim.new(0,2), PaddingRight = UDim.new(0,2), PaddingTop = UDim.new(0,2), PaddingBottom = UDim.new(0,3)})})
                    cols[i] = col
                end
            end
            Page._columnsFrames = cols
            function Page:Select()
                for _, pfr in ipairs(pageArea:GetChildren()) do if pfr:IsA("Frame") then pfr.Visible = false end end
                pageFrame.Visible = true
                Category._selectedPage = Page
                for _, b in ipairs(subBar:GetChildren()) do
                    if b:IsA("TextButton") then
                        T(b, 0.12, {TextColor3 = Theme.SubText}):Play()
                        local u = b:FindFirstChildOfClass("Frame") if u then u.Visible = false u.Size = UDim2.fromOffset(0,2) end
                    end
                end
                T(subBtn, 0.12, {TextColor3 = Theme.Text}):Play()
                subInd.Visible = true
                T(subInd, 0.2, {Size = UDim2.new(1, -8, 0, 2), Position = UDim2.new(0,4,1,0)}):Play()
            end
            subBtn.MouseButton1Click:Connect(function() Page:Select() end)
            -- Back-compat alias: Category:AddPage now Category:AddSection
            Category.AddPage = Category.AddSection
            function Page:AddPage(g)
                g = g or {}
                local gName = tostring(g.Name or "Block")
                local desc = g.Description
                local side = Clamp(tonumber(g.Side) or 1, 1, Page._columns)
                local Group = { Name = gName, _controls = {} }
                local gFrame = Create("Frame", {BackgroundColor3 = Theme.Bg, ClipsDescendants = true, Size = UDim2.new(1, -4, 0, 58), AutomaticSize = Enum.AutomaticSize.Y, BorderSizePixel = 0, ZIndex = z + 1, Parent = cols[side]}, {
                    Create("UICorner", {CornerRadius = UDim.new(0, 4)}),
                    Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3}),
                    Create("UIPadding", {PaddingLeft = UDim.new(0,6), PaddingRight = UDim.new(0,6), PaddingTop = UDim.new(0,6), PaddingBottom = UDim.new(0,6)})
                })
                Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 18), Text = gName, Font = Fonts.Bold, TextSize = 14, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, ZIndex = z + 2, Parent = gFrame})
                local y = 22
                if desc and #desc > 0 then
                    -- Larger visible info badge with plain 'i' (reworked: anchor via scale so resizing window doesn't break alignment)
                    local infoBtn = Create("TextButton", {BackgroundTransparency = 1, Size = UDim2.fromOffset(18,18), Position = UDim2.new(1, -6, 0, 1), AnchorPoint = Vector2.new(1,0), Text = "i", TextColor3 = Theme.SubText, Font = Fonts.Bold, TextSize = 14, AutoButtonColor = false, ZIndex = z + 6, Parent = gFrame})
                    -- hover circle (separate so base stays transparent) follows same anchored position
                    local hoverCircle = Create("Frame", {BackgroundColor3 = Color3.fromRGB(40,42,41), BackgroundTransparency = 1, Size = infoBtn.Size, Position = infoBtn.Position, AnchorPoint = Vector2.new(1,0), ZIndex = z + 5, Parent = gFrame})
                    Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = hoverCircle})
                    Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = infoBtn})
                    local iStroke = Create("UIStroke", {Color = Theme.Stroke, Thickness = 1.8, Transparency = 0, Parent = hoverCircle})
                    -- hover: shift stroke color instead of hiding it
                    local function hover(on)
                        if on then
                            T(hoverCircle,0.16,{BackgroundTransparency = 0.15}):Play()
                            T(infoBtn,0.14,{TextColor3 = Theme.Text}):Play()
                            T(iStroke,0.18,{Color = Theme.Text}):Play()
                        else
                            if popup and popup.Visible then return end
                            T(hoverCircle,0.20,{BackgroundTransparency = 1}):Play()
                            T(infoBtn,0.18,{TextColor3 = Theme.SubText}):Play()
                            T(iStroke,0.22,{Color = Theme.Stroke}):Play()
                        end
                    end
                    infoBtn.MouseEnter:Connect(function() hover(true) end)
                    infoBtn.MouseLeave:Connect(function() hover(false) end)
                    -- no AbsoluteSize polling needed; anchored with scale to right edge
                    -- measure text for better width
                    local meas = TextService:GetTextSize(desc, 12, Fonts.Regular, Vector2.new(320, math.huge))
                    local baseW = math.clamp(meas.X + 30, 140, 340)
                    local popup = Create("Frame", {BackgroundColor3 = Color3.fromRGB(28,30,29), BorderSizePixel = 0, Visible = false, Size = UDim2.new(0, baseW, 0, 0), ZIndex = z + 500, Parent = gFrame}, {
                        Create("UICorner", {CornerRadius = UDim.new(0,100)}),
                        Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.4}),
                        Create("UIPadding", {PaddingLeft = UDim.new(0,10), PaddingRight = UDim.new(0,10), PaddingTop = UDim.new(0,6), PaddingBottom = UDim.new(0,6)})
                    })
                    local pText = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,0,0), TextWrapped = true, TextYAlignment = Enum.TextYAlignment.Top, Text = desc, Font = Fonts.Regular, TextSize = 12, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, ZIndex = z + 501, Parent = popup})
                    pText.AutomaticSize = Enum.AutomaticSize.Y
                    popup.AutomaticSize = Enum.AutomaticSize.Y
                    popup.ClipsDescendants = true
                    -- arrow (triangle) using rotated square trick
                    -- arrow removed for minimalist pill popup
                    -- layout popup on show
                    local function positionPopup()
                        local relX = infoBtn.AbsolutePosition.X - gFrame.AbsolutePosition.X
                        local desired = relX - popup.AbsoluteSize.X/2 + infoBtn.AbsoluteSize.X/2
                        desired = math.clamp(desired, 4, math.max(4, gFrame.AbsoluteSize.X - popup.AbsoluteSize.X - 4))
                        popup.Position = UDim2.fromOffset(desired, 20)
                    end
                    local showing = false
                    local function show()
                        if showing then return end
                        showing = true
                        popup.Visible = true
                        popup.Size = UDim2.new(0, baseW, 0, 0)
                        positionPopup()
                        T(popup,0.18,{Size = UDim2.new(0,baseW,0,pText.AbsoluteSize.Y + 12)}):Play()
                        T(infoBtn,0.15,{BackgroundColor3 = Color3.fromRGB(48,52,50)}):Play()
                        T(iStroke,0.15,{Transparency = 0.35}):Play()
                    end
                    local function hide()
                        if not showing then return end
                        showing = false
                        local tw = T(popup,0.15,{Size = UDim2.new(0,baseW,0,0)})
                        tw:Play()
                        tw.Completed:Connect(function()
                            if not showing then
                                popup.Visible = false
                                T(infoBtn,0.18,{BackgroundColor3 = Color3.fromRGB(36,38,37)}):Play()
                                T(iStroke,0.18,{Transparency = 0.55}):Play()
                            end
                        end)
                    end
                    infoBtn.MouseEnter:Connect(show)
                    infoBtn.MouseLeave:Connect(function()
                        -- hide only if cursor not over popup
                        local con; con = game:GetService("RunService").RenderStepped:Connect(function()
                            local pos = UserInputService:GetMouseLocation()
                            local abs = popup.AbsolutePosition
                            local sz = popup.AbsoluteSize
                            local inside = pos.X >= abs.X and pos.X <= abs.X+sz.X and pos.Y >= abs.Y and pos.Y <= abs.Y+sz.Y
                            local btnAbs = infoBtn.AbsolutePosition
                            local btnSz = infoBtn.AbsoluteSize
                            local insideBtn = pos.X >= btnAbs.X and pos.X <= btnAbs.X+btnSz.X and pos.Y >= btnAbs.Y and pos.Y <= btnAbs.Y+btnSz.Y
                            if not inside and not insideBtn then
                                hide(); con:Disconnect()
                            end
                        end)
                    end)
                    infoBtn.MouseButton1Click:Connect(function()
                        if showing then hide() else show() end
                    end)
                    -- add a small vertical gap so controls aren't cramped under the info badge
                    y = y + 8
                end
                local function nextY(h) local o=y; y=y+h+6; return o end
                -- search registration helper (captures Category/Page/Group)
                local function registerSearch(text, searchType)
                    if not text or text == "" then return end
                    Library._searchEntries[#Library._searchEntries+1] = {
                        textLower = string.lower(text), 
                        category = Category, 
                        page = Page, 
                        groupFrame = gFrame,
                        originalText = text,
                        searchType = searchType or "control"
                    }
                end
                
                -- Register group name, category name, and page name for search
                registerSearch(gName, "group")
                registerSearch(Category.Name, "category") 
                registerSearch(Page.Name, "page")
                -- Back-compat alias: Page:AddBlock now Page:AddPage
                Page.AddBlock = Page.AddPage
                if desc and desc ~= "" then
                    registerSearch(desc, "description")
                end
                -- Toggle
                function Group:AddToggle(o)
                    o = o or {}
                    local label = tostring(o.Name or "Toggle")
                    local default = (o.Default == true)
                    local cb = o.Callback
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,32), Position = UDim2.fromOffset(0,nextY(32)), Parent = gFrame})
                    local container = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = "", Size = UDim2.new(1,0,1,0), Parent = row})
                    local labelWidth = 0.44
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(labelWidth,-6,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = container})
                    local shell = Create("Frame", {BackgroundColor3 = Color3.fromRGB(50,50,50), Size = UDim2.fromOffset(40,18), AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1,0,0.5,0), Parent = container})
                    Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = shell})
                    local recess = Create("Frame", {BackgroundColor3 = Theme.Bg, Size = UDim2.fromOffset(36,14), Position = UDim2.fromOffset(2,2), Parent = shell})
                    Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = recess})
                    local accentFill = Create("Frame", {BackgroundColor3 = Theme.Accent, BackgroundTransparency = 1, Size = UDim2.fromScale(1,1), Parent = shell})
                    Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = accentFill})
                    local knob = Create("Frame", {BackgroundColor3 = Theme.Scrollbar, Size = UDim2.fromOffset(12,12), Position = UDim2.new(0,4,0.5,0), AnchorPoint = Vector2.new(0,0.5), Parent = shell})
                    Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = knob})
                    local Toggle = { id = id, _value = default, _signal = Signal() }
                    function Toggle:Get() return self._value end
                    function Toggle:Set(v, silent)
                        v = (v == true)
                        self._value = v
                        if v then
                            T(accentFill,0.25,{BackgroundTransparency = 0}):Play()
                            T(knob,0.25,{Position = UDim2.new(1,-16,0.5,0), BackgroundColor3 = Theme.Text}):Play()
                        else
                            T(accentFill,0.25,{BackgroundTransparency = 1}):Play()
                            T(knob,0.25,{Position = UDim2.new(0,4,0.5,0), BackgroundColor3 = Theme.Scrollbar}):Play()
                        end
                        if not silent then if type(cb)=="function" then pcall(cb,v) end Toggle._signal:Fire(v) end
                    end
                    function Toggle:OnChanged(fn) return self._signal:Connect(fn) end
                    container.MouseButton1Click:Connect(function() Toggle:Set(not Toggle._value) end)
                    container.MouseEnter:Connect(function() T(shell,0.15,{BackgroundColor3 = Color3.fromRGB(58,58,58)}):Play() end)
                    container.MouseLeave:Connect(function() T(shell,0.15,{BackgroundColor3 = Color3.fromRGB(50,50,50)}):Play() end)
                    Toggle:Set(default,true)
                    Library:_registerControl(Toggle)
                    table.insert(Group._controls, Toggle)
                    registerSearch(label)
                    return Toggle
                end
                -- Button
                function Group:AddButton(o)
                    o = o or {}
                    local label = tostring(o.Name or "Button")
                    local cb = o.Callback
                    local compact = o.Compact == true
                    local h = compact and 28 or 32
                    local row = Create("TextButton", {BackgroundColor3 = Theme.Button, AutoButtonColor = false, Size = UDim2.new(1,0,0,h), Position = UDim2.fromOffset(0,nextY(h)), Text = "", Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, Parent = gFrame}, {
                        Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                        Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.45}),
                        Create("UIPadding", {PaddingLeft = UDim.new(0,10), PaddingRight = UDim.new(0,10)})
                    })
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})
                    local bar = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0,0,0,2), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,0,1,0), BackgroundTransparency = 0.15, Parent = row})
                    local function hover(on)
                        if on then
                            T(row,0.11,{BackgroundColor3 = Theme.Hover}):Play()
                            T(row.Stroke,0.14,{Transparency = 0.25}):Play()
                        else
                            T(row,0.11,{BackgroundColor3 = Theme.Button}):Play()
                            T(row.Stroke,0.14,{Transparency = 0.45}):Play()
                        end
                    end
                    row.MouseEnter:Connect(function() hover(true) end)
                    row.MouseLeave:Connect(function() hover(false) end)
                    row.MouseButton1Click:Connect(function()
                        if type(cb)=="function" then pcall(cb) end
                        -- animate bar across then retract & hide
                        bar.BackgroundTransparency = 0.15
                        bar.Size = UDim2.new(0,0,0,2)
                        local tween1 = T(bar,0.18,{Size = UDim2.new(1,0,0,2)})
                        tween1:Play()
                        tween1.Completed:Connect(function()
                            local tween2 = T(bar,0.18,{Size = UDim2.new(0,0,0,2)})
                            tween2:Play()
                            tween2.Completed:Connect(function()
                                bar.BackgroundTransparency = 1
                            end)
                        end)
                    end)
                    local Button = { id = ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label) }
                    Library:_registerControl(Button)
                    table.insert(Group._controls, Button)
                    registerSearch(label)
                    return Button
                end
                -- Slider
                function Group:AddSlider(o)
                    o = o or {}
                    local label = tostring(o.Name or "Slider")
                    local min = tonumber(o.Min) or 0
                    local max = tonumber(o.Max) or 100
                    if max == min then max = min + 1 end
                    local default = tonumber(o.Default or min)
                    local step = tonumber(o.Step or 1)
                    local cb = o.Callback
                    local precise = o.Precise == true
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)
                    -- UI row (compressed height)
                    local rowHeight = 46
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,rowHeight), Position = UDim2.fromOffset(0,nextY(rowHeight)), Parent = gFrame})
                    -- Label anchored top-left
                    local labelText = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1, -80, 0, 18), Position = UDim2.new(0,0,0,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})
                    -- Value box floats to right of label
                    local valueBox = Create("TextBox", {BackgroundColor3 = Theme.Button, Text = tostring(default), Font = Fonts.Medium, TextSize = 12, TextColor3 = Theme.SubText, Size = UDim2.new(0,64,0,18), Position = UDim2.new(1,-66,0,0), AnchorPoint = Vector2.new(0,0), ClearTextOnFocus = false, TextXAlignment = Enum.TextXAlignment.Center, Parent = row})
                    Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = valueBox})
                    local vbStroke = Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.45, Parent = valueBox})
                    -- Bar spans almost entire width beneath
                    local bar = Create("Frame", {BackgroundColor3 = Color3.fromRGB(30,32,31), Size = UDim2.new(1,0,0,6), Position = UDim2.new(0,0,0,26), Parent = row}, {Create("UICorner", {CornerRadius = UDim.new(1,0)})})
                    local barStroke = Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.6, Parent = bar})
                    -- drag pulse effect frame (overlay)
                    local dragPulse = Create("Frame", {BackgroundColor3 = Theme.Accent, BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Parent = bar})
                    Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = dragPulse})
                    dragPulse.ZIndex = bar.ZIndex + 1
                    local fill = Create("Frame", {BackgroundColor3 = Theme.Accent, Size = UDim2.new(0,0,1,0), Parent = bar}, {Create("UICorner", {CornerRadius = UDim.new(1,0)})})
                    local gradient = Instance.new("UIGradient")
                    gradient.Color = ColorSequence.new({
                        ColorSequenceKeypoint.new(0, Theme.Accent),
                        ColorSequenceKeypoint.new(0.5, Theme.Accent2),
                        ColorSequenceKeypoint.new(1, Theme.Accent)
                    })
                    gradient.Rotation = 0
                    gradient.Parent = fill
                    -- animate gradient shift
                    task.spawn(function()
                        local t0 = tick()
                        while row.Parent do
                            local tNow = (tick() - t0) * 25
                            gradient.Offset = Vector2.new((tNow % 100)/100, 0)
                            task.wait(0.05)
                        end
                    end)
                    local knob = Create("Frame", {BackgroundColor3 = Theme.Text, Size = UDim2.fromOffset(14,14), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.new(0,0,0.5,0), Parent = bar}, {Create("UICorner", {CornerRadius = UDim.new(1,0)})})
                    local knobStroke = Create("UIStroke", {Color = Theme.Accent, Thickness = 2, Transparency = 0.2, Parent = knob})
                    local knobGlow = Create("ImageLabel", {BackgroundTransparency = 1, Image = "rbxassetid://4996891970", ImageColor3 = Theme.Accent, ImageTransparency = 0.9, Size = UDim2.fromOffset(28,28), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.new(0.5,0,0.5,0), Parent = knob})
                    -- sheen effect
                    local sheen = Create("Frame", {BackgroundColor3 = Color3.fromRGB(255,255,255), BackgroundTransparency = 0.85, Size = UDim2.new(0,0,1,0), Parent = fill})
                    Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = sheen})
                    -- tooltip
                    knobGlow.ZIndex = 9 knob.ZIndex = 9
                    -- min/max subtle labels
                    -- removed min/max labels per request
                    -- Hover effects
                    local function hover(on)
                        if on then
                            T(bar,0.16,{BackgroundColor3 = Color3.fromRGB(36,40,38)}):Play()
                            T(barStroke,0.18,{Transparency = 0.35}):Play()
                            T(knobGlow,0.2,{ImageTransparency = 0.75}):Play()
                            T(knob,0.18,{Size = UDim2.fromOffset(18,18)}):Play()
                        else
                            T(bar,0.20,{BackgroundColor3 = Color3.fromRGB(30,32,31)}):Play()
                            T(barStroke,0.20,{Transparency = 0.6}):Play()
                            T(knobGlow,0.25,{ImageTransparency = 0.9}):Play()
                            T(knob,0.20,{Size = UDim2.fromOffset(14,14)}):Play()
                        end
                    end
                    bar.MouseEnter:Connect(function() hover(true) end)
                    bar.MouseLeave:Connect(function() hover(false) end)
                    knob.MouseEnter:Connect(function() hover(true) end)
                    -- early declare interaction state so hover callbacks capture them
                    local dragging, fine, lastClick = false, false, 0
                    -- sink game input while dragging to avoid A/D or other keys affecting gameplay/camera
                    local dragSinkAction = sanitize(libraryName) .. "SliderDrag_" .. id
                    local function bindDragSink()
                        local keys = Enum.KeyCode:GetEnumItems()
                        ContextActionService:BindAction(dragSinkAction, function(_, state, input)
                            if not dragging then return Enum.ContextActionResult.Pass end
                            -- While dragging the slider, sink keyboard/gamepad inputs
                            return Enum.ContextActionResult.Sink
                        end, false, table.unpack(keys))
                    end
                    local function unbindDragSink()
                        pcall(function() ContextActionService:UnbindAction(dragSinkAction) end)
                    end
                    knob.MouseLeave:Connect(function() if not dragging then hover(false) end end)
                    valueBox.Focused:Connect(function() T(vbStroke,0.15,{Transparency = 0.25}):Play() end)
                    valueBox.FocusLost:Connect(function() T(vbStroke,0.18,{Transparency = 0.45}):Play() end)
                    local Slider = { id = id, _value = default }
                    function Slider:Get() return self._value end
                    local function formatValue(v)
                        if precise then
                            local s = string.format("%.3f", v)
                            s = s:gsub("0+$", "")
                            s = s:gsub("%.$", "")
                            return s
                        else
                            return tostring(math.floor(v + 0.5))
                        end
                    end
                    function Slider:Set(v, silent)
                        local num = tonumber(v)
                        if not num or num ~= num or num == math.huge or num == -math.huge then
                            return
                        end
                        -- Clamp and round appropriately
                        if precise then
                            if step and step > 0 then
                                num = Round(num, step)
                            end
                            num = Clamp(num, min, max)
                        else
                            num = Clamp(Round(num, step or 1), min, max)
                        end
                        self._value = num
                        local pct = (num - min) / (max - min)
                        fill.Size = UDim2.new(pct,0,1,0)
                        knob.Position = UDim2.new(pct,0,0.5,0)
                        valueBox.Text = formatValue(num)
                        if not silent and type(cb)=="function" then pcall(cb,num) end
                    end
                    -- dragging / fine control logic (state already declared above)
                    -- ctrl-held fine adjustment flag is 'fine'
                    -- double click reset support uses 'lastClick'
                    local function updateFromX(x)
                        local rel = (x - bar.AbsolutePosition.X)/math.max(1, bar.AbsoluteSize.X)
                        rel = math.clamp(rel,0,1)
                        local raw = min + rel * (max - min)
                        if not precise then
                            Slider:Set(raw)
                        else
                            Slider:Set(raw)
                        end
                    end
                    local function beginDrag(input)
                        dragging = true
                        bindDragSink()
                        -- start pulse
                        dragPulse.BackgroundTransparency = 0.9
                        dragPulse.Size = UDim2.new(1,0,1,0)
                        T(dragPulse,0.25,{BackgroundTransparency = 1}):Play()
                        local x = (input.UserInputType==Enum.UserInputType.Touch) and input.Position.X or UserInputService:GetMouseLocation().X
                        updateFromX(x)
                    end
                    bar.InputBegan:Connect(function(input)
                        if input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.Touch then
                            local now = tick()
                            if now - lastClick < 0.35 then
                                -- double click -> reset to default
                                Slider:Set(default)
                            else
                                beginDrag(input)
                            end
                            lastClick = now
                        end
                    end)
                    knob.InputBegan:Connect(function(input)
                        if input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.Touch then
                            beginDrag(input)
                        end
                    end)
                    UserInputService.InputChanged:Connect(function(input)
                        if dragging and (input.UserInputType==Enum.UserInputType.MouseMovement or input.UserInputType==Enum.UserInputType.Touch) then
                            local x = (input.UserInputType==Enum.UserInputType.Touch) and input.Position.X or UserInputService:GetMouseLocation().X
                            if fine then
                                -- apply smaller incremental move by biasing x slightly toward previous value position
                                updateFromX(x)
                            else
                                updateFromX(x)
                            end
                        end
                    end)
                    UserInputService.InputEnded:Connect(function(input)
                        if input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.Touch then
                            if dragging then
                                -- end pulse
                                T(dragPulse,0.18,{BackgroundTransparency = 1}):Play()
                                unbindDragSink()
                            end
                            dragging=false
                        end
                    end)
                    UserInputService.InputBegan:Connect(function(input)
                        if input.KeyCode == Enum.KeyCode.LeftControl or input.KeyCode == Enum.KeyCode.RightControl then fine = true end
                        if dragging then return end -- ignore arrow adjustments while dragging
                        if input.KeyCode == Enum.KeyCode.Left then
                            if fine then Slider:Set(Slider._value - (precise and (step*0.25) or step)) else Slider:Set(Slider._value - step) end
                        elseif input.KeyCode == Enum.KeyCode.Right then
                            if fine then Slider:Set(Slider._value + (precise and (step*0.25) or step)) else Slider:Set(Slider._value + step) end
                        end
                    end)
                    UserInputService.InputEnded:Connect(function(input)
                        if input.KeyCode == Enum.KeyCode.LeftControl or input.KeyCode == Enum.KeyCode.RightControl then fine = false end
                    end)
                    -- valueBox editing
                    valueBox.Focused:Connect(function()
                        valueBox.TextColor3 = Theme.Text
                    end)
                    valueBox.FocusLost:Connect(function(enter)
                        valueBox.TextColor3 = Theme.SubText
                        local num = tonumber(valueBox.Text)
                        if num then
                            Slider:Set(num)
                        else
                            valueBox.Text = formatValue(Slider._value)
                        end
                    end)
                    valueBox:GetPropertyChangedSignal("Text"):Connect(function()
                        if precise then return end
                        -- Limit to digits and optional leading minus
                        local t = valueBox.Text
                        -- Remove non-digits
                        t = t:gsub("[^%d%-]", "")
                        -- Keep only first minus sign at start
                        local neg = t:match("^%-") and "-" or ""
                        t = t:gsub("%-", "")
                        t = neg .. t
                        if t ~= valueBox.Text then valueBox.Text = t end
                    end)
                    -- init
                    Slider:Set(default,true)
                    -- continuous sheen sweep loop
                    task.spawn(function()
                        while row.Parent do
                            sheen.Size = UDim2.new(0,0,1,0)
                            sheen.BackgroundTransparency = 0.9
                            T(sheen,1.2,{Size = UDim2.new(1,0,1,0), BackgroundTransparency = 1}):Play()
                            task.wait(3.5)
                        end
                    end)
                    Library:_registerControl(Slider)
                    table.insert(Group._controls, Slider)
                    registerSearch(label)
                    return Slider
                end
                -- NewSlider(text, low, high, precise, callback, defaultValue, flag)
                function Group:NewSlider(text, low, high, precise, callback, defaultValue, flag)
                    return Group:AddSlider({
                        Name = text,
                        Min = low,
                        Max = high,
                        Precise = precise,
                        Callback = callback,
                        Default = defaultValue,
                        Flag = flag,
                        Step = precise and ( (high - low) / 300 ) or 1,
                    })
                end
                -- Dropdown (new design v2)
                function Group:AddDropdown(...)
                    -- Accept both table-based and positional API:
                    -- AddDropdown({ Name=label, Options=options, Default=default, Multi=isMulti, Callback=cb, Flag=flag, Search=true/false, Placeholder=.. })
                    -- AddDropdown(label, options, default, isMulti, cb, flag)
                    local argc = select("#", ...)
                    local _first = ...
                    local o
                    if argc == 1 and type(_first) == "table" then
                        o = _first or {}
                    else
                        local labelArg, optionsArg, defaultArg, isMultiArg, cbArg, flagArg = ...
                        o = { Name = labelArg, Options = optionsArg, Default = defaultArg, Multi = isMultiArg, Callback = cbArg, Flag = flagArg }
                    end
                    o = o or {}
                    local label = tostring(o.Name or "Dropdown")
                    local options = o.Options or {}
                    local default = o.Default
                    local cb = o.Callback
                    local isMulti = (o.Multi == true) or (o.IsMulti == true)
                    -- Back-compat: allow either Filter or Search to toggle
                    local enableSearch = (o.Search ~= false) and (o.Filter ~= false)
                    local placeholder = tostring(o.Placeholder or "Choose...")
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)

                    -- Row + label
                    local rowH = 28
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,rowH), Position = UDim2.fromOffset(0,nextY(rowH)), Parent = gFrame})
                    local labelWidth = 0.42
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(labelWidth,-6,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})

                    -- Trigger: compact solid
                    local trigger = Create("TextButton", {BackgroundColor3 = Theme.Button, AutoButtonColor = false, Text = "", Size = UDim2.new(1-labelWidth,-4,1,0), Position = UDim2.new(labelWidth,4,0,0), Parent = row}, {
                        Create("UICorner", {CornerRadius = UDim.new(0,5)}),
                        Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.45}),
                        Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,0)})
                    })
                    -- Always start with placeholder; defaults are applied via Set() after options initialize
                    local valueLbl = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,-18,1,0), Text = placeholder, Font = Fonts.Medium, TextSize = 12, TextXAlignment = Enum.TextXAlignment.Left, TextColor3 = Theme.SubText, Parent = trigger})
                    local caret = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.fromOffset(16,14), AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1,-2,0.5,0), Text = "▼", Font = Fonts.Bold, TextSize = 14, TextColor3 = Theme.SubText, Parent = trigger})
                    caret.ZIndex = (trigger.ZIndex or 1) + 1

                    -- Panel (root-parented), width follows trigger; horizontally clamped to root
                    local panel = Create("Frame", {BackgroundColor3 = Theme.Bg, BorderSizePixel = 0, Visible = false, Size = UDim2.fromOffset(0,0), ZIndex = z + 350, Parent = root}, {
                        Create("UICorner", {CornerRadius = UDim.new(0,6)}),
                        Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.35})
                    })
                    local shadow = Create("ImageLabel", {BackgroundTransparency = 1, Image = "rbxassetid://4996891970", ImageColor3 = Theme.Bg, ImageTransparency = 0.85, Size = UDim2.fromScale(1,1), ZIndex = panel.ZIndex - 1, Parent = panel})
                    shadow.ScaleType = Enum.ScaleType.Slice; shadow.SliceCenter = Rect.new(20,20,280,280)

                    -- Internals
                    local innerPad = 6
                    local searchBox, listFrame, header
                    local itemHeight = 22
                    local maxVisible = 7
                    local open = false
                    local anim = false
                    local conns = {}
                    local activeIndex = 1
                    local Dropdown = { id = id, _value = default, _values = {}, _options = {}, _filtered = {}, _itemMap = {}, _onOpen = nil, _onClose = nil, _multi = isMulti, _clickGate = false }
                    -- forward declaration for helper used by context menu below (assigned later)
                    local getMouseGuiPosition

                    -- Context menu state (for multi-select): right-click -> Select All / Unselect All
                    local ctxMenu, ctxOpen = nil, false
                    local ctxBlocker = nil
                    local ctxConns = {}
                    local function ctxDisconnectAll()
                        for i = #ctxConns, 1, -1 do
                            local c = ctxConns[i]
                            if c and c.Disconnect then pcall(function() c:Disconnect() end) end
                            ctxConns[i] = nil
                        end
                    end
                    local function closeCtxMenu()
                        if not ctxOpen then return end
                        ctxOpen = false
                        if ctxBlocker and ctxBlocker.Parent then ctxBlocker:Destroy() end
                        ctxBlocker = nil
                        if ctxMenu and ctxMenu.Parent then ctxMenu:Destroy() end
                        ctxMenu = nil
                        ctxDisconnectAll()
                        if Library and Library._openDropdownCtx == closeCtxMenu then
                            Library._openDropdownCtx = nil
                        end
                    end
                    local function openCtxMenu(input)
                        if not Dropdown._multi then return end
                        -- toggle if already open
                        if ctxOpen then closeCtxMenu(); return end
                        -- Close any other dropdown context menu globally
                        if Library and Library._openDropdownCtx and Library._openDropdownCtx ~= closeCtxMenu then
                            pcall(Library._openDropdownCtx)
                        end
                        ctxOpen = true
                        -- create a full-screen modal blocker to prevent hover/click on other UI and allow right-click-to-close
                        ctxBlocker = Create("TextButton", {AutoButtonColor = false, Modal = false, BackgroundTransparency = 1, Text = "", Size = UDim2.fromScale(1,1), Position = UDim2.fromOffset(0,0), ZIndex = 10999, Parent = RootGui})
                        table.insert(ctxConns, ctxBlocker.MouseButton1Click:Connect(function()
                            closeCtxMenu()
                        end))
                        table.insert(ctxConns, ctxBlocker.MouseButton2Click:Connect(function()
                            closeCtxMenu()
                        end))
                        table.insert(ctxConns, ctxBlocker.TouchTap:Connect(function()
                            closeCtxMenu()
                        end))
                        -- build menu (match library style: solid lib background, standard outline, simple items)
                        local textService = game:GetService("TextService")
                        local labelFont = Fonts.Medium
                        local labelSize = 12
                        local sidePad, vPad, gap, itemH = 10, 6, 2, 24
                        local function measure(text)
                            local sz = textService:GetTextSize(text or "", labelSize, labelFont, Vector2.new(1000, itemH))
                            return sz.X
                        end
                        local maxTextW = math.max(measure("Select All"), measure("Unselect All"))
                        local menuW = math.clamp(math.floor(maxTextW + (sidePad*2) + 8), 140, 220)
                        local finalH = vPad*2 + (itemH*2) + gap
                        ctxMenu = Create("Frame", {BackgroundColor3 = Theme.Bg, BackgroundTransparency = 0, BorderSizePixel = 0, Size = UDim2.fromOffset(menuW, 0), ZIndex = z + 360, ClipsDescendants = true, Parent = root}, {
                            Create("UICorner", {CornerRadius = UDim.new(0,6)}),
                            Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.40})
                        })
                        -- subtle outer shadow like other panels
                        local shadow2 = Create("ImageLabel", {BackgroundTransparency = 1, Image = "rbxassetid://4996891970", ImageColor3 = Theme.Bg, ImageTransparency = 0.92, Size = UDim2.fromScale(1,1), ZIndex = (ctxMenu.ZIndex or 1) - 1, Parent = ctxMenu})
                        shadow2.ScaleType = Enum.ScaleType.Slice; shadow2.SliceCenter = Rect.new(20,20,280,280)
                        -- content container
                        local content = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1, -(sidePad*2), 1, -(vPad*2)), Position = UDim2.fromOffset(sidePad, vPad), ZIndex = ctxMenu.ZIndex + 1, Parent = ctxMenu}, {
                            Create("UIListLayout", {Padding = UDim.new(0, gap), SortOrder = Enum.SortOrder.LayoutOrder})
                        })
                        local function makeItem(text, onClick)
                            local btn = Create("TextButton", {AutoButtonColor = false, BackgroundTransparency = 0, BackgroundColor3 = Theme.Bg, Size = UDim2.new(1, 0, 0, itemH), Text = "", ZIndex = content.ZIndex + 1, Parent = content}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                                Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,8)})
                            })
                            Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Position = UDim2.fromOffset(0,0), Text = text, Font = labelFont, TextSize = labelSize, TextXAlignment = Enum.TextXAlignment.Left, TextColor3 = Theme.Text, Parent = btn})
                            btn.MouseEnter:Connect(function()
                                T(btn,0.10,{BackgroundColor3 = Theme.Hover}):Play()
                            end)
                            btn.MouseLeave:Connect(function()
                                T(btn,0.10,{BackgroundColor3 = Theme.Bg}):Play()
                            end)
                            if btn.Activated then
                                table.insert(ctxConns, btn.Activated:Connect(function()
                                    closeCtxMenu()
                                    onClick()
                                end))
                            else
                                table.insert(ctxConns, btn.MouseButton1Click:Connect(function()
                                    closeCtxMenu()
                                    onClick()
                                end))
                            end
                            return btn
                        end
                        makeItem("Select All", function() 
                            closeCtxMenu()
                            task.defer(function()
                                Dropdown:SelectAll()
                            end)
                        end)
                        makeItem("Unselect All", function() 
                            closeCtxMenu()
                            task.defer(function()
                                Dropdown:UnselectAll()
                            end)
                        end)
                        -- position above the dropdown, aligned to right edge; flip below when needed
                        local tAbs = trigger.AbsolutePosition
                        local tSz = trigger.AbsoluteSize
                        local rootAbs = root.AbsolutePosition
                        local rootSz = root.AbsoluteSize
                        local menuH = finalH
                        local px = (tAbs.X - rootAbs.X) + tSz.X - menuW
                        local py = (tAbs.Y - rootAbs.Y) - menuH - 6
                        if px < 4 then px = 4 end
                        if px + menuW > rootSz.X - 4 then px = rootSz.X - menuW - 4 end
                        if py < 4 then py = (tAbs.Y - rootAbs.Y) + tSz.Y + 6 end
                        if py + menuH > rootSz.Y - 4 then py = rootSz.Y - menuH - 4 end
                        ctxMenu.Position = UDim2.fromOffset(px, py)
                        -- open animation
                        ctxMenu.Size = UDim2.fromOffset(menuW, 0)
                        local openTw = T(ctxMenu, 0.16, {Size = UDim2.fromOffset(menuW, finalH), BackgroundTransparency = 0})
                        openTw:Play()
                        -- outside click / esc to close
                        table.insert(ctxConns, UserInputService.InputBegan:Connect(function(inp)
                            if not ctxOpen or not ctxMenu or not ctxMenu.Parent then return end
                            if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.MouseButton2 or inp.UserInputType == Enum.UserInputType.Touch then
                                -- inline-adjusted mouse position (avoid dependency on helper creation order)
                                local m
                                if inp and (inp.UserInputType == Enum.UserInputType.Touch) then
                                    m = Vector2.new(inp.Position.X, inp.Position.Y)
                                else
                                    m = UserInputService:GetMouseLocation()
                                end
                                local ok, inset = pcall(function()
                                    return game:GetService("GuiService"):GetGuiInset()
                                end)
                                if ok and typeof(inset) == "Vector2" then
                                    m = Vector2.new(m.X, m.Y - inset.Y)
                                end
                                local p = ctxMenu.AbsolutePosition; local s = ctxMenu.AbsoluteSize
                                local inside = m.X >= p.X and m.X <= p.X+s.X and m.Y >= p.Y and m.Y <= p.Y+s.Y
                                if not inside then closeCtxMenu() end
                            elseif inp.KeyCode == Enum.KeyCode.Escape then
                                closeCtxMenu()
                            end
                        end))
                        -- also close context menu if trigger becomes hidden or removed
                        table.insert(ctxConns, trigger:GetPropertyChangedSignal("Visible"):Connect(function()
                            if ctxOpen and trigger.Visible == false then closeCtxMenu() end
                        end))
                        table.insert(ctxConns, trigger.AncestryChanged:Connect(function()
                            if ctxOpen and not trigger:IsDescendantOf(root) then closeCtxMenu() end
                        end))
                        if Library then Library._openDropdownCtx = closeCtxMenu end
                    end

                    local function refreshLabelFromSelection()
                        if Dropdown._multi then
                            local selectedTexts = {}
                            for _, opt in ipairs(Dropdown._options) do
                                if Dropdown._values[tostring(opt)] then table.insert(selectedTexts, tostring(opt)) end
                            end
                            local count = #selectedTexts
                            if count == 0 then
                                valueLbl.Text = placeholder; valueLbl.TextColor3 = Theme.SubText
                            else
                                if count <= 2 then
                                    valueLbl.Text = table.concat(selectedTexts, ", ")
                                else
                                    valueLbl.Text = ("%d selected"):format(count)
                                end
                                valueLbl.TextColor3 = Theme.Text
                            end
                        else
                            if Dropdown._value == nil then
                                valueLbl.Text = placeholder; valueLbl.TextColor3 = Theme.SubText
                            else
                                valueLbl.Text = tostring(Dropdown._value); valueLbl.TextColor3 = Theme.Text
                            end
                        end
                    end

                    local function disconnectAll()
                        for i = #conns, 1, -1 do
                            local c = conns[i]
                            if c and c.Disconnect then pcall(function() c:Disconnect() end) end
                            conns[i] = nil
                        end
                    end
                    local function source()
                        return Dropdown._filtered[1] and Dropdown._filtered or Dropdown._options
                    end
                    local function clamp(v, lo, hi) if v < lo then return lo elseif v > hi then return hi else return v end end
                    local function positionPanel(finalH)
                        local rootAbs = root.AbsolutePosition
                        local rootSz = root.AbsoluteSize
                        local tAbs = trigger.AbsolutePosition
                        local tSz = trigger.AbsoluteSize
                        local width = tSz.X
                        local px = tAbs.X - rootAbs.X
                        px = clamp(px, 0, math.max(0, rootSz.X - width))
                        local openBelowY = (tAbs.Y - rootAbs.Y) + tSz.Y + 2
                        -- Always open dropdown panels below the trigger (no flip), and clamp within root height
                        local py = openBelowY
                        if finalH then
                            py = math.clamp(py, 4, math.max(4, rootSz.Y - finalH - 4))
                        end
                        panel.Position = UDim2.fromOffset(px, py)
                        panel.Size = UDim2.fromOffset(width, finalH or 0)
                    end
                    local function buildPanel()
                        for _, c in ipairs(panel:GetChildren()) do
                            if c:IsA("ScrollingFrame") or c:IsA("TextBox") or c:IsA("TextLabel") then
                                c:Destroy()
                            end
                        end
                        local y = innerPad
                        if enableSearch then
                            -- external icon on the left of the search box
                            local searchY = y
                            Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.fromOffset(16,24), Position = UDim2.fromOffset(innerPad, searchY), Text = "🔎", Font = Fonts.Medium, TextSize = 12, TextColor3 = Theme.SubText, TextXAlignment = Enum.TextXAlignment.Center, Parent = panel})
                            searchBox = Create("TextBox", {BackgroundColor3 = Theme.Button, ClearTextOnFocus = false, Text = "", PlaceholderText = "Search...", PlaceholderColor3 = Theme.SubText, TextColor3 = Theme.Text, Font = Fonts.Medium, TextSize = 12, TextXAlignment = Enum.TextXAlignment.Center, Size = UDim2.new(1, -(innerPad*2 + 16 + 6), 0, 24), Position = UDim2.fromOffset(innerPad + 16 + 6, searchY), Parent = panel}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,5)}),
                                Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.4})
                            })
                            y = y + 24 + innerPad
                        end
                        listFrame = Create("ScrollingFrame", {BackgroundTransparency = 1, BorderSizePixel = 0, Position = UDim2.fromOffset(innerPad, y), Size = UDim2.new(1, -innerPad*2, 1, -y - innerPad), CanvasSize = UDim2.fromOffset(0,0), AutomaticCanvasSize = Enum.AutomaticSize.Y, ScrollingDirection = Enum.ScrollingDirection.Y, ScrollBarThickness = 2, ScrollBarImageColor3 = Theme.Accent, ZIndex = panel.ZIndex + 1, Parent = panel}, {
                            Create("UIListLayout", {Padding = UDim.new(0,4), SortOrder = Enum.SortOrder.LayoutOrder})
                        })
                    end
                    local function updateSelection()
                        if Dropdown._multi then
                            for key, ref in pairs(Dropdown._itemMap) do
                                if ref and ref.dot then ref.dot.Visible = (Dropdown._values[key] == true) end
                            end
                        else
                            local cur = tostring(Dropdown._value)
                            for key, ref in pairs(Dropdown._itemMap) do
                                if ref and ref.dot then ref.dot.Visible = (key == cur) end
                            end
                        end
                    end
                    local function ensureVisible(index)
                        local layout = listFrame:FindFirstChildOfClass("UIListLayout")
                        if not layout then return end
                        local children = listFrame:GetChildren()
                        local items = {}
                        for _, c in ipairs(children) do if c:IsA("TextButton") then table.insert(items, c) end end
                        local item = items[index]
                        if not item then return end
                        local top = item.AbsolutePosition.Y - listFrame.AbsolutePosition.Y
                        local bottom = top + item.AbsoluteSize.Y
                        local viewTop = listFrame.CanvasPosition.Y
                        local viewBottom = viewTop + listFrame.AbsoluteWindowSize.Y
                        if top < viewTop then
                            listFrame.CanvasPosition = Vector2.new(0, top)
                        elseif bottom > viewBottom then
                            listFrame.CanvasPosition = Vector2.new(0, bottom - listFrame.AbsoluteWindowSize.Y)
                        end
                    end
                    local function renderItems()
                        for _, c in ipairs(listFrame:GetChildren()) do if c:IsA("TextButton") then c:Destroy() end end
                        Dropdown._itemMap = {}
                        local src = source()
                        for _, val in ipairs(src) do
                            local item = Create("TextButton", {AutoButtonColor = false, BackgroundColor3 = Theme.Button, Size = UDim2.new(1,0,0,itemHeight), Text = "", Parent = listFrame, ZIndex = panel.ZIndex + 2}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,5)}),
                                Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.45}),
                                Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,8)})
                            })
                            -- Radio marker (left): ring + inner dot
                            local radio = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(16,16), AnchorPoint = Vector2.new(0,0.5), Position = UDim2.new(0,0,0.5,0), Parent = item})
                            local ring = Create("Frame", {BackgroundColor3 = Theme.Bg, Size = UDim2.fromOffset(16,16), Position = UDim2.fromOffset(0,0), Parent = radio})
                            Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = ring})
                            Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.45, Parent = ring})
                            local dot = Create("Frame", {BackgroundColor3 = Theme.Accent, Size = UDim2.fromOffset(8,8), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.new(0.5,0,0.5,0), Parent = ring})
                            Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = dot})
                            dot.Visible = (Dropdown._multi and Dropdown._values[tostring(val)] == true) or (tostring(Dropdown._value) == tostring(val))
                            local text = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,-24,1,0), Position = UDim2.fromOffset(22,0), Text = tostring(val), Font = Fonts.Medium, TextSize = 12, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = item})
                            item.MouseEnter:Connect(function()
                                T(item,0.12,{BackgroundColor3 = Theme.Hover}):Play()
                                local stroke = item:FindFirstChild("Stroke")
                                if stroke then T(stroke,0.12,{Transparency = 0.35}):Play() end
                            end)
                            item.MouseLeave:Connect(function()
                                T(item,0.12,{BackgroundColor3 = Theme.Button}):Play()
                                local stroke = item:FindFirstChild("Stroke")
                                if stroke then T(stroke,0.12,{Transparency = 0.45}):Play() end
                            end)
                            local function selectUI()
                                if Dropdown._multi then
                                    if Dropdown._clickGate then return end
                                    Dropdown._clickGate = true
                                    Dropdown:Set(val)
                                    task.delay(0.08, function()
                                        Dropdown._clickGate = false
                                    end)
                                else
                                    Dropdown:Set(val)
                                end
                            end
                            -- Use overlay only for click handling to avoid duplicate Down/Click toggles
                            -- Topmost invisible click-catcher to prevent visual children from blocking selection
                            local hit = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = "", Size = UDim2.new(1,0,1,0), Position = UDim2.fromOffset(0,0), Parent = item})
                            hit.ZIndex = (item.ZIndex or 1) + 100
                            if hit.Activated then
                                hit.Activated:Connect(selectUI)
                            else
                                -- Fallback for environments without Activated
                                hit.MouseButton1Click:Connect(selectUI)
                            end
                            local key = tostring(val)
                            Dropdown._itemMap[key] = {item = item, dot = dot}
                        end
                        if #src == 0 then
                            local empty = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,0,itemHeight), Text = "No matches", Font = Fonts.Medium, TextSize = 12, TextColor3 = Theme.SubText, TextXAlignment = Enum.TextXAlignment.Center, Parent = listFrame, ZIndex = panel.ZIndex + 2})
                        end
                        listFrame.CanvasPosition = Vector2.new(0,0)
                    end

                    -- Helper: mouse position adjusted for GUI inset (so we can do accurate bounds checks)
                    getMouseGuiPosition = function(input)
                        local pos
                        if input and (input.UserInputType == Enum.UserInputType.Touch) then
                            pos = Vector2.new(input.Position.X, input.Position.Y)
                        else
                            pos = UserInputService:GetMouseLocation()
                        end
                        -- Subtract top GUI inset so coordinates match AbsolutePosition space
                        local ok, inset = pcall(function()
                            return game:GetService("GuiService"):GetGuiInset()
                        end)
                        if ok and typeof(inset) == "Vector2" then
                            return Vector2.new(pos.X, pos.Y - inset.Y)
                        end
                        return pos
                    end

                    local function openPanel()
                        if open or anim then return end
                        anim = true; open = true
                        T(trigger,0.12,{BackgroundColor3 = Theme.Hover}):Play()
                        local tStroke = trigger:FindFirstChild("Stroke")
                        if tStroke then T(tStroke,0.12,{Transparency = 0.35}):Play() end
                        T(caret,0.16,{TextColor3 = Theme.Text}):Play(); caret.Text = "▲"

                        closeCtxMenu() -- hide context menu if open
                        buildPanel(); Dropdown._filtered = {}; renderItems();
                        panel.Visible = true; panel.ClipsDescendants = true

                        local count = #source()
                        local searchH = enableSearch and (24 + innerPad) or 0
                        local listH = math.min(count, maxVisible) * (itemHeight + 4)
                        local targetH = math.max(searchH + listH + innerPad, (innerPad*2 + itemHeight))
                        positionPanel(targetH)
                        panel.Size = UDim2.fromOffset(panel.AbsoluteSize.X, 0)
                        local tw = T(panel,0.18,{Size = UDim2.fromOffset(panel.AbsoluteSize.X, targetH)})
                        tw:Play(); tw.Completed:Connect(function() anim = false if type(Dropdown._onOpen)=="function" then pcall(Dropdown._onOpen) end end)

                        if enableSearch and searchBox then
                            table.insert(conns, searchBox:GetPropertyChangedSignal("Text"):Connect(function()
                                local q = (searchBox.Text or ""):lower()
                                Dropdown._filtered = {}
                                if q ~= "" then for _, v in ipairs(Dropdown._options) do if tostring(v):lower():find(q,1,true) then table.insert(Dropdown._filtered, v) end end end
                                activeIndex = 1; renderItems(); ensureVisible(activeIndex)
                            end))
                        end

                        table.insert(conns, UserInputService.InputBegan:Connect(function(input)
                            if not panel.Visible or not open then return end
                            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                                local pos = getMouseGuiPosition(input)
                                local p = panel.AbsolutePosition; local ps = panel.AbsoluteSize
                                local insideP = pos.X >= p.X and pos.X <= p.X+ps.X and pos.Y >= p.Y and pos.Y <= p.Y+ps.Y
                                local b = trigger.AbsolutePosition; local bs = trigger.AbsoluteSize
                                local insideB = pos.X >= b.X and pos.X <= b.X+bs.X and pos.Y >= b.Y and pos.Y <= b.Y+bs.Y
                                local insideC = false
                                if ctxMenu and ctxMenu.Parent then
                                    local c = ctxMenu.AbsolutePosition; local cs = ctxMenu.AbsoluteSize
                                    insideC = pos.X >= c.X and pos.X <= c.X+cs.X and pos.Y >= c.Y and pos.Y <= c.Y+cs.Y
                                end
                                if not insideP and not insideB and not insideC then Dropdown:_closePanel() end
                            elseif input.KeyCode == Enum.KeyCode.Escape then
                                Dropdown:_closePanel()
                            elseif input.KeyCode == Enum.KeyCode.Up then
                                activeIndex = math.max(1, activeIndex - 1); ensureVisible(activeIndex)
                            elseif input.KeyCode == Enum.KeyCode.Down then
                                local n = #source(); activeIndex = math.min(n, activeIndex + 1); ensureVisible(activeIndex)
                            elseif input.KeyCode == Enum.KeyCode.Home then
                                activeIndex = 1; ensureVisible(activeIndex)
                            elseif input.KeyCode == Enum.KeyCode.End then
                                activeIndex = #source(); ensureVisible(activeIndex)
                            elseif input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.KeypadEnter then
                                local src = source(); if src[activeIndex] ~= nil then Dropdown:Set(src[activeIndex]) end
                            end
                        end))

                        -- reposition while open if layout moves
                        table.insert(conns, trigger:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
                            if open then positionPanel(panel.AbsoluteSize.Y) end
                        end))
                        table.insert(conns, root:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                            if open then positionPanel(panel.AbsoluteSize.Y) end
                        end))
                        -- auto-close when trigger hides or is removed (category/section change)
                        table.insert(conns, trigger:GetPropertyChangedSignal("Visible"):Connect(function()
                            if open and trigger.Visible == false then Dropdown:_closePanel() end
                        end))
                        table.insert(conns, trigger.AncestryChanged:Connect(function()
                            if open and not trigger:IsDescendantOf(root) then Dropdown:_closePanel() end
                        end))
                    end
                    function Dropdown:_closePanel()
                        if not open or anim then return end
                        open = false; anim = true
                        closeCtxMenu()
                        T(trigger,0.12,{BackgroundColor3 = Theme.Button}):Play()
                        local tStroke = trigger:FindFirstChild("Stroke")
                        if tStroke then T(tStroke,0.12,{Transparency = 0.45}):Play() end
                        T(caret,0.16,{TextColor3 = Theme.SubText}):Play(); caret.Text = "▼"
                        local tw = T(panel,0.18,{Size = UDim2.fromOffset(panel.AbsoluteSize.X, 0)})
                        tw:Play(); tw.Completed:Connect(function() panel.Visible = false; anim = false if type(Dropdown._onClose)=="function" then pcall(Dropdown._onClose) end end)
                        -- Safety unlock in case tween completion is skipped by engine race
                        task.delay(0.35, function()
                            if panel and panel.Parent and panel.Visible and panel.AbsoluteSize.Y <= 1 then
                                panel.Visible = false
                            end
                            anim = false
                        end)
                        disconnectAll()
                    end

                    trigger.MouseEnter:Connect(function()
                        if not open and not anim then
                            T(trigger,0.12,{BackgroundColor3 = Theme.Hover}):Play()
                            local s = trigger:FindFirstChild("Stroke"); if s then T(s,0.12,{Transparency = 0.35}):Play() end
                        end
                    end)
                    trigger.MouseLeave:Connect(function()
                        if not open and not anim then
                            T(trigger,0.12,{BackgroundColor3 = Theme.Button}):Play()
                            local s = trigger:FindFirstChild("Stroke"); if s then T(s,0.12,{Transparency = 0.45}):Play() end
                        end
                    end)
                    trigger.MouseButton1Click:Connect(function() if open then Dropdown:_closePanel() else openPanel() end end)
                    -- Right-click context menu for multi-select
                    trigger.MouseButton2Click:Connect(function(input)
                        if Dropdown._multi then openCtxMenu(input) end
                    end)

                    -- Public controls
                    function Dropdown:Open()
                        openPanel()
                    end
                    function Dropdown:Close()
                        self:_closePanel()
                    end
                    function Dropdown:Toggle()
                        if open then self:_closePanel() else openPanel() end
                    end

                    function Dropdown:Get()
                        if self._multi then
                            local list = {}
                            for _, opt in ipairs(self._options) do if self._values[tostring(opt)] then table.insert(list, opt) end end
                            return list
                        end
                        return self._value
                    end
                    local function resolveOption(v)
                        if table.find(Dropdown._options, v) then return v end
                        local sv = tostring(v)
                        for _, opt in ipairs(Dropdown._options) do if tostring(opt) == sv then return opt end end
                        return nil
                    end
                    function Dropdown:Set(v, silent)
                        if self._multi then
                            if v == nil then
                                self._values = {}
                            else
                                if type(v) == "table" then
                                    local newSet = {}
                                    for _, item in ipairs(v) do
                                        local r = resolveOption(item)
                                        if r ~= nil then newSet[tostring(r)] = true end
                                    end
                                    self._values = newSet
                                else
                                    local resolved = resolveOption(v); if not self._options or not resolved then return end
                                    local key = tostring(resolved)
                                    if self._values[key] then self._values[key] = nil else self._values[key] = true end
                                end
                            end
                            updateSelection(); refreshLabelFromSelection()
                            -- Don't auto-close for multi-select
                            if not silent and type(cb)=="function" then pcall(cb, self:Get()) end
                            return
                        end
                        -- single-select behavior
                        if v == nil then
                            self._value = nil
                            refreshLabelFromSelection()
                            if open then Dropdown:_closePanel() end
                            return
                        end
                        local resolved = resolveOption(v); if not self._options or not resolved then return end
                        self._value = resolved
                        refreshLabelFromSelection(); updateSelection();
                        if open then Dropdown:_closePanel() end
                        if not silent and type(cb)=="function" then pcall(cb, resolved) end
                    end
                    function Dropdown:SetOptions(nl)
                        self._options = {}
                        for _, val in ipairs(nl or {}) do table.insert(self._options, val) end
                        Dropdown._filtered = {}
                        if self._multi then
                            -- prune selections that no longer exist
                            local valid = {}
                            for _, opt in ipairs(self._options) do valid[tostring(opt)] = true end
                            for key, _ in pairs(self._values) do if not valid[key] then self._values[key] = nil end end
                        end
                        if panel.Visible then buildPanel(); renderItems(); updateSelection() end
                        refreshLabelFromSelection()
                    end
                    -- Public helpers for multi-select
                    function Dropdown:SelectAll(silent)
                        if not self._multi then return end
                        local newSet = {}
                        for _, opt in ipairs(self._options) do newSet[tostring(opt)] = true end
                        self._values = newSet
                        
                        -- Force UI updates
                        pcall(updateSelection)
                        pcall(refreshLabelFromSelection)
                        
                        -- If panel is visible, rebuild it to reflect changes
                        if panel and panel.Visible then
                            pcall(buildPanel)
                            pcall(renderItems)
                            pcall(updateSelection)
                        end
                        
                        if not silent and type(cb)=="function" then pcall(cb, self:Get()) end
                    end
                    function Dropdown:UnselectAll(silent)
                        if not self._multi then return end
                        self._values = {}
                        
                        -- Force UI updates
                        pcall(updateSelection)
                        pcall(refreshLabelFromSelection)
                        
                        -- If panel is visible, rebuild it to reflect changes
                        if panel and panel.Visible then
                            pcall(buildPanel)
                            pcall(renderItems)
                            pcall(updateSelection)
                        end
                        
                        if not silent and type(cb)=="function" then pcall(cb, self:Get()) end
                    end
                    function Dropdown:OnOpen(fn) self._onOpen = fn end
                    function Dropdown:OnClose(fn) self._onClose = fn end
                    function Dropdown:FocusSearch() if enableSearch and searchBox then pcall(function() searchBox:CaptureFocus() end) end end

                    Dropdown:SetOptions(options)
                    -- Initialize default(s)
                    if default ~= nil then
                        if isMulti then
                            if type(default) == "table" then Dropdown:Set(default, true) else Dropdown:Set({default}, true) end
                        else
                            Dropdown:Set(default, true)
                        end
                    end
                    refreshLabelFromSelection()
                    Library:_registerControl(Dropdown)
                    table.insert(Group._controls, Dropdown)
                    registerSearch(label)
                    return Dropdown
                end
                -- Textbox
                function Group:AddTextbox(o)
                    o = o or {}
                    local label = tostring(o.Name or "Text")
                    local placeholder = tostring(o.Placeholder or "")
                    local default = tostring(o.Default or "")
                    local cb = o.Callback
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,30), Position = UDim2.fromOffset(0,nextY(30)), Parent = gFrame})
                    -- Align label/input split with dropdown (label 42%, input 58%), and match right margin (-4/+4)
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(0.42,-6,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})
                    local box = Create("TextBox", {BackgroundColor3 = Theme.Button, Size = UDim2.new(0.58,-4,1,0), Position = UDim2.new(0.42,4,0,0), ClearTextOnFocus = false, PlaceholderText = placeholder, Text = default, Font = Fonts.Regular, TextSize = 13, TextColor3 = Theme.Text, PlaceholderColor3 = Theme.SubText, Parent = row}, {
                        Create("UICorner", {CornerRadius = UDim.new(0,3)}),
                        Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.55}),
                        Create("UIPadding", {PaddingLeft = UDim.new(0,6), PaddingRight = UDim.new(0,6)})
                    })
                    local focusBar = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0,0,0,2), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,0,1,0), BackgroundTransparency = 1, Parent = box})
                    local Textbox = { id = id, _value = default }
                    function Textbox:Get() return box and box.Text or self._value end
                    function Textbox:Set(v, silent) v = tostring(v or "") self._value = v box.Text = v if not silent and type(cb)=="function" then pcall(cb,v) end end
                    -- One-time clear on first focus if it's still showing the default text
                    local _clearedOnce = false
                    box.Focused:Connect(function()
                        if not _clearedOnce and (box.Text == tostring(default or "")) then
                            box.Text = ""
                            _clearedOnce = true
                        end
                        focusBar.BackgroundTransparency = 0
                        focusBar.Size = UDim2.new(0,0,0,2)
                        T(focusBar,0.20,{Size = UDim2.new(1,0,0,2)}):Play()
                        T(box.Stroke,0.15,{Transparency = 0.35}):Play()
                    end)
                    box.FocusLost:Connect(function()
                        Textbox:Set(box.Text)
                        local tw1 = T(focusBar,0.18,{Size = UDim2.new(0,0,0,2)})
                        tw1:Play()
                        tw1.Completed:Connect(function() focusBar.BackgroundTransparency = 1 end)
                        T(box.Stroke,0.18,{Transparency = 0.55}):Play()
                    end)
                    Library:_registerControl(Textbox)
                    table.insert(Group._controls, Textbox)
                    registerSearch(label)
                    return Textbox
                end
                -- Paragraph (note text / read-only, flag updatable)
                function Group:AddParagraph(o)
                    o = o or {}
                    local label = tostring(o.Name or "Paragraph")
                    local text = tostring(o.Text or o.Value or "")
                    local cb = o.Callback -- optional: fire when text changes via Set
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)
                    local h = tonumber(o.Height) or 48
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,h), Position = UDim2.fromOffset(0,nextY(h)), Parent = gFrame})
                    local box = Create("Frame", {BackgroundColor3 = Theme.Button, Size = UDim2.new(1,0,1,0), Parent = row}, {
                        Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                        Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.45}),
                        Create("UIPadding", {PaddingLeft = UDim.new(0,10), PaddingRight = UDim.new(0,10), PaddingTop = UDim.new(0,8), PaddingBottom = UDim.new(0,8)})
                    })
                    local txt = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), TextWrapped = true, Text = text, Font = Fonts.Regular, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Top, Parent = box})
                    -- Auto-resize helpers: compute required height and reflow following controls
                    local function measureNeededHeight(str)
                        local availW = math.max(20, row.AbsoluteSize.X - 20) -- account for 10px left/right padding
                        local sz = TextService:GetTextSize(tostring(str or ""), 13, Fonts.Regular, Vector2.new(availW, math.huge))
                        local innerPadY = 8 + 8
                        local need = math.max(h, sz.Y + innerPadY)
                        return need
                    end
                    local function reflowToHeight(newH)
                        newH = math.floor(newH + 0.5)
                        local oldH = row.Size.Y.Offset
                        if newH == oldH then return end
                        local baseY = row.Position.Y.Offset
                        local delta = newH - oldH
                        row.Size = UDim2.new(row.Size.X.Scale, row.Size.X.Offset, 0, newH)
                        -- Shift subsequent siblings down/up by delta
                        for _, child in ipairs(gFrame:GetChildren()) do
                            if child ~= row and child:IsA("GuiObject") then
                                local pos = child.Position
                                if pos.Y.Scale == 0 and pos.X.Scale == 0 and pos.Y.Offset > baseY then
                                    child.Position = UDim2.new(pos.X.Scale, pos.X.Offset, pos.Y.Scale, pos.Y.Offset + delta)
                                end
                            end
                        end
                        -- Update running y so future nextY placements are correct
                        y = y + delta
                    end
                    local function resizeNow()
                        -- Defer if width is zero (not laid out yet)
                        if row.AbsoluteSize.X <= 0 then
                            task.defer(resizeNow)
                            return
                        end
                        local need = measureNeededHeight(txt.Text)
                        reflowToHeight(need)
                    end
                    -- hover feedback like other controls
                    box.MouseEnter:Connect(function()
                        T(box,0.12,{BackgroundColor3 = Theme.Hover}):Play()
                        local s = box:FindFirstChild("Stroke"); if s then T(s,0.12,{Transparency = 0.25}):Play() end
                    end)
                    box.MouseLeave:Connect(function()
                        T(box,0.12,{BackgroundColor3 = Theme.Button}):Play()
                        local s = box:FindFirstChild("Stroke"); if s then T(s,0.12,{Transparency = 0.45}):Play() end
                    end)
                    local Paragraph = { id = id, _value = text, _label = label, _row = row, _box = box, _text = txt }
                    function Paragraph:Get() return self._value end
                    function Paragraph:Set(v, silent)
                        v = tostring(v or "")
                        self._value = v
                        txt.Text = v
                        resizeNow()
                        if not silent and type(cb) == "function" then pcall(cb, v) end
                    end
                    -- react to width changes (window resize / column change)
                    row:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                        resizeNow()
                    end)
                    gFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                        resizeNow()
                    end)
                    -- initial size pass (after mount)
                    task.defer(resizeNow)
                    Library:_registerControl(Paragraph)
                    table.insert(Group._controls, Paragraph)
                    registerSearch(label)
                    return Paragraph
                end
                -- Keybind
                function Group:AddKeybind(o)
                    o = o or {}
                    local label = tostring(o.Name or "Keybind")
                    local default = o.Default
                    if typeof(default) ~= "EnumItem" and type(default) == "string" then
                        default = ParseKeyFromString(default) or default
                    end
                    local cb = o.Callback
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)
                    
                    -- Mouse button names for AddKeybind
                    local mouseButtonNames = {
                        [Enum.UserInputType.MouseButton1] = "Mouse1",
                        [Enum.UserInputType.MouseButton2] = "Mouse2"
                    }
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,0,0,30), Position = UDim2.fromOffset(0,nextY(30)), Parent = gFrame})
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(0.5,-8,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})
                    local initText
                    if default and typeof(default) == "EnumItem" then
                        initText = Library.FormatKeyName(default)
                    elseif type(default) == "string" then
                        initText = Library.FormatKeyName(default)
                    else
                        initText = "Press a key..."
                    end
                    local box = Create("TextButton", {BackgroundColor3 = Theme.Button, AutoButtonColor = false, Size = UDim2.new(0.5,-4,1,0), Position = UDim2.new(0.5,4,0,0), Text = initText, Font = Fonts.Regular, TextSize = 13, TextColor3 = Theme.SubText, Parent = row}, {Create("UICorner", {CornerRadius = UDim.new(0,4)}), Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})})
                    -- Focus line (like Textbox) shown during capture
                    local focusBar = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0,0,0,2), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,0,1,0), BackgroundTransparency = 1, Parent = box})
                    local stroke = box:FindFirstChild("Stroke")
                    local waiting = false
                    local actionName = sanitize(libraryName) .. "KeybindCapture_" .. id
                    

                    local function startVisual()
                        -- Show bottom accent line and slightly emphasize stroke; keep background unchanged
                        if focusBar then
                            focusBar.BackgroundTransparency = 0
                            focusBar.Size = UDim2.new(0,0,0,2)
                            T(focusBar,0.20,{Size = UDim2.new(1,0,0,2)}):Play()
                        end
                        if stroke then T(stroke,0.15,{Transparency = 0.18}):Play() end
                    end

                    local function stopVisual()
                        -- Hide bottom accent line and reset stroke emphasis
                        if focusBar then
                            local tw1 = T(focusBar,0.18,{Size = UDim2.new(0,0,0,2)})
                            tw1:Play()
                            tw1.Completed:Connect(function()
                                if focusBar.Parent then focusBar.BackgroundTransparency = 1 end
                            end)
                        end
                        if stroke then T(stroke,0.18,{Transparency = 0.3}):Play() end
                    end

                    local Keybind = { id = id, _value = default }
                    function Keybind:Get() return self._value end
                    function Keybind:Set(keycode, silent)
                        -- Allow string inputs by parsing to Enum
                        if type(keycode) == "string" then
                            local parsed = ParseKeyFromString(keycode)
                            keycode = parsed or keycode
                        end
                        self._value = keycode
                        -- Handle both KeyCode and UserInputType/string (mouse/buttons)
                        if keycode then
                            box.Text = Library.FormatKeyName(keycode)
                        else
                            box.Text = "None"
                        end
                        box.TextColor3 = keycode and Theme.Text or Theme.SubText
                        box.Font = Fonts.Regular
                        -- Auto-resize based on text content
                        local textService = game:GetService("TextService")
                        local textSize = textService:GetTextSize(box.Text, 13, Fonts.Regular, Vector2.new(math.huge, 30))
                        box.Size = UDim2.new(0.5, math.max(-4, textSize.X + 8 - (box.Parent.AbsoluteSize.X * 0.5)), 1, 0)
                        
                        -- Update keybind list tracking
                        if self._keybindId then
                            local keyName = keycode and (keycode.Name or mouseButtonNames[keycode]) or (type(keycode)=="string" and keycode or "None")
                            Library:_updateKeybind(self._keybindId, {
                                key = keyName
                            })
                        end
                        
                        if keycode and not silent and type(cb) == "function" then pcall(cb, keycode) end
                    end

                    local function unbindSink()
                        pcall(function() ContextActionService:UnbindAction(actionName) end)
                    end

                    local function bindSink()
                        local function handler(_, state, input)
                            if not waiting then return Enum.ContextActionResult.Pass end
                            if state ~= Enum.UserInputState.Begin then return Enum.ContextActionResult.Sink end
                            if input.UserInputType == Enum.UserInputType.Keyboard then
                                waiting = false
                                Keybind:Set(input.KeyCode)
                                stopVisual()
                                unbindSink()
                            elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
                                waiting = false
                                Keybind:Set(input.UserInputType)
                                stopVisual()
                                unbindSink()
                            elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
                                -- Allow MouseButton2 to be bound, but with slight delay to avoid context menu interference
                                task.wait(0.1)
                                if waiting then  -- Still waiting after delay, so it's a legitimate bind attempt
                                    waiting = false
                                    Keybind:Set(input.UserInputType)
                                    stopVisual()
                                    unbindSink()
                                end
                            end
                            return Enum.ContextActionResult.Sink
                        end
                        -- sink all keyboard keys while capturing
                        local keys = Enum.KeyCode:GetEnumItems()
                        ContextActionService:BindAction(actionName, handler, false, table.unpack(keys))
                    end

                    box.MouseButton1Click:Connect(function()
                        waiting = true
                        box.Text = "..."
                        box.Font = Fonts.Regular
                        box.TextColor3 = Theme.Text
                        startVisual()
                        bindSink()
                    end)

                    -- Fallback: still listen to InputBegan (in case CAS is unavailable)
                    UserInputService.InputBegan:Connect(function(input)
                        if waiting and input.UserInputType == Enum.UserInputType.Keyboard then
                            waiting = false
                            Keybind:Set(input.KeyCode)
                            stopVisual()
                            unbindSink()
                        elseif waiting and input.UserInputType == Enum.UserInputType.MouseButton1 then
                            waiting = false
                            Keybind:Set(input.UserInputType)
                            stopVisual()
                            unbindSink()
                        elseif waiting and input.UserInputType == Enum.UserInputType.MouseButton2 then
                            -- Handle MouseButton2 with delay to avoid context menu interference
                            task.wait(0.1)
                            if waiting then
                                waiting = false
                                Keybind:Set(input.UserInputType)
                                stopVisual()
                                unbindSink()
                            end
                        elseif waiting and input.KeyCode == Enum.KeyCode.Escape then
                            -- cancel capture with ESC
                            waiting = false
                            stopVisual()
                            unbindSink()
                            if Keybind._value then
                                box.Text = Library.FormatKeyName(Keybind._value)
                            else
                                box.Text = "None"
                            end
                            box.TextColor3 = Keybind._value and Theme.Text or Theme.SubText
                            box.Font = Fonts.Regular
                        end
                    end)

                    -- Add context menu for mode selection (similar to AddKeybindToggle but simpler)
                    local keybindMode = "Hold" -- Default mode for regular keybind
                    local keybindCtxMenu, keybindCtxOpen
                    local keybindCtxBlocker = nil
                    local keybindCtxConns = {}
                    local function keybindCtxDisconnectAll()
                        for i=#keybindCtxConns,1,-1 do keybindCtxConns[i]:Disconnect(); table.remove(keybindCtxConns,i) end
                    end
                    local function closeKeybindCtx()
                        if not keybindCtxOpen or not keybindCtxMenu then return end
                        keybindCtxOpen = false
                        keybindCtxDisconnectAll()
                        if keybindCtxBlocker and keybindCtxBlocker.Parent then pcall(function() keybindCtxBlocker:Destroy() end) end
                        keybindCtxBlocker = nil
                        pcall(function() if keybindCtxMenu then keybindCtxMenu:Destroy() end end)
                        keybindCtxMenu = nil
                        if Library._openKeybindCtxClose == closeKeybindCtx then Library._openKeybindCtxClose = nil end
                    end
                    box.MouseButton2Click:Connect(function()
                        if waiting then return end  -- Don't open context menu if waiting for keybind
                        if Library._openKeybindCtxClose and Library._openKeybindCtxClose ~= closeKeybindCtx then pcall(Library._openKeybindCtxClose) end
                        closeKeybindCtx()
                        if keybindCtxMenu then pcall(function() keybindCtxMenu:Destroy() end); keybindCtxMenu=nil end
                        
                        local menuZBase = 12000
                        keybindCtxBlocker = Create("TextButton", {AutoButtonColor = false, Modal = false, BackgroundTransparency = 1, Text = "", Size = UDim2.fromScale(1,1), Position = UDim2.fromOffset(0,0), ZIndex = menuZBase, Parent = RootGui})
                        table.insert(keybindCtxConns, keybindCtxBlocker.MouseButton1Click:Connect(function() closeKeybindCtx() end))
                        table.insert(keybindCtxConns, keybindCtxBlocker.MouseButton2Click:Connect(function() closeKeybindCtx() end))
                        table.insert(keybindCtxConns, keybindCtxBlocker.TouchTap:Connect(function() closeKeybindCtx() end))
                        
                        local textService = game:GetService("TextService")
                        local labelFont = Fonts.Medium
                        local labelSize = 11
                        local sidePad, vPad, gap, itemH = 10, 6, 2, 24
                        local function measure(text)
                            local sz = textService:GetTextSize(text or "", labelSize, labelFont, Vector2.new(1000, itemH))
                            return sz.X
                        end
                        -- Include keybind list toggle text in width calculation
                        local keybindListText1 = measure("Add To List")
                        local keybindListText2 = measure("Remove From List")
                        local maxTextW = math.max(
                            measure("Hold"), 
                            measure("Toggle"), 
                            measure("Always"),
                            keybindListText1,
                            keybindListText2
                        )
                        local menuW = math.clamp(math.floor(maxTextW + (sidePad*2) + 16), 120, 200)
                        
                        keybindCtxMenu = Create("Frame", {BackgroundColor3 = Theme.Bg, BackgroundTransparency = 0, BorderSizePixel = 0, Size = UDim2.fromOffset(menuW,0), ZIndex = menuZBase + 1, ClipsDescendants = true, Parent = RootGui}, {
                            Create("UICorner", {CornerRadius = UDim.new(0,6)}),
                            Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.40})
                        })
                        local shadow = Create("ImageLabel", {BackgroundTransparency = 1, Image = "rbxassetid://4996891970", ImageColor3 = Theme.Bg, ImageTransparency = 0.92, Size = UDim2.fromScale(1,1), ZIndex = (keybindCtxMenu.ZIndex or 1)-1, Parent = keybindCtxMenu})
                        shadow.ScaleType = Enum.ScaleType.Slice; shadow.SliceCenter = Rect.new(20,20,280,280)
                        
                        local content = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1, -(sidePad*2), 1, -(vPad*2)), Position = UDim2.fromOffset(sidePad, vPad), ZIndex = keybindCtxMenu.ZIndex + 1, Parent = keybindCtxMenu}, {
                            Create("UIListLayout", {Padding = UDim.new(0,gap), SortOrder = Enum.SortOrder.LayoutOrder})
                        })
                        
                        local function createModeItem(modeText, isSelected)
                            local btn = Create("TextButton", {AutoButtonColor = false, BackgroundTransparency = 0, BackgroundColor3 = Theme.Bg, Size = UDim2.new(1,0,0,itemH), Text = "", ZIndex = content.ZIndex + 1, Parent = content}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                                Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,8)})
                            })
                            local textLabel = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Position = UDim2.fromOffset(0,0), Text = modeText, Font = labelFont, TextSize = labelSize, TextXAlignment = Enum.TextXAlignment.Left, TextColor3 = Theme.Text, Parent = btn})
                            local underline = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0, isSelected and 1 or 0, 0, 1), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,0,1,-1), Parent = btn})
                            if isSelected then T(underline, 0.2, {Size = UDim2.new(0.8, 0, 0, 1)}):Play() end
                            
                            btn.MouseEnter:Connect(function() T(btn,0.10,{BackgroundColor3 = Theme.Hover}):Play() end)
                            btn.MouseLeave:Connect(function() T(btn,0.10,{BackgroundColor3 = Theme.Bg}):Play() end)
                            btn.MouseButton1Click:Connect(function() 
                                keybindMode = modeText
                                -- Apply mode to Keybind object and update list state
                                if Keybind and Keybind.SetMode then Keybind:SetMode(modeText, true) end
                                closeKeybindCtx() 
                            end)
                            return btn
                        end
                        
                        -- Add keybind list toggle option
                        local function createKeybindListToggle()
                            local isInList = Keybind._keybindId and Library._keybinds[Keybind._keybindId] and Library._keybinds[Keybind._keybindId].showInList
                            local toggleText = isInList and "Remove From List" or "Add To List"
                            
                            local btn = Create("TextButton", {AutoButtonColor = false, BackgroundTransparency = 0, BackgroundColor3 = Theme.Bg, Size = UDim2.new(1,0,0,itemH), Text = "", ZIndex = content.ZIndex + 1, Parent = content}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                                Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,8)})
                            })
                            local textLabel = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Position = UDim2.fromOffset(0,0), Text = toggleText, Font = labelFont, TextSize = labelSize, TextXAlignment = Enum.TextXAlignment.Left, TextColor3 = Theme.Text, Parent = btn})
                            
                            btn.MouseEnter:Connect(function() T(btn,0.10,{BackgroundColor3 = Theme.Hover}):Play() end)
                            btn.MouseLeave:Connect(function() T(btn,0.10,{BackgroundColor3 = Theme.Bg}):Play() end)
                            btn.MouseButton1Click:Connect(function() 
                                if Keybind._keybindId then
                                    Library:_toggleKeybindInList(Keybind._keybindId)
                                end
                                closeKeybindCtx() 
                            end)
                            return btn
                        end
                        
                        createKeybindListToggle()
                        
                        -- Add separator line
                        local separator = Create("Frame", {BackgroundColor3 = Theme.Stroke, BorderSizePixel = 0, Size = UDim2.new(1, 0, 0, 1), Parent = content})
                        
                        createModeItem("Hold", keybindMode == "Hold")
                        createModeItem("Toggle", keybindMode == "Toggle")
                        createModeItem("Always", keybindMode == "Always")
                        
                        local menuH = (itemH * 4) + (gap * 4) + (vPad * 2) + 1 -- +1 for separator
                        keybindCtxMenu.Size = UDim2.fromOffset(menuW, menuH)
                        -- Use colorpicker positioning logic
                        local btnAbs = box.AbsolutePosition
                        local btnSize = box.AbsoluteSize
                        local guiInset = game:GetService("GuiService"):GetGuiInset()
                        -- Position menu directly above the button, aligned to left edge
                        local px = btnAbs.X
                        local py = btnAbs.Y - menuH - 6 + guiInset.Y
                        keybindCtxMenu.Position = UDim2.fromOffset(px, py)
                        
                        Library._openKeybindCtxClose = closeKeybindCtx
                        keybindCtxOpen = true
                    end)

                    -- Add to keybind list tracking system
                    local function getDefaultKeyName(keycode)
                        if keycode and keycode.Name then
                            return keycode.Name
                        elseif keycode and mouseButtonNames[keycode] then
                            return mouseButtonNames[keycode]
                        elseif type(keycode) == "string" then
                            -- Normalize to display-friendly name
                            local parsed = ParseKeyFromString(keycode)
                            return (parsed and parsed.Name) or keycode
                        else
                            return "None"
                        end
                    end
                    
                    local keybindId = Library:_addKeybind(label, getDefaultKeyName(default), "Keybind", {
                        active = false,
                        showInList = true, -- Default: show in list; context starts as "Remove From List"
                        keybindObject = Keybind
                    })
                    Keybind._keybindId = keybindId
                    Keybind._isActive = false
                    Keybind._mode = keybindMode -- "Hold" | "Toggle" | "Always"
                    Keybind._toggleState = false -- only used in Toggle mode

                    function Keybind:GetMode()
                        return self._mode
                    end

                    function Keybind:SetMode(newMode, silent)
                        if newMode ~= "Hold" and newMode ~= "Toggle" and newMode ~= "Always" then return end
                        self._mode = newMode
                        -- Compute current active based on mode
                        local newActive
                        if newMode == "Always" then
                            newActive = true
                        elseif newMode == "Toggle" then
                            newActive = self._toggleState
                        else -- Hold
                            newActive = false
                        end
                        self._isActive = newActive and true or false
                        if self._keybindId then
                            Library:_updateKeybind(self._keybindId, { active = self._isActive })
                        end
                    end
                    
                    -- Track when keybind is active
                    local originalUserInputBegan = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                        if gameProcessed then return end
                        local matches = false
                        if Keybind._value then
                            if typeof(Keybind._value) == "EnumItem" then
                                if Keybind._value.EnumType == Enum.KeyCode then
                                    matches = input.KeyCode == Keybind._value
                                elseif Keybind._value.EnumType == Enum.UserInputType then
                                    matches = input.UserInputType == Keybind._value
                                end
                            end
                        end
                        if matches then
                            if Keybind._mode == "Toggle" then
                                Keybind._toggleState = not (Keybind._toggleState == true)
                                Keybind._isActive = Keybind._toggleState
                                Library:_updateKeybind(keybindId, {active = Keybind._isActive})
                            elseif Keybind._mode == "Always" then
                                Keybind._isActive = true
                                Library:_updateKeybind(keybindId, {active = true})
                            else -- Hold
                                Keybind._isActive = true
                                Library:_updateKeybind(keybindId, {active = true})
                            end
                        end
                    end)
                    
                    local originalUserInputEnded = UserInputService.InputEnded:Connect(function(input, gameProcessed)
                        local matches = false
                        if Keybind._value then
                            if typeof(Keybind._value) == "EnumItem" then
                                if Keybind._value.EnumType == Enum.KeyCode then
                                    matches = input.KeyCode == Keybind._value
                                elseif Keybind._value.EnumType == Enum.UserInputType then
                                    matches = input.UserInputType == Keybind._value
                                end
                            end
                        end
                        if matches then
                            if Keybind._mode == "Hold" then
                                Keybind._isActive = false
                                Library:_updateKeybind(keybindId, {active = false})
                            else
                                -- In Toggle / Always, do not change active on release
                            end
                        end
                    end)
                    
                    Library:_registerControl(Keybind)
                    table.insert(Group._controls, Keybind)
                    registerSearch(label)
                    return Keybind
                end
                -- Colorpicker - Clean Rewrite
                function Group:AddColorpicker(o)
                    o = o or {}
                    local label = tostring(o.Name or "Color")
                    local cb = o.Callback
                    local amount = math.max(1, tonumber(o.Amount) or 1)
                    -- Opt-in global sync across different colorpickers; default off to keep slots independent
                    local doSync = (o.Sync == true) or (o.SyncGlobally == true)
                    -- Always start with Rainbow off; per-slot toggle only
                    local startRainbow = false
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s/%s"):format(Window.Name, Category.Name, Page.Name, Group.Name, label)
                    -- helpers
                    local function clamp01(x) if x < 0 then return 0 elseif x > 1 then return 1 else return x end end
                    local function toRGB255(c)
                        return math.floor(c.R*255+0.5), math.floor(c.G*255+0.5), math.floor(c.B*255+0.5)
                    end
                    local function rgbToHex(r,g,b)
                        return string.format("#%02X%02X%02X", math.clamp(r,0,255), math.clamp(g,0,255), math.clamp(b,0,255))
                    end
                    local function hexToRGB(hex)
                        hex = tostring(hex or ""):gsub("^#","")
                        if #hex == 6 then
                            local r = tonumber(hex:sub(1,2),16)
                            local g = tonumber(hex:sub(3,4),16)
                            local b = tonumber(hex:sub(5,6),16)
                            if r and g and b then return r,g,b end
                        end
                        return nil
                    end
                    local function parseRGBText(t)
                        -- accept formats like "255,255,255" or "255, 255, 255"
                        local r,g,b = t:match("%s*(%d+)%s*,%s*(%d+)%s*,%s*(%d+)%s*")
                        if r and g and b then return tonumber(r), tonumber(g), tonumber(b) end
                        return nil
                    end

                    -- rainbow sync bus
                    Library._rainbowBus = Library._rainbowBus or { listeners = {}, conn = nil }
                    
                    -- Global sync system for RGB and Pulse modes across ALL colorpickers
                    Library._globalRGBSync = Library._globalRGBSync or { active = false, listeners = {} }
                    Library._globalPulseSync = Library._globalPulseSync or { active = false, listeners = {} }
                    
                    local function syncRGBColor(color, sourceId)
                        if not Library._globalRGBSync.active then return end
                        for id, listener in pairs(Library._globalRGBSync.listeners) do
                            if id ~= sourceId then
                                pcall(listener, color, sourceId)
                            end
                        end
                    end
                    
                    local function syncPulseColor(color, sourceId)
                        if not Library._globalPulseSync.active then return end
                        for id, listener in pairs(Library._globalPulseSync.listeners) do
                            if id ~= sourceId then
                                pcall(listener, color, sourceId)
                            end
                        end
                    end
                    local function rainbowStart()
                        if Library._rainbowBus.conn then return end
                        local RS = game:GetService("RunService")
                        local t0 = tick()
                        Library._rainbowBus.conn = RS.RenderStepped:Connect(function()
                            local t = (tick() - t0) * 0.08 -- speed
                            local h = t % 1
                            Library._rainbowBus.h = h -- expose current hue for offset calculations
                            for _, fn in ipairs(Library._rainbowBus.listeners) do
                                pcall(fn, h)
                            end
                        end)
                    end
                    local function rainbowAdd(fn)
                        table.insert(Library._rainbowBus.listeners, fn)
                        rainbowStart()
                        return fn
                    end
                    local function rainbowRemove(fn)
                        for i=#Library._rainbowBus.listeners,1,-1 do
                            if Library._rainbowBus.listeners[i] == fn then table.remove(Library._rainbowBus.listeners,i) end
                        end
                        if #Library._rainbowBus.listeners == 0 and Library._rainbowBus.conn then
                            Library._rainbowBus.conn:Disconnect(); Library._rainbowBus.conn = nil
                        end
                    end

                    -- Resolve defaults per slot
                    local defaults = {}
                    local function colorFromAny(v)
                        if typeof(v) == "Color3" then return v end
                        if type(v) == "table" and v.r and v.g and v.b then return Color3.fromRGB(v.r, v.g, v.b) end
                        if type(v) == "string" then
                            local r,g,b = parseRGBText(v)
                            if r then return Color3.fromRGB(r,g,b) end
                            local hr,hg,hb = hexToRGB(v)
                            if hr then return Color3.fromRGB(hr,hg,hb) end
                        end
                        return Theme.Accent
                    end
                    -- accept Default or Value as initial colors
                    local init = (o.Default ~= nil) and o.Default or o.Value
                    if type(init) == "table" and amount > 1 then
                        for i=1, amount do defaults[i] = colorFromAny(init[i]) end
                    else
                        local c = colorFromAny(init)
                        for i=1, amount do defaults[i] = c end
                    end

                    -- build row
                    local rowH = 30
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,rowH), Position = UDim2.fromOffset(0,nextY(rowH)), Parent = gFrame})
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(0.42,-6,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})
                    local holder = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(0.58,-4,1,0), Position = UDim2.new(0.42,4,0,0), Parent = row}, {
                        Create("UIPadding", {PaddingLeft = UDim.new(0,0), PaddingRight = UDim.new(0,0)})
                    })
                    local layout = Create("UIListLayout", {Parent = holder, FillDirection = Enum.FillDirection.Horizontal, Padding = UDim.new(0,6), HorizontalAlignment = Enum.HorizontalAlignment.Right, VerticalAlignment = Enum.VerticalAlignment.Center})

                    -- state per slot
                    local slots = {}
                    for i=1, amount do
                        local btn = Create("TextButton", {AutoButtonColor = false, BackgroundColor3 = Theme.Button, Size = UDim2.fromOffset(26,26), Text = "", Parent = holder}, {
                            Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                            Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.35})
                        })
                        local fill = Create("Frame", {BackgroundColor3 = defaults[i], Size = UDim2.new(1,-6,1,-6), Position = UDim2.fromOffset(3,3), Parent = btn}, {
                            Create("UICorner", {CornerRadius = UDim.new(0,3)})
                        })
                        btn.MouseEnter:Connect(function() T(btn,0.12,{BackgroundColor3 = Theme.Hover}):Play(); local s = btn:FindFirstChild("Stroke"); if s then T(s,0.12,{Transparency = 0.25}):Play() end end)
                        btn.MouseLeave:Connect(function() T(btn,0.12,{BackgroundColor3 = Theme.Button}):Play(); local s = btn:FindFirstChild("Stroke"); if s then T(s,0.12,{Transparency = 0.35}):Play() end end)
                        slots[i] = { btn = btn, fill = fill, color = defaults[i], hsv = { Color3.toHSV(defaults[i]) }, rainbow = startRainbow, rainbowHook = nil, pulse = false, pulseHook = nil, hueOffset = 0, pulseHueOffset = 0, panel = nil, panelOpen = false }
                    end

                    -- shared panel for all slots
                    local panel, open, anim = nil, false, false
                    local panelBlocker = nil
                    local activeIndex = 1
                    local openConns = {}
                    local function disconnectAll()
                        for i=#openConns,1,-1 do openConns[i]:Disconnect(); table.remove(openConns,i) end
                    end

                    -- Clipboard helpers (exploit env)
                    local function copyText(s)
                        if typeof(setclipboard) == "function" then pcall(setclipboard, s) end
                        Library._clipboardColor = s
                    end
                    local function pasteText()
                        if typeof(getclipboard) == "function" then local ok, v = pcall(getclipboard); if ok then return v end end
                        return Library._clipboardColor
                    end

                    -- context menu (right click)
                    local ctxMenu, ctxOpen
                    local ctxBlocker = nil
                    local ctxConns = {}
                    local function ctxDisconnectAll()
                        for i=#ctxConns,1,-1 do ctxConns[i]:Disconnect(); table.remove(ctxConns,i) end
                    end
                    local function closeCtx()
                        if not ctxOpen or not ctxMenu then return end
                        ctxOpen = false
                        ctxDisconnectAll()
                        if ctxBlocker and ctxBlocker.Parent then pcall(function() ctxBlocker:Destroy() end) end
                        ctxBlocker = nil
                        -- Destroy immediately to avoid stuck animation when spamming clicks
                        pcall(function() if ctxMenu then ctxMenu:Destroy() end end)
                        ctxMenu = nil
                        if Library._openColorCtxClose == closeCtx then Library._openColorCtxClose = nil end
                    end
                    local function openCtx(btnFor)
                        if Library._openColorCtxClose and Library._openColorCtxClose ~= closeCtx then pcall(Library._openColorCtxClose) end
                        closeCtx()
                        if ctxMenu then pcall(function() ctxMenu:Destroy() end); ctxMenu=nil end
                        -- Create modal blocker to capture outside clicks and block underlying UI across the whole screen
                        local menuZBase = 12000
                        ctxBlocker = Create("TextButton", {AutoButtonColor = false, Modal = false, BackgroundTransparency = 1, Text = "", Size = UDim2.fromScale(1,1), Position = UDim2.fromOffset(0,0), ZIndex = menuZBase, Parent = RootGui})
                        table.insert(ctxConns, ctxBlocker.MouseButton1Click:Connect(function() closeCtx() end))
                        table.insert(ctxConns, ctxBlocker.MouseButton2Click:Connect(function() closeCtx() end))
                        table.insert(ctxConns, ctxBlocker.TouchTap:Connect(function() closeCtx() end))
                        -- Match multi-dropdown menu visuals (padding, corner radius, outline, hover behavior)
                        local textService = game:GetService("TextService")
                        local labelFont = Fonts.Medium
                        local labelSize = 12
                        local sidePad, vPad, gap, itemH = 10, 6, 2, 24
                        local function measure(text)
                            local sz = textService:GetTextSize(text or "", labelSize, labelFont, Vector2.new(1000, itemH))
                            return sz.X
                        end
                        local maxTextW = math.max(measure("Copy Value"), measure("Paste Value"))
                        local menuW = math.clamp(math.floor(maxTextW + (sidePad*2) + 8), 140, 220)
                        ctxMenu = Create("Frame", {BackgroundColor3 = Theme.Bg, BackgroundTransparency = 0, BorderSizePixel = 0, Size = UDim2.fromOffset(menuW,0), ZIndex = menuZBase + 1, ClipsDescendants = true, Parent = RootGui}, {
                            Create("UICorner", {CornerRadius = UDim.new(0,6)}),
                            Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.40})
                        })
                        local shadow2 = Create("ImageLabel", {BackgroundTransparency = 1, Image = "rbxassetid://4996891970", ImageColor3 = Theme.Bg, ImageTransparency = 0.92, Size = UDim2.fromScale(1,1), ZIndex = (ctxMenu.ZIndex or 1)-1, Parent = ctxMenu})
                        shadow2.ScaleType = Enum.ScaleType.Slice; shadow2.SliceCenter = Rect.new(20,20,280,280)
                        local content = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1, -(sidePad*2), 1, -(vPad*2)), Position = UDim2.fromOffset(sidePad, vPad), ZIndex = ctxMenu.ZIndex + 1, Parent = ctxMenu}, {
                            Create("UIListLayout", {Padding = UDim.new(0,gap), SortOrder = Enum.SortOrder.LayoutOrder})
                        })
                        local function item(text, on)
                            local btn = Create("TextButton", {AutoButtonColor = false, BackgroundTransparency = 0, BackgroundColor3 = Theme.Bg, Size = UDim2.new(1,0,0,itemH), Text = "", ZIndex = content.ZIndex + 1, Parent = content}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                                Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,8)})
                            })
                            Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Position = UDim2.fromOffset(0,0), Text = text, Font = labelFont, TextSize = labelSize, TextXAlignment = Enum.TextXAlignment.Left, TextColor3 = Theme.Text, Parent = btn})
                            btn.MouseEnter:Connect(function() T(btn,0.10,{BackgroundColor3 = Theme.Hover}):Play() end)
                            btn.MouseLeave:Connect(function() T(btn,0.10,{BackgroundColor3 = Theme.Bg}):Play() end)
                            btn.MouseButton1Click:Connect(function() on(); closeCtx() end)
                            return btn
                        end
                        item("Copy Value", function()
                            local slot = slots[activeIndex]
                            local c = slot.color
                            local r,g,b = toRGB255(c)
                            -- Enhanced copy: include mode information with color
                            local modeInfo = ""
                            if slot.rainbow then modeInfo = "|RGB" end
                            if slot.pulse then modeInfo = "|PULSE" end
                            copyText(string.format("%d, %d, %d%s", r,g,b, modeInfo))
                        end)
                        item("Paste Value", function()
                            local txt = pasteText()
                            if not txt then return end
                            -- Check for mode information in pasted text
                            local colorPart, modePart = txt:match("^([^|]+)|(.+)$")
                            if not modePart then
                                colorPart = txt
                                modePart = ""
                            end
                            local r,g,b = parseRGBText(colorPart)
                            if not r then 
                                local hr,hg,hb = hexToRGB(colorPart)
                                if hr then r,g,b = hr,hg,hb end 
                            end
                            if r then
                                local c = Color3.fromRGB(r,g,b)
                                local h,s,v = Color3.toHSV(c)
                                slots[activeIndex].hsv = {h,s,v}
                                slots[activeIndex].color = c
                                slots[activeIndex].fill.BackgroundColor3 = c
                                
                                -- Restore mode if specified
                                if modePart and modePart ~= "" then
                                    -- Find the current colorpicker instance by ID
                                    local currentColorpicker = nil
                                    for _, control in pairs(Library._controls) do
                                        if control.id == id and control._enableRainbow then
                                            currentColorpicker = control
                                            break
                                        end
                                    end
                                    
                                    if currentColorpicker then
                                        if modePart == "RGB" then
                                            currentColorpicker._enableRainbow(activeIndex)
                                        elseif modePart == "PULSE" then
                                            currentColorpicker._enablePulse(activeIndex)
                                        end
                                    end
                                end
                                
                                -- Update visual elements if panel is open
                                if open and panel and panel.Visible then
                                    updateSVBackground(h)
                                    if svCursor and sv then svCursor.Position = UDim2.fromOffset(s*(sv.AbsoluteSize.X), (1-v)*(sv.AbsoluteSize.Y)) end
                                    if hueGrab and hueSlider then hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), h*(hueSlider.AbsoluteSize.Y)) end
                                    if rgbBox and not rgbBox:IsFocused() then rgbBox.Text = string.format("%d, %d, %d", r,g,b) end
                                    if hexBox and not hexBox:IsFocused() then hexBox.Text = rgbToHex(r,g,b) end
                                end
                                
                                if type(cb)=="function" then pcall(cb, c, activeIndex) end
                            end
                        end)
                        -- position near btnFor using same logic as colorpicker panel but above
                        local finalH = vPad*2 + (itemH*2) + gap
                        local btnAbs = btnFor.AbsolutePosition
                        local btnSize = btnFor.AbsoluteSize
                        -- Since RootGui has IgnoreGuiInset = true, we need to account for the top bar
                        local guiInset = game:GetService("GuiService"):GetGuiInset()
                        -- Position menu directly above the button, aligned to left edge
                        local px = btnAbs.X
                        local py = btnAbs.Y - finalH - 6 + guiInset.Y
                        ctxMenu.Position = UDim2.fromOffset(px, py)
                        ctxMenu.Size = UDim2.fromOffset(menuW,0)
                        local tw = T(ctxMenu,0.14,{Size = UDim2.fromOffset(menuW, finalH), BackgroundTransparency = 0})
                        tw:Play(); ctxOpen = true
                        -- No ESC handler; close via mouse/touch/blocker only
                        Library._openColorCtxClose = closeCtx
                        -- Swallow clicks on menu content so they don't bubble to blocker
                        table.insert(ctxConns, ctxMenu.InputBegan:Connect(function() end))
                    end

                    -- Build color panel (once)
                    local sv, svWhite, svBlack, svCursor
                    local hueSlider, hueGrab
                    local rgbBox, hexBox
                    local rainbowToggle -- simple small toggle
                    local function hsvToColor(hsv)
                        return Color3.fromHSV(clamp01(hsv[1] or 0), clamp01(hsv[2] or 0), clamp01(hsv[3] or 0))
                    end
                    local function updateSVBackground(h)
                        if sv then sv.BackgroundColor3 = Color3.fromHSV(h,1,1) end
                    end
                    local function applyColorFromHSV(index)
                        local slot = slots[index]
                        local hsv = slot.hsv
                        local c = hsvToColor(hsv)
                        slot.color = c
                        slot.fill.BackgroundColor3 = c
                        -- update inputs only if this slot is currently active in the panel
                        if open and activeIndex == index then
                            if rgbBox and not rgbBox:IsFocused() then local r,g,b = toRGB255(c); rgbBox.Text = string.format("%d, %d, %d", r,g,b) end
                            if hexBox and not hexBox:IsFocused() then local r,g,b = toRGB255(c); hexBox.Text = rgbToHex(r,g,b) end
                        end
                        if type(cb)=="function" then pcall(cb, c, index) end
                    end
                    local function setHSV(index, h,s,v)
                        local slot = slots[index]
                        if not slot then return end
                        
                        -- For manual control, don't interfere with effects - let them continue running
                        -- This allows effects to work alongside manual adjustments
                        
                        local H,S,V = slot.hsv[1], slot.hsv[2], slot.hsv[3]
                        if h~=nil then H=h end; if s~=nil then S=s end; if v~=nil then V=v end
                        slot.hsv = { clamp01(H), clamp01(S), clamp01(V) }
                        if slot.updateSVBackground then slot.updateSVBackground(H) end
                        applyColorFromHSV(index)

                    end
                    
                    -- Separate function for drag operations that doesn't permanently disable effects
                    local function setHSVDrag(index, h,s,v)
                        local slot = slots[index]
                        if not slot then return end
                        
                        local H,S,V = slot.hsv[1], slot.hsv[2], slot.hsv[3]
                        if h~=nil then H=h end; if s~=nil then S=s end; if v~=nil then V=v end
                        slot.hsv = { clamp01(H), clamp01(S), clamp01(V) }
                        if slot.updateSVBackground then slot.updateSVBackground(H) end
                        applyColorFromHSV(index)
                    end

                    -- helper: attach rainbow animation to a specific slot index, updating UI only if it's the active one
                    local function attachRainbow(i)
                        local slot = slots[i]
                        -- Seed offset from current hue vs global rainbow hue
                        if Library._rainbowBus and Library._rainbowBus.h then
                            local currentH = slot.hsv[1] or 0
                            slot.hueOffset = (currentH - Library._rainbowBus.h) % 1
                        end
                        return rainbowAdd(function(h)
                            -- For RGB mode, ensure good saturation and value for visible colors
                            local s = math.max(0.8, slot.hsv[2] or 1) -- Minimum 80% saturation
                            local v = math.max(0.7, slot.hsv[3] or 1) -- Minimum 70% value
                            local hh = (h + (slot.hueOffset or 0)) % 1
                            slot.hsv = {hh, s, v}
                            local c = hsvToColor(slot.hsv)
                            slot.color = c
                            slot.fill.BackgroundColor3 = c
                            
                            -- Sync to other RGB colorpickers globally
                            if slot._syncId then
                                syncRGBColor(c, slot._syncId)
                            end
                            
                            if open and activeIndex == i then
                                updateSVBackground(hh)
                                if hueSlider and hueGrab then hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), hh * hueSlider.AbsoluteSize.Y) end
                                applyColorFromHSV(i)
                            else
                                -- update color silently when not active
                                if type(cb) == "function" then pcall(cb, c, i) end
                            end
                        end)
                    end

                    -- Shared UI references (will be set when panel is created)
                    local cbMark, pulseMark
                    
                    -- Shared UI update functions (work with currently active panel)
                    local function updateSVBackground(h)
                        if sv then sv.BackgroundColor3 = Color3.fromHSV(h,1,1) end
                    end
                    
                    local function setCheckbox(on)
                        if cbMark then cbMark.Visible = on and true or false end
                    end
                    
                    local function setPulseCheckbox(on)
                        if pulseMark then pulseMark.Visible = on and true or false end
                    end
                    
                    -- Unified helpers for stable per-slot toggles
                    local function updateSlotUI(i)
                        local slot = slots[i]
                        if open and activeIndex == i then
                            setCheckbox(slot.rainbow or false)
                            setPulseCheckbox(slot.pulse or false)
                        end
                    end
                    local function disableRainbow(i)
                        local slot = slots[i]
                        slot.rainbow = false
                        slot._resumeRainbow = nil
                        if slot.rainbowHook then rainbowRemove(slot.rainbowHook); slot.rainbowHook = nil end
                        -- Properly cleanup global sync listeners
                        if slot._syncId then
                            Library._globalRGBSync.listeners[slot._syncId] = nil
                            slot._syncId = nil
                            -- Check if there are any active RGB listeners left
                            local hasActiveRGB = false
                            for _, listener in pairs(Library._globalRGBSync.listeners) do 
                                if listener then hasActiveRGB = true break end 
                            end
                            Library._globalRGBSync.active = hasActiveRGB
                        end
                        updateSlotUI(i)
                        -- refresh UI cursors to match HSV when open
                        if open and activeIndex == i then
                            local h,s,v = table.unpack(slot.hsv)
                            updateSVBackground(h)
                            if svCursor and sv then svCursor.Position = UDim2.fromOffset(s*(sv.AbsoluteSize.X), (1-v)*(sv.AbsoluteSize.Y)) end
                            if hueGrab and hueSlider then hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), h*(hueSlider.AbsoluteSize.Y)) end
                        end
                    end
                    local function enableRainbow(i)
                        local slot = slots[i]
                        -- turn off pulse for this slot
                        if slot.pulseHook then rainbowRemove(slot.pulseHook); slot.pulseHook = nil end
                        slot.pulse = false
                        slot._resumePulse = nil
                        -- if pulse sync was active, remove listener for this slot
                        if slot._pulseSyncId then
                            Library._globalPulseSync.listeners[slot._pulseSyncId] = nil
                            slot._pulseSyncId = nil
                            local hasActivePulse = false
                            for _, listener in pairs(Library._globalPulseSync.listeners) do 
                                if listener then hasActivePulse = true break end 
                            end
                            Library._globalPulseSync.active = hasActivePulse
                        end
                        -- Always set up global sync for ALL colorpickers
                        Library._globalRGBSync.active = true
                        local syncId = tostring(id .. "_" .. i .. "_" .. math.random(1000000, 9999999))
                        slot._syncId = syncId
                        -- Create proper sync listener
                        Library._globalRGBSync.listeners[syncId] = function(syncColor, sourceId)
                            if not slot.rainbow or sourceId == syncId then return end -- Don't sync to self
                            local h,s,v = Color3.toHSV(syncColor)
                            slot.hsv = {h,s,v}
                            if Library._rainbowBus and Library._rainbowBus.h then
                                slot.hueOffset = (h - Library._rainbowBus.h) % 1
                            end
                            slot.color = syncColor
                            slot.fill.BackgroundColor3 = syncColor
                            if type(cb) == "function" then pcall(cb, syncColor, i) end
                            if open and activeIndex == i then
                                updateSVBackground(h)
                                if svCursor and sv then svCursor.Position = UDim2.fromOffset(s*(sv.AbsoluteSize.X), (1-v)*(sv.AbsoluteSize.Y)) end
                                if hueGrab and hueSlider then hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), h*(hueSlider.AbsoluteSize.Y)) end
                                if rgbBox and not rgbBox:IsFocused() then local r,g,b = toRGB255(syncColor); rgbBox.Text = string.format("%d, %d, %d", r,g,b) end
                                if hexBox and not hexBox:IsFocused() then local r,g,b = toRGB255(syncColor); hexBox.Text = rgbToHex(r,g,b) end
                            end
                        end
                        
                        -- If there are existing RGB effects active, sync to them after a small delay
                        if Library._globalRGBSync.active then
                            task.spawn(function()
                                task.wait(0.1) -- Small delay to let the enable process complete
                                local foundRGBSync = false
                                for existingId, existingListener in pairs(Library._globalRGBSync.listeners) do
                                    if existingId ~= syncId and existingListener and not foundRGBSync then
                                        -- Find an existing RGB slot to sync from
                                        for checkId, checkSlot in pairs(Library._controls) do
                                            if checkSlot._slots and not foundRGBSync then
                                                for j, checkSlotData in ipairs(checkSlot._slots) do
                                                    if checkSlotData.rainbow and checkSlotData._syncId and checkSlotData._syncId ~= syncId then
                                                        -- Sync to this existing RGB color
                                                        local syncColor = checkSlotData.color
                                                        if Library._globalRGBSync.listeners[syncId] then
                                                            Library._globalRGBSync.listeners[syncId](syncColor, checkSlotData._syncId)
                                                        end
                                                        foundRGBSync = true
                                                        break
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end)
                        end
                        if slot.rainbowHook then rainbowRemove(slot.rainbowHook); slot.rainbowHook = nil end
                        slot.rainbow = true
                        slot.rainbowHook = attachRainbow(i)
                        if slot._syncId then
                            local c0 = hsvToColor(slot.hsv)
                            syncRGBColor(c0, slot._syncId)
                        end
                        updateSlotUI(i)
                        -- Force immediate UI refresh to ensure checkbox shows correctly
                        task.defer(function()
                            if open and activeIndex == i then
                                setCheckbox(slot.rainbow or false)
                            end
                        end)
                    end
                    local function disablePulse(i)
                        local slot = slots[i]
                        slot.pulse = false
                        slot._resumePulse = nil
                        if slot.pulseHook then rainbowRemove(slot.pulseHook); slot.pulseHook = nil end
                        -- Properly cleanup global sync listeners
                        if slot._pulseSyncId then
                            Library._globalPulseSync.listeners[slot._pulseSyncId] = nil
                            slot._pulseSyncId = nil
                            -- Check if there are any active pulse listeners left
                            local hasActivePulse = false
                            for _, listener in pairs(Library._globalPulseSync.listeners) do 
                                if listener then hasActivePulse = true break end 
                            end
                            Library._globalPulseSync.active = hasActivePulse
                        end
                        updateSlotUI(i)
                    end
                    local function enablePulse(i)
                        local slot = slots[i]
                        -- turn off rainbow for this slot
                        if slot.rainbowHook then rainbowRemove(slot.rainbowHook); slot.rainbowHook = nil end
                        slot.rainbow = false
                        slot._resumeRainbow = nil
                        -- if RGB sync was active, remove listener for this slot
                        if slot._syncId then
                            Library._globalRGBSync.listeners[slot._syncId] = nil
                            slot._syncId = nil
                            local hasActiveRGB = false
                            for _, listener in pairs(Library._globalRGBSync.listeners) do 
                                if listener then hasActiveRGB = true break end 
                            end
                            Library._globalRGBSync.active = hasActiveRGB
                        end
                        -- Always set up global sync for ALL colorpickers
                        Library._globalPulseSync.active = true
                        local syncId = tostring(id .. "_" .. i .. "_" .. math.random(1000000, 9999999))
                        slot._pulseSyncId = syncId
                        -- Create proper pulse sync listener
                        Library._globalPulseSync.listeners[syncId] = function(syncColor, sourceId)
                            if not slot.pulse or sourceId == syncId then return end -- Don't sync to self
                            slot.color = syncColor
                            slot.fill.BackgroundColor3 = syncColor
                            if type(cb) == "function" then pcall(cb, syncColor, i) end
                            if open and activeIndex == i then
                                if rgbBox and not rgbBox:IsFocused() then local r,g,b = toRGB255(syncColor); rgbBox.Text = string.format("%d, %d, %d", r,g,b) end
                                if hexBox and not hexBox:IsFocused() then local r,g,b = toRGB255(syncColor); hexBox.Text = rgbToHex(r,g,b) end
                            end
                        end
                        
                        -- If there are existing Pulse effects active, sync to them after a small delay
                        if Library._globalPulseSync.active then
                            task.spawn(function()
                                task.wait(0.1) -- Small delay to let the enable process complete
                                local foundPulseSync = false
                                for existingId, existingListener in pairs(Library._globalPulseSync.listeners) do
                                    if existingId ~= syncId and existingListener and not foundPulseSync then
                                        -- Find an existing Pulse slot to sync from
                                        for checkId, checkSlot in pairs(Library._controls) do
                                            if checkSlot._slots and not foundPulseSync then
                                                for j, checkSlotData in ipairs(checkSlot._slots) do
                                                    if checkSlotData.pulse and checkSlotData._pulseSyncId and checkSlotData._pulseSyncId ~= syncId then
                                                        -- Sync to this existing Pulse color
                                                        local syncColor = checkSlotData.color
                                                        if Library._globalPulseSync.listeners[syncId] then
                                                            Library._globalPulseSync.listeners[syncId](syncColor, checkSlotData._pulseSyncId)
                                                        end
                                                        foundPulseSync = true
                                                        break
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end)
                        end
                        -- seed pulse offset vs global hue
                        if Library._rainbowBus and Library._rainbowBus.h then
                            local currentH = slot.hsv[1] or 0
                            slot.pulseHueOffset = (currentH - Library._rainbowBus.h) % 1
                        else
                            -- Initialize offset to 0 if rainbow bus not yet started
                            slot.pulseHueOffset = 0
                        end
                        if slot.pulseHook then rainbowRemove(slot.pulseHook); slot.pulseHook = nil end
                        slot.pulse = true
                        -- Ensure rainbow animation starts and then add pulse hook
                        slot.pulseHook = rainbowAdd(function(h)
                            -- For Pulse mode, ensure good saturation and base value for visible effects
                            local s = math.max(0.8, slot.hsv[2] or 1) -- Minimum 80% saturation
                            local baseV = math.max(0.7, slot.hsv[3] or 1) -- Minimum 70% base value
                            local hh = (h + (slot.pulseHueOffset or 0)) % 1
                            local vPulse = 0.35 + 0.65 * (0.5 + 0.5 * math.sin(tick() * 4))
                            local c = Color3.fromHSV(hh, s, math.clamp(vPulse * baseV, 0, 1))
                            slot.hsv = {hh, s, baseV}
                            slot.color = c
                            slot.fill.BackgroundColor3 = c
                            if slot._pulseSyncId then syncPulseColor(c, slot._pulseSyncId) end
                            if type(cb) == "function" then pcall(cb, c, i) end
                            if open and activeIndex == i then
                                if rgbBox and not rgbBox:IsFocused() then local r,g,b = toRGB255(c); rgbBox.Text = string.format("%d, %d, %d", r,g,b) end
                                if hexBox and not hexBox:IsFocused() then local r,g,b = toRGB255(c); hexBox.Text = rgbToHex(r,g,b) end
                            end
                        end)
                        if slot._pulseSyncId then
                            local c0 = hsvToColor(slot.hsv)
                            syncPulseColor(c0, slot._pulseSyncId)
                        end
                        updateSlotUI(i)
                        -- Force immediate UI refresh to ensure checkbox shows correctly
                        task.defer(function()
                            if open and activeIndex == i then
                                setPulseCheckbox(slot.pulse or false)
                            end
                        end)
                    end

                    local function resolveColorPanelPosition(targetBtn, width, height)
                        width = math.max(0, width or 250)
                        height = math.max(0, height or 220)
                        local btnAbs = targetBtn.AbsolutePosition
                        local btnSize = targetBtn.AbsoluteSize
                        -- Since RootGui has IgnoreGuiInset = true, we need to account for the top bar
                        local guiInset = game:GetService("GuiService"):GetGuiInset()
                        -- Position panel directly below the button, aligned to left edge
                        local px = btnAbs.X
                        local py = btnAbs.Y + btnSize.Y + 6 + guiInset.Y
                        return px, py
                    end

                    local function openPanel(btnFor, index)
                        if anim then return end
                        -- toggle close if clicking the same swatch while open
                        if open and panel and activeIndex == index then
                            if Library._openColorPanelClose then pcall(Library._openColorPanelClose); Library._openColorPanelClose = nil end
                            return
                        end
                        if open and panel then
                            -- retarget existing panel to new slot
                            activeIndex = index
                            -- reposition near new button (prefer below the swatch)
                            -- If switching to a different slot's panel, swap panels
                            local targetPanel = slots[index] and slots[index].panel
                            if targetPanel and targetPanel ~= panel then
                                panel.Visible = false
                                panel = targetPanel
                                panel.Visible = true
                            end
                            local width, height = panel.AbsoluteSize.X, panel.AbsoluteSize.Y
                            if width <= 0 then width = 250 end
                            if height <= 0 then height = 220 end
                            local px, py = resolveColorPanelPosition(btnFor, width, height)
                            panel.Position = UDim2.fromOffset(px, py)
                            -- refresh UI to the selected slot
                            local slot = slots[index]
                            local h,s,v = table.unpack(slot.hsv)
                            updateSVBackground(h)
                            if svCursor and sv then svCursor.Position = UDim2.fromOffset(s*(sv.AbsoluteSize.X), (1-v)*(sv.AbsoluteSize.Y)) end
                            if hueGrab and hueSlider then hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), h*(hueSlider.AbsoluteSize.Y)) end
                            if rgbBox then local r,g,b = toRGB255(slot.color); rgbBox.Text = string.format("%d, %d, %d", r,g,b) end
                            if hexBox then local r,g,b = toRGB255(slot.color); hexBox.Text = rgbToHex(r,g,b) end
                            -- Restore UI to show ONLY this slot's actual functional state
                            setCheckbox(slot.rainbow or false)
                            setPulseCheckbox(slot.pulse or false)
                            -- If we switched to an existing target panel, we're done; otherwise, fall through to create it
                            if targetPanel then return end
                        end
                        local slot = slots[index]
                        slot.panelOpen = true; open = true; anim = true; activeIndex = index
                        if not slot.panel then
                            -- Calculate initial position below the button
                            local btnAbs = btnFor.AbsolutePosition
                            local btnSize = btnFor.AbsoluteSize
                            local guiInset = game:GetService("GuiService"):GetGuiInset()
                            local initialX = btnAbs.X
                            local initialY = btnAbs.Y + btnSize.Y + 6 + guiInset.Y
                            
                            slot.panel = Create("TextButton", {AutoButtonColor = false, Text = "", BackgroundColor3 = Theme.Bg, BorderSizePixel = 0, Visible = false, Size = UDim2.fromOffset(0,0), Position = UDim2.fromOffset(initialX, initialY), ZIndex = 12000, Parent = RootGui}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                                -- Main holder outline (panel)
                                Create("UIStroke", {Name = "Stroke", ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})
                            })
                        
                        -- Create UI elements for this panel (only if panel is new)
                        panel = slot.panel  -- Set for backward compatibility
                        
                            local shadow = Create("ImageLabel", {BackgroundTransparency = 1, Image = "rbxassetid://4996891970", ImageColor3 = Theme.Bg, ImageTransparency = 0.85, Size = UDim2.fromScale(1,1), ZIndex = panel.ZIndex - 1, Parent = panel})
                            shadow.ScaleType = Enum.ScaleType.Slice; shadow.SliceCenter = Rect.new(20,20,280,280)

                            -- content
                            local pad = 6
                            -- Main inner container (the frame that holds SV, inputs, and hue/checkbox)
                            local container = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-pad*2,1,-pad*2), Position = UDim2.fromOffset(pad,pad), ZIndex = panel.ZIndex + 1, Parent = panel}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,4)})
                            })
                            local content = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromScale(1,1), ZIndex = container.ZIndex + 1, Parent = container}, {
                                Create("UIListLayout", {Padding = UDim.new(0,2), FillDirection = Enum.FillDirection.Horizontal, SortOrder = Enum.SortOrder.LayoutOrder})
                            })
                            -- (Removed overlay border; using panel's own stroke so it outlines the true main holder)
                            -- Left: SV square (S across X, V across Y), base hue set by slider; plus RGB/Hex inputs
                            local leftCol = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(210, 210), ZIndex = content.ZIndex + 1, Parent = content})
                            sv = Create("Frame", {Active = true, BackgroundTransparency = 0, BackgroundColor3 = Color3.fromHSV(0,1,1), Size = UDim2.fromOffset(180, 150), ZIndex = leftCol.ZIndex + 1, Parent = leftCol})
                            Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = sv})
                            Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3, Parent = sv})
                            -- White overlay: left side white (S=0) to right transparent (S=1)
                            svWhite = Create("Frame", {Active = true, BackgroundTransparency = 0, BackgroundColor3 = Color3.fromRGB(255,255,255), Size = UDim2.fromScale(1,1), ZIndex = sv.ZIndex + 1, Parent = sv})
                            local gWhite = Instance.new("UIGradient"); gWhite.Rotation = 0; gWhite.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(1,1)}); gWhite.Parent = svWhite
                            -- Black overlay: top transparent (V=1) to bottom black (V=0)
                            svBlack = Create("Frame", {Active = true, BackgroundTransparency = 0, BackgroundColor3 = Color3.fromRGB(0,0,0), Size = UDim2.fromScale(1,1), ZIndex = sv.ZIndex + 2, Parent = sv})
                            local gBlack = Instance.new("UIGradient"); gBlack.Rotation = 90; gBlack.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1), NumberSequenceKeypoint.new(1,0)}); gBlack.Parent = svBlack
                            -- Cursor
                            svCursor = Create("Frame", {BackgroundColor3 = Theme.Bg, Size = UDim2.fromOffset(10,10), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.fromOffset(0,0), ZIndex = sv.ZIndex + 3, Parent = sv}, {Create("UICorner", {CornerRadius = UDim.new(1,0)}), Create("UIStroke", {Color = Theme.Accent, Thickness = 1, Transparency = 0})})

                            rgbBox = Create("TextBox", {BackgroundColor3 = Theme.Button, ClearTextOnFocus = false, Text = "", PlaceholderText = "R, G, B", Font = Fonts.Regular, TextSize = 12, TextColor3 = Theme.Text, PlaceholderColor3 = Theme.SubText, Size = UDim2.fromOffset(180, 22), Position = UDim2.fromOffset(0, 160), ZIndex = leftCol.ZIndex + 1, Parent = leftCol}, {Create("UICorner", {CornerRadius = UDim.new(0,3)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.55}), Create("UIPadding", {PaddingLeft = UDim.new(0,6), PaddingRight = UDim.new(0,6)})})
                            hexBox = Create("TextBox", {BackgroundColor3 = Theme.Button, ClearTextOnFocus = false, Text = "", PlaceholderText = "#FFFFFF", Font = Fonts.Regular, TextSize = 12, TextColor3 = Theme.Text, PlaceholderColor3 = Theme.SubText, Size = UDim2.fromOffset(180, 22), Position = UDim2.fromOffset(0, 186), ZIndex = leftCol.ZIndex + 1, Parent = leftCol}, {Create("UICorner", {CornerRadius = UDim.new(0,3)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.55}), Create("UIPadding", {PaddingLeft = UDim.new(0,6), PaddingRight = UDim.new(0,6)})})

                            -- Right: Hue slider + rainbow toggle
                            local HUE_W, HUE_H = 26, 150
                            local rightCol = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.fromOffset(52, 210), ZIndex = content.ZIndex + 1, Parent = content})
                            -- Make the hue slider background opaque white so the UIGradient is visible and vibrant
                            -- Position slider perfectly centered between checkbox and text (fine-tuned alignment)
                            hueSlider = Create("Frame", {Active = true, BackgroundTransparency = 0, BackgroundColor3 = Color3.fromRGB(255,255,255), BorderSizePixel = 0, Size = UDim2.fromOffset(HUE_W, HUE_H), Position = UDim2.fromOffset(-12, 0), ZIndex = rightCol.ZIndex + 1, Parent = rightCol}, {Create("UICorner", {CornerRadius = UDim.new(0,4)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})})
                            local hueGrad = Instance.new("UIGradient")
                            hueGrad.Color = ColorSequence.new({
                                ColorSequenceKeypoint.new(0.00, Color3.fromHSV(0/6,1,1)),
                                ColorSequenceKeypoint.new(0.17, Color3.fromHSV(1/6,1,1)),
                                ColorSequenceKeypoint.new(0.33, Color3.fromHSV(2/6,1,1)),
                                ColorSequenceKeypoint.new(0.50, Color3.fromHSV(3/6,1,1)),
                                ColorSequenceKeypoint.new(0.67, Color3.fromHSV(4/6,1,1)),
                                ColorSequenceKeypoint.new(0.83, Color3.fromHSV(5/6,1,1)),
                                ColorSequenceKeypoint.new(1.00, Color3.fromHSV(1,1,1)),
                            })
                            hueGrad.Rotation = 90; hueGrad.Parent = hueSlider
                            hueGrab = Create("Frame", {Active = true, BackgroundColor3 = Theme.Bg, Size = UDim2.fromOffset(HUE_W, 4), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.fromOffset(math.floor(HUE_W/2), 0), ZIndex = hueSlider.ZIndex + 1, Parent = hueSlider}, {Create("UIStroke", {Color = Theme.Accent, Thickness = 1, Transparency = 0})})

                                -- RGB checkbox + label centered between RGB textbox end and frame boundary
                            local cbRow = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = "", Size = UDim2.fromOffset(40, 22), Position = UDim2.fromOffset(190, 160), ZIndex = leftCol.ZIndex + 1, Parent = leftCol})
                            local cbBox = Create("Frame", {BackgroundColor3 = Theme.Button, Size = UDim2.fromOffset(12,12), Position = UDim2.fromOffset(0,5), ZIndex = cbRow.ZIndex + 1, Parent = cbRow}, {Create("UICorner", {CornerRadius = UDim.new(0,2)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})})
                            cbMark = Create("Frame", {BackgroundColor3 = Theme.Text, Size = UDim2.fromOffset(8,8), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.fromOffset(6,6), Visible = false, ZIndex = cbBox.ZIndex + 1, Parent = cbBox}, {Create("UICorner", {CornerRadius = UDim.new(0,2)})})
                            Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.fromOffset(24,22), Position = UDim2.fromOffset(16,0), Text = "RGB", Font = Fonts.Regular, TextSize = 10, TextColor3 = Theme.SubText, TextXAlignment = Enum.TextXAlignment.Left, ZIndex = cbRow.ZIndex + 1, Parent = cbRow})
                            
                            -- Pulse RGB checkbox + label positioned at hex textbox Y level, same X as RGB checkbox
                            local pulseRow = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = "", Size = UDim2.fromOffset(50, 22), Position = UDim2.fromOffset(190, 186), ZIndex = leftCol.ZIndex + 1, Parent = leftCol})
                            local pulseBox = Create("Frame", {BackgroundColor3 = Theme.Button, Size = UDim2.fromOffset(12,12), Position = UDim2.fromOffset(0,5), ZIndex = pulseRow.ZIndex + 1, Parent = pulseRow}, {Create("UICorner", {CornerRadius = UDim.new(0,2)}), Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})})
                            pulseMark = Create("Frame", {BackgroundColor3 = Theme.Text, Size = UDim2.fromOffset(8,8), AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.fromOffset(6,6), Visible = false, ZIndex = pulseBox.ZIndex + 1, Parent = pulseBox}, {Create("UICorner", {CornerRadius = UDim.new(0,2)})})
                            Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.fromOffset(34,22), Position = UDim2.fromOffset(16,0), Text = "Pulse", Font = Fonts.Regular, TextSize = 10, TextColor3 = Theme.SubText, TextXAlignment = Enum.TextXAlignment.Left, ZIndex = pulseRow.ZIndex + 1, Parent = pulseRow})
                            -- Store the current panel reference
                            slot.panel = panel

                            -- interactions: SV drag (S across X, V across Y)
                            local function getScreenPos()
                                local inset = game:GetService("GuiService"):GetGuiInset()
                                local m = UserInputService:GetMouseLocation()
                                return Vector2.new(m.X - inset.X, m.Y - inset.Y)
                            end
                            local svDragging = false
                            local svDragIndex = nil
                            local function handleSVDown(inp)
                                if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
                                    svDragging = true
                                    svDragIndex = activeIndex
                                    -- While dragging, update color live; if rainbow is on, update hueOffset so it continues from here
                                    local slot = slots[svDragIndex]
                                    local p = getScreenPos()
                                    local rel = Vector2.new(p.X - sv.AbsolutePosition.X, p.Y - sv.AbsolutePosition.Y)
                                    local s = clamp01(rel.X / math.max(1, sv.AbsoluteSize.X))
                                    local v = 1 - clamp01(rel.Y / math.max(1, sv.AbsoluteSize.Y))
                                    svCursor.Position = UDim2.fromOffset(math.clamp(rel.X,0,sv.AbsoluteSize.X), math.clamp(rel.Y,0,sv.AbsoluteSize.Y))
                                    setHSVDrag(svDragIndex, nil, s, v)
                                    -- Adjust offsets if effects active
                                    if slot and Library._rainbowBus and Library._rainbowBus.h then
                                        if slot.rainbow then
                                        local currentH = slot.hsv[1] or 0
                                        slot.hueOffset = (currentH - Library._rainbowBus.h) % 1
                                        end
                                        if slot.pulse then
                                            local currentH = slot.hsv[1] or 0
                                            slot.pulseHueOffset = (currentH - Library._rainbowBus.h) % 1
                                        end
                                    end
                                end
                            end
                            sv.InputBegan:Connect(handleSVDown)
                            svWhite.InputBegan:Connect(handleSVDown)
                            svBlack.InputBegan:Connect(handleSVDown)
                            UserInputService.InputChanged:Connect(function(inp)
                                if svDragging and (inp.UserInputType == Enum.UserInputType.MouseMovement or inp.UserInputType == Enum.UserInputType.Touch) then
                                    local p = getScreenPos()
                                    local rel = Vector2.new(p.X - sv.AbsolutePosition.X, p.Y - sv.AbsolutePosition.Y)
                                    local s = clamp01(rel.X / math.max(1, sv.AbsoluteSize.X))
                                    local v = 1 - clamp01(rel.Y / math.max(1, sv.AbsoluteSize.Y))
                                    svCursor.Position = UDim2.fromOffset(math.clamp(rel.X,0,sv.AbsoluteSize.X), math.clamp(rel.Y,0,sv.AbsoluteSize.Y))
                                    setHSVDrag(svDragIndex or activeIndex, nil, s, v)
                                end
                            end)
                            UserInputService.InputEnded:Connect(function(inp)
                                if svDragging and (inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch) then
                                    svDragging = false
                                    local dragIndex = svDragIndex or activeIndex
                                    local slot = slots[dragIndex]
                                    -- Keep offsets synced to current manual position
                                    if slot and Library._rainbowBus and Library._rainbowBus.h then
                                        local currentH = slot.hsv[1] or 0
                                        if slot.rainbow then slot.hueOffset = (currentH - Library._rainbowBus.h) % 1 end
                                        if slot.pulse then slot.pulseHueOffset = (currentH - Library._rainbowBus.h) % 1 end
                                    end
                                    svDragIndex = nil
                                end
                            end)

                            -- hue drag
                            local hueDragging = false
                            local hueDragIndex = nil
                            local function handleHueDown(inp)
                                if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
                                    hueDragging = true
                                    hueDragIndex = activeIndex
                                    local slot = slots[hueDragIndex]
                                    local p = getScreenPos()
                                    local relY = math.clamp(p.Y - hueSlider.AbsolutePosition.Y, 0, hueSlider.AbsoluteSize.Y)
                                    hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), relY)
                                    local h = clamp01(relY / math.max(1, hueSlider.AbsoluteSize.Y))
                                    setHSVDrag(hueDragIndex, h, nil, nil)
                                    updateSVBackground(h)
                                    -- If effects are on, update offsets live
                                    if slot and Library._rainbowBus and Library._rainbowBus.h then
                                        if slot.rainbow then slot.hueOffset = (h - Library._rainbowBus.h) % 1 end
                                        if slot.pulse then slot.pulseHueOffset = (h - Library._rainbowBus.h) % 1 end
                                    end
                                end
                            end
                            hueSlider.InputBegan:Connect(handleHueDown)
                            hueGrab.InputBegan:Connect(handleHueDown)
                            UserInputService.InputChanged:Connect(function(inp)
                                if hueDragging and (inp.UserInputType == Enum.UserInputType.MouseMovement or inp.UserInputType == Enum.UserInputType.Touch) then
                                    local p = getScreenPos()
                                    local relY = math.clamp(p.Y - hueSlider.AbsolutePosition.Y, 0, hueSlider.AbsoluteSize.Y)
                                    hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), relY)
                                    local h = clamp01(relY / math.max(1, hueSlider.AbsoluteSize.Y))
                                    local idx = hueDragIndex or activeIndex
                                    setHSVDrag(idx, h, nil, nil)
                                    updateSVBackground(h)
                                end
                            end)
                            UserInputService.InputEnded:Connect(function(inp)
                                if hueDragging and (inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch) then
                                    hueDragging = false
                                    local dragIndex = hueDragIndex or activeIndex
                                    local slot = slots[dragIndex]
                                    
                                    -- Keep offsets synced
                                    if slot and Library._rainbowBus and Library._rainbowBus.h then
                                        local currentH = slot.hsv[1] or 0
                                        if slot.rainbow then slot.hueOffset = (currentH - Library._rainbowBus.h) % 1 end
                                        if slot.pulse then slot.pulseHueOffset = (currentH - Library._rainbowBus.h) % 1 end
                                    end
                                    hueDragIndex = nil
                                end
                            end)

                            -- inputs
                            rgbBox.FocusLost:Connect(function()
                                local slot = slots[activeIndex]
                                local r,g,b = parseRGBText(rgbBox.Text or "")
                                if r then
                                    r,g,b = math.clamp(r,0,255), math.clamp(g,0,255), math.clamp(b,0,255)
                                    local c = Color3.fromRGB(r,g,b)
                                    local h,s,v = Color3.toHSV(c)
                                    setHSV(activeIndex, h,s,v)
                                    -- Update visual UI elements
                                    updateSVBackground(h)
                                    if svCursor and sv then svCursor.Position = UDim2.fromOffset(s*(sv.AbsoluteSize.X), (1-v)*(sv.AbsoluteSize.Y)) end
                                    if hueGrab and hueSlider then hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), h*(hueSlider.AbsoluteSize.Y)) end
                                else
                                    local c = slots[activeIndex].color
                                    local rr,gg,bb = toRGB255(c)
                                    rgbBox.Text = string.format("%d, %d, %d", rr,gg,bb)
                                end
                            end)
                            hexBox.FocusLost:Connect(function()
                                local slot = slots[activeIndex]
                                local r,g,b = hexToRGB(hexBox.Text or "")
                                if r then
                                    local c = Color3.fromRGB(r,g,b)
                                    local h,s,v = Color3.toHSV(c)
                                    setHSV(activeIndex, h,s,v)
                                    -- Update visual UI elements
                                    updateSVBackground(h)
                                    if svCursor and sv then svCursor.Position = UDim2.fromOffset(s*(sv.AbsoluteSize.X), (1-v)*(sv.AbsoluteSize.Y)) end
                                    if hueGrab and hueSlider then hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), h*(hueSlider.AbsoluteSize.Y)) end
                                else
                                    local c = slots[activeIndex].color
                                    hexBox.Text = (function() local r,g,b = toRGB255(c); return rgbToHex(r,g,b) end)()
                                end
                            end)

                            -- rainbow checkbox logic
                            cbRow.MouseButton1Click:Connect(function()
                                local idx = activeIndex
                                local s = slots[idx]
                                -- Store current state to avoid reading it mid-transition
                                local wasRainbow = s.rainbow
                                
                                if wasRainbow then
                                    disableRainbow(idx)
                                else
                                    enableRainbow(idx)
                                end
                            end)
                            
                            -- pulse RGB checkbox logic
                            pulseRow.MouseButton1Click:Connect(function()
                                local idx = activeIndex
                                local s = slots[idx]
                                -- Store current state to avoid reading it mid-transition
                                local wasPulse = s.pulse
                                
                                if wasPulse then
                                    disablePulse(idx)
                                else
                                    enablePulse(idx)
                                end
                            end)
                        end

                        -- position panel near btnFor (prefer below)
                        panel.Visible = true; panel.ClipsDescendants = true
                        -- Create a blocker to intercept outside clicks and block underlying UI
                        if panelBlocker and panelBlocker.Parent then pcall(function() panelBlocker:Destroy() end) end
                        panelBlocker = Create("TextButton", {AutoButtonColor = false, Modal = false, BackgroundTransparency = 1, Text = "", Size = UDim2.fromScale(1,1), Position = UDim2.fromOffset(0,0), ZIndex = (panel.ZIndex or 1) - 1, Parent = RootGui})
                        -- Close any other open color panel globally
                        local function closePanel()
                            if not panel or not panel.Visible then return end
                            panel.Visible = false; open=false; anim=false; disconnectAll()
                            if panelBlocker and panelBlocker.Parent then pcall(function() panelBlocker:Destroy() end) end
                            panelBlocker = nil
                            if Library._openColorPanelClose == closePanel then Library._openColorPanelClose = nil end
                        end
                        if Library._openColorPanelClose and Library._openColorPanelClose ~= closePanel then pcall(Library._openColorPanelClose) end
                        if Library._openColorCtxClose then pcall(Library._openColorCtxClose); Library._openColorCtxClose = nil end
                        Library._openColorPanelClose = closePanel

                        local width, height = 250, 220

                        -- Since panel is parented to RootGui, use screen coordinates
                        -- Position directly below the button
                        local function placePanel()
                            local currentWidth = panel.AbsoluteSize.X
                            local currentHeight = panel.AbsoluteSize.Y
                            if currentWidth <= 0 then currentWidth = width end
                            if currentHeight <= 0 then currentHeight = height end
                            local px, py = resolveColorPanelPosition(btnFor, currentWidth, currentHeight)
                            panel.Position = UDim2.fromOffset(px, py)
                        end
                        placePanel()
                        panel.Size = UDim2.fromOffset(width, 0)

                        -- set UI to current slot
                        local slotForUI = slots[index]
                        local h,s,v = table.unpack(slotForUI.hsv)
                        updateSVBackground(h)
                        if svCursor and sv then svCursor.Position = UDim2.fromOffset(s*(sv.AbsoluteSize.X), (1-v)*(sv.AbsoluteSize.Y)) end
                        if hueGrab and hueSlider then hueGrab.Position = UDim2.fromOffset(math.floor(hueSlider.AbsoluteSize.X/2), h*(hueSlider.AbsoluteSize.Y)) end
                        if rgbBox then local r,g,b = toRGB255(slotForUI.color); rgbBox.Text = string.format("%d, %d, %d", r,g,b) end
                        if hexBox then local r,g,b = toRGB255(slotForUI.color); hexBox.Text = rgbToHex(r,g,b) end
                        -- Reflect slot state and resume effects if needed
                        setCheckbox(slotForUI.rainbow or false)
                        setPulseCheckbox(slotForUI.pulse or false)
                        -- Effects should already be running if enabled, no need to resume here
                        -- The enable/disable functions handle all effect management properly

                        -- Swallow background clicks on the panel itself so blocker doesn't see them
                        -- Clear previous ephemeral open connections (if panel reopened)
                        disconnectAll()
                        table.insert(openConns, panel.InputBegan:Connect(function() end))
                        local tw = T(panel,0.18,{Size = UDim2.fromOffset(width, height)})
                        tw:Play(); tw.Completed:Connect(function() anim=false end)
                        -- Keep the panel aligned while sizes/positions change
                        table.insert(openConns, panel:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                            if panel.AbsoluteSize.X > 0 then width = panel.AbsoluteSize.X end
                            if panel.AbsoluteSize.Y > 0 then height = panel.AbsoluteSize.Y end
                            placePanel()
                        end))
                        table.insert(openConns, btnFor:GetPropertyChangedSignal("AbsolutePosition"):Connect(placePanel))
                        table.insert(openConns, btnFor:GetPropertyChangedSignal("AbsoluteSize"):Connect(placePanel))
                        table.insert(openConns, root:GetPropertyChangedSignal("AbsolutePosition"):Connect(placePanel))
                        table.insert(openConns, root:GetPropertyChangedSignal("AbsoluteSize"):Connect(placePanel))
                        anim=false
                        local justOpened = true; task.defer(function() justOpened = false end)
                        -- outside close / esc
                        -- close when clicking on blocker
                        if panelBlocker then
                            table.insert(openConns, panelBlocker.MouseButton1Click:Connect(function() closePanel() end))
                            table.insert(openConns, panelBlocker.MouseButton2Click:Connect(function() closePanel() end))
                            table.insert(openConns, panelBlocker.TouchTap:Connect(function() closePanel() end))
                        end
                    end

                    -- open/ctx events per slot
                    for i,slot in ipairs(slots) do
                        slot.btn.MouseButton1Click:Connect(function() openPanel(slot.btn, i) end)
                        slot.btn.MouseButton2Click:Connect(function()
                            activeIndex = i
                            if Library._openColorCtxClose and Library._openColorCtxClose ~= closeCtx then pcall(Library._openColorCtxClose) end
                            openCtx(slot.btn)
                            Library._openColorCtxClose = function() closeCtx(); if Library._openColorCtxClose then Library._openColorCtxClose = nil end end
                        end)
                        slot.btn.InputBegan:Connect(function(inp)
                            if inp.UserInputType == Enum.UserInputType.MouseButton2 then
                                activeIndex = i
                                if Library._openColorCtxClose and Library._openColorCtxClose ~= closeCtx then pcall(Library._openColorCtxClose) end
                                openCtx(slot.btn)
                                Library._openColorCtxClose = function() closeCtx(); if Library._openColorCtxClose then Library._openColorCtxClose = nil end end
                            end
                        end)
                    end

                    -- public API
                    local Colorpicker = { 
                        id = id, 
                        _slots = slots,
                        _enableRainbow = enableRainbow,
                        _enablePulse = enablePulse,
                        _disableRainbow = disableRainbow,
                        _disablePulse = disablePulse
                    }
                    -- expose current active slot index for this control
                    function Colorpicker:_getActiveIndex()
                        return activeIndex or 1
                    end
                    function Colorpicker:Get(index)
                        if index then return self._slots[index] and self._slots[index].color end
                        if #self._slots == 1 then return self._slots[1].color end
                        local arr = {}
                        for i,s in ipairs(self._slots) do arr[i] = s.color end
                        return arr
                    end
                    function Colorpicker:Set(value, index, silent)
                        local function setOne(i, c)
                            local h,s,v = Color3.toHSV(c)
                            self._slots[i].hsv = {h,s,v}
                            self._slots[i].color = c
                            self._slots[i].fill.BackgroundColor3 = c
                            if not silent and type(cb)=="function" then pcall(cb, c, i) end
                        end
                        if index then
                            local c = colorFromAny(value)
                            setOne(index, c)
                        else
                            if type(value) == "table" and #value > 0 then
                                for i=1, math.min(#value, #self._slots) do setOne(i, colorFromAny(value[i])) end
                            else
                                local c = colorFromAny(value)
                                for i=1, #self._slots do setOne(i, c) end
                            end
                        end
                    end
                    function Colorpicker:SetRainbow(on, index)
                        if not index then index = self:_getActiveIndex() end
                        if on == true then
                            enableRainbow(index)
                        else
                            disableRainbow(index)
                        end
                    end
                    function Colorpicker:SetPulse(on, index)
                        if not index then index = self:_getActiveIndex() end
                        if on == true then
                            enablePulse(index)
                        else
                            disablePulse(index)
                        end
                    end

                    -- apply defaults & optional rainbow
                    for i=1,#slots do
                        local h,s,v = Color3.toHSV(slots[i].color)
                        slots[i].hsv = {h,s,v}
                        -- Rainbow default is always off
                    end

                    Library:_registerControl(Colorpicker)
                    table.insert(Group._controls, Colorpicker)
                    registerSearch(label)
                    return Colorpicker
                end

                -- Keybind Toggle
                function Group:AddKeybindToggle(o)
                    o = o or {}
                    local label = tostring(o.Name or "Keybind Toggle")
                    local cb = o.Callback
                    local defaultKey = o.Default or o.Key or Enum.KeyCode.E
                    if typeof(defaultKey) ~= "EnumItem" and type(defaultKey) == "string" then
                        defaultKey = ParseKeyFromString(defaultKey) or defaultKey
                    end
                    local mode = o.Mode or "Hold" -- "Toggle", "Hold", "Always"
                    local defaultToggle = o.DefaultToggle or (mode == "Hold" or mode == "Always") -- Default ON for Hold and Always modes
                    local id = o.Flag and tostring(o.Flag) or ("%s/%s/%s/%s"):format(Category.Name, Page.Name, Group.Name, label)
                    
                    -- Key name lookup table (including mouse buttons)
                    local keyNames = {
                        [Enum.KeyCode.LeftShift] = "LShift", [Enum.KeyCode.RightShift] = "RShift",
                        [Enum.KeyCode.LeftControl] = "LCtrl", [Enum.KeyCode.RightControl] = "RCtrl", 
                        [Enum.KeyCode.LeftAlt] = "LAlt", [Enum.KeyCode.RightAlt] = "RAlt",
                        [Enum.KeyCode.CapsLock] = "Caps", [Enum.KeyCode.Tab] = "Tab",
                        [Enum.KeyCode.Backspace] = "Backspace", [Enum.KeyCode.Return] = "Enter",
                        [Enum.KeyCode.Space] = "Space", [Enum.KeyCode.Escape] = "Esc",
                        [Enum.KeyCode.Insert] = "Ins", [Enum.KeyCode.Delete] = "Del",
                        [Enum.KeyCode.Home] = "Home", [Enum.KeyCode.End] = "End",
                        [Enum.KeyCode.PageUp] = "PgUp", [Enum.KeyCode.PageDown] = "PgDn",
                        [Enum.KeyCode.Up] = "↑", [Enum.KeyCode.Down] = "↓", 
                        [Enum.KeyCode.Left] = "←", [Enum.KeyCode.Right] = "→",
                        [Enum.KeyCode.F1] = "F1", [Enum.KeyCode.F2] = "F2", [Enum.KeyCode.F3] = "F3",
                        [Enum.KeyCode.F4] = "F4", [Enum.KeyCode.F5] = "F5", [Enum.KeyCode.F6] = "F6",
                        [Enum.KeyCode.F7] = "F7", [Enum.KeyCode.F8] = "F8", [Enum.KeyCode.F9] = "F9",
                        [Enum.KeyCode.F10] = "F10", [Enum.KeyCode.F11] = "F11", [Enum.KeyCode.F12] = "F12"
                    }
                    
                    -- Mouse button names
                    local mouseButtonNames = {
                        [Enum.UserInputType.MouseButton1] = "Mouse1",
                        [Enum.UserInputType.MouseButton2] = "Mouse2"
                    }
                    
                    local function getKeyName(keyCode, inputType)
                        if inputType and mouseButtonNames[inputType] then 
                            return mouseButtonNames[inputType] 
                        end
                        if keyNames[keyCode] then return keyNames[keyCode] end
                        local name = tostring(keyCode):match("Enum%.KeyCode%.(.+)")
                        -- Prettify keypad
                        if name and name:match("^Keypad%d$") then return name end
                        if name == "KeypadPlus" then return "Keypad+" end
                        if name == "KeypadMinus" then return "Keypad-" end
                        if name == "KeypadMultiply" then return "Keypad*" end
                        if name == "KeypadDivide" then return "Keypad/" end
                        if name == "KeypadPeriod" then return "Keypad." end
                        return name or "None"
                    end
                    
                    -- State management
                    local currentKey = defaultKey
                    local currentInputType = nil -- Track if it's a mouse button
                    local isToggled = defaultToggle
                    local isBinding = false
                    local isHolding = false
                    local keybindToggleState = false -- Track active sub-state for Toggle mode (true when toggled via key)
                    local connections = {}
                    
                    -- Build row
                    local rowH = 30
                    local row = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1,-2,0,rowH), Position = UDim2.fromOffset(0,nextY(rowH)), Parent = gFrame})
                    Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(0.42,-6,1,0), Text = label, Font = Fonts.Medium, TextSize = 13, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, Parent = row})
                    
                    -- Right side container
                    local rightContainer = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(0.58,-4,1,0), Position = UDim2.new(0.42,4,0,0), Parent = row})
                    local rightLayout = Create("UIListLayout", {Parent = rightContainer, FillDirection = Enum.FillDirection.Horizontal, Padding = UDim.new(0,8), HorizontalAlignment = Enum.HorizontalAlignment.Right, VerticalAlignment = Enum.VerticalAlignment.Center})
                    
                    -- Keybind button (positioned first, so it appears on the right) - styled like normal AddKeybind but same height as toggle
                    local keybindBtn = Create("TextButton", {BackgroundColor3 = Theme.Button, AutoButtonColor = false, Size = UDim2.fromOffset(60, 18), Text = Library.FormatKeyName(getKeyName(currentKey, currentInputType)), Font = Fonts.Regular, TextSize = 11, TextColor3 = Theme.SubText, Parent = rightContainer}, {Create("UICorner", {CornerRadius = UDim.new(0,4)}), Create("UIStroke", {Name = "Stroke", Color = Theme.Stroke, Thickness = 1, Transparency = 0.3})})
                    -- Focus line for keybind capture (like normal AddKeybind)
                    local focusBar = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0,0,0,2), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,0,1,0), BackgroundTransparency = 1, Parent = keybindBtn})
                    local stroke = keybindBtn:FindFirstChild("Stroke")
                    
                    -- Toggle switch (like AddToggle, positioned second so it appears on the left)
                    local toggleContainer = Create("TextButton", {BackgroundTransparency = 1, AutoButtonColor = false, Text = "", Size = UDim2.fromOffset(40, 18), Parent = rightContainer})
                    local shell = Create("Frame", {BackgroundColor3 = Color3.fromRGB(50,50,50), Size = UDim2.fromScale(1,1), Parent = toggleContainer})
                    Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = shell})
                    local recess = Create("Frame", {BackgroundColor3 = Theme.Bg, Size = UDim2.fromOffset(36,14), Position = UDim2.fromOffset(2,2), Parent = shell})
                    Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = recess})
                    local accentFill = Create("Frame", {BackgroundColor3 = Theme.Accent, BackgroundTransparency = 1, Size = UDim2.fromScale(1,1), Parent = shell})
                    Create("UICorner", {CornerRadius = UDim.new(0,4), Parent = accentFill})
                    local knob = Create("Frame", {BackgroundColor3 = Theme.Scrollbar, Size = UDim2.fromOffset(12,12), Position = UDim2.new(0,4,0.5,0), AnchorPoint = Vector2.new(0,0.5), Parent = shell})
                    Create("UICorner", {CornerRadius = UDim.new(1,0), Parent = knob})
                    
                    -- Mode display in keybind button (no separate button needed)
                    
                    -- Hover effects
                    toggleContainer.MouseEnter:Connect(function() T(shell,0.15,{BackgroundColor3 = Color3.fromRGB(58,58,58)}):Play() end)
                    toggleContainer.MouseLeave:Connect(function() T(shell,0.15,{BackgroundColor3 = Color3.fromRGB(50,50,50)}):Play() end)
                    -- Keybind button hover - no special effects, just like normal AddKeybind
                    
                    -- Update visual state (using AddToggle style)
                    local function updateToggleVisual()
                        if isToggled then
                            T(accentFill,0.25,{BackgroundTransparency = 0}):Play()
                            T(knob,0.25,{Position = UDim2.new(1,-16,0.5,0), BackgroundColor3 = Theme.Text}):Play()
                        else
                            T(accentFill,0.25,{BackgroundTransparency = 1}):Play()
                            T(knob,0.25,{Position = UDim2.new(0,4,0.5,0), BackgroundColor3 = Theme.Scrollbar}):Play()
                        end
                    end
                    
                    local function updateKeybindVisual()
                        if isBinding then
                            keybindBtn.Text = "..."
                            keybindBtn.TextColor3 = Theme.Text
                            keybindBtn.Font = Fonts.Regular
                            -- Show focus line like normal AddKeybind
                            if focusBar then
                                focusBar.BackgroundTransparency = 0
                                focusBar.Size = UDim2.new(0,0,0,2)
                                T(focusBar,0.20,{Size = UDim2.new(1,0,0,2)}):Play()
                            end
                            if stroke then T(stroke,0.15,{Transparency = 0.18}):Play() end
                        else
                            keybindBtn.Text = Library.FormatKeyName(getKeyName(currentKey, currentInputType))
                            keybindBtn.TextColor3 = currentKey and Theme.Text or Theme.SubText
                            keybindBtn.Font = Fonts.Regular
                            -- Auto-resize based on text content (match toggle height of 18px)
                            local textService = game:GetService("TextService")
                            local textSize = textService:GetTextSize(keybindBtn.Text, 11, Fonts.Regular, Vector2.new(math.huge, 18))
                            keybindBtn.Size = UDim2.fromOffset(math.max(40, textSize.X + 12), 18)
                            -- Hide focus line
                            if focusBar then
                                local tw1 = T(focusBar,0.18,{Size = UDim2.new(0,0,0,2)})
                                tw1:Play()
                                tw1.Completed:Connect(function()
                                    if focusBar.Parent then focusBar.BackgroundTransparency = 1 end
                                end)
                            end
                            if stroke then T(stroke,0.18,{Transparency = 0.3}):Play() end
                        end
                    end
                    
                    -- Keybind functionality
                    local function disconnectAll()
                        for _, conn in pairs(connections) do
                            if conn then pcall(function() conn:Disconnect() end) end
                        end
                        table.clear(connections)
                    end
                    
                    local function startBinding()
                        if isBinding then return end
                        isBinding = true
                        updateKeybindVisual()
                        disconnectAll()
                        
                        -- Listen for key and mouse input
                        table.insert(connections, UserInputService.InputBegan:Connect(function(input, gameProcessed)
                            if gameProcessed then return end
                            if input.UserInputType == Enum.UserInputType.Keyboard then
                                local keyCode = input.KeyCode
                                if keyCode == Enum.KeyCode.Escape then
                                    -- Cancel binding with ESC
                                    isBinding = false
                                    if updateKeybindVisual then updateKeybindVisual() end
                                    if disconnectAll then disconnectAll() end
                                    if setupKeybindListener then setupKeybindListener() end
                                elseif keyCode ~= Enum.KeyCode.Unknown then
                                    currentKey = keyCode
                                    currentInputType = nil -- It's a keyboard key
                                    isBinding = false
                                    if updateKeybindVisual then updateKeybindVisual() end
                                    if disconnectAll then disconnectAll() end
                                    if setupKeybindListener then setupKeybindListener() end
                                end
                            elseif input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.MouseButton2 then
                                -- Capture mouse buttons immediately without delay
                                currentKey = nil
                                currentInputType = input.UserInputType
                                isBinding = false
                                if updateKeybindVisual then updateKeybindVisual() end
                                if disconnectAll then disconnectAll() end
                                if setupKeybindListener then setupKeybindListener() end
                            end
                        end))
                        
                        -- Additional safety handler for edge cases
                        table.insert(connections, UserInputService.InputBegan:Connect(function(input)
                            if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Escape and isBinding then
                                isBinding = false
                                if updateKeybindVisual then updateKeybindVisual() end
                                if disconnectAll then disconnectAll() end
                                if setupKeybindListener then setupKeybindListener() end
                            end
                        end))
                    end
                    
                    local function setupKeybindListener()
                        disconnectAll()
                        
                        if mode == "Always" then
                            -- Always mode - toggle is always ON, keybind always active
                            isToggled = true
                            updateToggleVisual()
                            -- In Always mode, immediately trigger callback
                            if type(cb) == "function" then
                                pcall(cb, true, currentKey or currentInputType)
                            end
                        end
                        
                        -- Keybind listeners - only work when toggle is ON
                        table.insert(connections, UserInputService.InputBegan:Connect(function(input, gameProcessed)
                            if gameProcessed then return end
                            if not isToggled then return end  -- Only work when toggle is ON
                            
                            local matches = false
                            
                            if currentInputType then
                                -- Mouse button
                                matches = input.UserInputType == currentInputType
                            else
                                -- Keyboard key
                                matches = input.KeyCode == currentKey
                            end
                            
                            if not matches then return end
                            
                            if mode == "Toggle" then
                                -- In toggle mode, pressing keybind alternates state
                                keybindToggleState = not keybindToggleState
                                -- Update list 'active' to reflect Toggle sub-state
                                if updateKeybindTracking ~= nil then
                                    updateKeybindTracking({ active = keybindToggleState, toggleEnabled = isToggled })
                                end
                                if type(cb) == "function" then
                                    pcall(cb, keybindToggleState, currentKey or currentInputType)
                                end
                            elseif mode == "Hold" then
                                isHolding = true
                                if updateKeybindTracking ~= nil then
                                    updateKeybindTracking({ active = true, toggleEnabled = isToggled })
                                end
                                if type(cb) == "function" then
                                    pcall(cb, true, currentKey or currentInputType)
                                end
                            end
                        end))
                        
                        if mode == "Hold" then
                            table.insert(connections, UserInputService.InputEnded:Connect(function(input, gameProcessed)
                                if not isToggled then return end  -- Only work when toggle is ON
                                local matches = false
                                
                                if currentInputType then
                                    -- Mouse button
                                    matches = input.UserInputType == currentInputType
                                else
                                    -- Keyboard key
                                    matches = input.KeyCode == currentKey
                                end
                                
                                if not matches then return end
                                isHolding = false
                                if updateKeybindTracking ~= nil then
                                    updateKeybindTracking({ active = false, toggleEnabled = isToggled })
                                end
                                if type(cb) == "function" then
                                    pcall(cb, false, currentKey or currentInputType)
                                end
                            end))
                        end
                    end
                    
                    -- Toggle button click - controls keybind activation
                    toggleContainer.MouseButton1Click:Connect(function()
                        if mode == "Always" then return end -- Can't manually toggle in Always mode
                        isToggled = not isToggled
                        updateToggleVisual()
                        
                        -- Update keybind list tracking
                        if updateKeybindTracking ~= nil then
                            updateKeybindTracking({
                                toggleEnabled = isToggled,
                                active = isToggled
                            })
                        end
                        -- Toggle just enables/disables the keybind, doesn't trigger callback
                    end)
                    
                    -- Context menu for mode selection
                    local ctxMenu, ctxOpen = nil, false
                    local ctxBlocker = nil
                    local ctxConns = {}
                    local function ctxDisconnectAll()
                        for i=#ctxConns,1,-1 do ctxConns[i]:Disconnect(); table.remove(ctxConns,i) end
                    end
                    local function closeCtx()
                        if not ctxOpen or not ctxMenu then return end
                        ctxOpen = false
                        ctxDisconnectAll()
                        if ctxBlocker and ctxBlocker.Parent then pcall(function() ctxBlocker:Destroy() end) end
                        ctxBlocker = nil
                        pcall(function() if ctxMenu then ctxMenu:Destroy() end end)
                        ctxMenu = nil
                        if Library._openKeybindCtxClose == closeCtx then Library._openKeybindCtxClose = nil end
                    end
                    local function openCtx()
                        if Library._openKeybindCtxClose and Library._openKeybindCtxClose ~= closeCtx then pcall(Library._openKeybindCtxClose) end
                        closeCtx()
                        if ctxMenu then pcall(function() ctxMenu:Destroy() end); ctxMenu=nil end
                        
                        local menuZBase = 12000
                        ctxBlocker = Create("TextButton", {AutoButtonColor = false, Modal = false, BackgroundTransparency = 1, Text = "", Size = UDim2.fromScale(1,1), Position = UDim2.fromOffset(0,0), ZIndex = menuZBase, Parent = RootGui})
                        table.insert(ctxConns, ctxBlocker.MouseButton1Click:Connect(function() closeCtx() end))
                        table.insert(ctxConns, ctxBlocker.MouseButton2Click:Connect(function() closeCtx() end))
                        table.insert(ctxConns, ctxBlocker.TouchTap:Connect(function() closeCtx() end))
                        
                        local textService = game:GetService("TextService")
                        local labelFont = Fonts.Medium
                        local labelSize = 12
                        local sidePad, vPad, gap, itemH = 10, 6, 2, 24
                        local function measure(text)
                            local sz = textService:GetTextSize(text or "", labelSize, labelFont, Vector2.new(1000, itemH))
                            return sz.X
                        end
                        local maxTextW = math.max(measure("Hold"), measure("Toggle"), measure("Always"))
                        local menuW = math.clamp(math.floor(maxTextW + (sidePad*2) + 24), 100, 160) -- Extra space for indicators
                        
                        ctxMenu = Create("Frame", {BackgroundColor3 = Theme.Bg, BackgroundTransparency = 0, BorderSizePixel = 0, Size = UDim2.fromOffset(menuW,0), ZIndex = menuZBase + 1, ClipsDescendants = true, Parent = RootGui}, {
                            Create("UICorner", {CornerRadius = UDim.new(0,6)}),
                            Create("UIStroke", {Color = Theme.Stroke, Thickness = 1, Transparency = 0.40})
                        })
                        local shadow = Create("ImageLabel", {BackgroundTransparency = 1, Image = "rbxassetid://4996891970", ImageColor3 = Theme.Bg, ImageTransparency = 0.92, Size = UDim2.fromScale(1,1), ZIndex = (ctxMenu.ZIndex or 1)-1, Parent = ctxMenu})
                        shadow.ScaleType = Enum.ScaleType.Slice; shadow.SliceCenter = Rect.new(20,20,280,280)
                        
                        local content = Create("Frame", {BackgroundTransparency = 1, Size = UDim2.new(1, -(sidePad*2), 1, -(vPad*2)), Position = UDim2.fromOffset(sidePad, vPad), ZIndex = ctxMenu.ZIndex + 1, Parent = ctxMenu}, {
                            Create("UIListLayout", {Padding = UDim.new(0,gap), SortOrder = Enum.SortOrder.LayoutOrder})
                        })
                        
                        local function createModeItem(modeText, isSelected)
                            local btn = Create("TextButton", {AutoButtonColor = false, BackgroundTransparency = 0, BackgroundColor3 = Theme.Bg, Size = UDim2.new(1,0,0,itemH), Text = "", ZIndex = content.ZIndex + 1, Parent = content}, {
                                Create("UICorner", {CornerRadius = UDim.new(0,4)}),
                                Create("UIPadding", {PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,8)})
                            })
                            local textLabel = Create("TextLabel", {BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Position = UDim2.fromOffset(0,0), Text = modeText, Font = labelFont, TextSize = labelSize, TextXAlignment = Enum.TextXAlignment.Left, TextColor3 = Theme.Text, Parent = btn})
                            -- Selection indicator (animated underline)
                            local underline = Create("Frame", {BackgroundColor3 = Theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0, isSelected and 1 or 0, 0, 1), AnchorPoint = Vector2.new(0,1), Position = UDim2.new(0,0,1,-1), Parent = btn})
                            if isSelected then
                                T(underline, 0.2, {Size = UDim2.new(0.8, 0, 0, 1)}):Play()
                            end
                            
                            btn.MouseEnter:Connect(function() T(btn,0.10,{BackgroundColor3 = Theme.Hover}):Play() end)
                            btn.MouseLeave:Connect(function() T(btn,0.10,{BackgroundColor3 = Theme.Bg}):Play() end)
                            btn.MouseButton1Click:Connect(function() 
                                if mode ~= modeText then
                                    mode = modeText  -- Set mode directly instead of calling SetMode
                                    setupKeybindListener()
                                    if mode == "Always" then
                                        isToggled = true
                                        updateToggleVisual()
                                        if type(cb) == "function" then
                                            pcall(cb, true, currentKey or currentInputType)
                                        end
                                    end
                                end
                                closeCtx() 
                            end)
                            return btn
                        end
                        
                        createModeItem("Hold", mode == "Hold")
                        createModeItem("Toggle", mode == "Toggle")
                        createModeItem("Always", mode == "Always")
                        
                        -- Position menu above the keybind button using colorpicker logic
                        local menuH = (itemH * 3) + (gap * 2) + (vPad * 2)
                        ctxMenu.Size = UDim2.fromOffset(menuW, menuH)
                        local btnAbs = keybindBtn.AbsolutePosition
                        local btnSize = keybindBtn.AbsoluteSize
                        local guiInset = game:GetService("GuiService"):GetGuiInset()
                        -- Position menu directly above the button, aligned to left edge
                        local px = btnAbs.X
                        local py = btnAbs.Y - menuH - 6 + guiInset.Y
                        ctxMenu.Position = UDim2.fromOffset(px, py)
                        
                        Library._openKeybindCtxClose = closeCtx
                        ctxOpen = true
                    end

                    -- Button events
                    keybindBtn.MouseButton1Click:Connect(function()
                        if isBinding then
                            -- If already binding, capture MouseButton1 as the keybind
                            currentKey = nil
                            currentInputType = Enum.UserInputType.MouseButton1
                            isBinding = false
                            if updateKeybindVisual then updateKeybindVisual() end
                            if disconnectAll then disconnectAll() end
                            if setupKeybindListener then setupKeybindListener() end
                        else
                            -- Start binding mode
                            startBinding()
                        end
                    end)
                    keybindBtn.MouseButton2Click:Connect(function()
                        if isBinding then
                            -- If binding, capture MouseButton2 as the keybind
                            currentKey = nil
                            currentInputType = Enum.UserInputType.MouseButton2
                            isBinding = false
                            if updateKeybindVisual then updateKeybindVisual() end
                            if disconnectAll then disconnectAll() end
                            if setupKeybindListener then setupKeybindListener() end
                        elseif not isBinding then  
                            -- Only open context menu if not currently binding
                            openCtx()
                        end
                    end)
                    
                    -- Public API
                    local KeybindToggle = { id = id }
                    local keybindId = nil -- Will be set after KeybindToggle is defined
                    
                    -- Helper function to safely update keybind tracking
                    local function updateKeybindTracking(updates)
                        if keybindId and Library._keybinds and Library._keybinds[keybindId] then
                            Library:_updateKeybind(keybindId, updates)
                        end
                    end
                    
                    -- Initialize
                    setupKeybindListener()
                    updateToggleVisual()
                    updateKeybindVisual()
                    
                    function KeybindToggle:GetKey()
                        return currentKey
                    end
                    
                    function KeybindToggle:SetKey(keyCode, silent)
                        if type(keyCode) == "string" then
                            local parsed = ParseKeyFromString(keyCode)
                            keyCode = parsed or keyCode
                        end
                        if typeof(keyCode) == "EnumItem" then
                            if keyCode.EnumType == Enum.KeyCode then
                                currentKey = keyCode
                                currentInputType = nil
                                if updateKeybindVisual then updateKeybindVisual() end
                                if not silent and setupKeybindListener then setupKeybindListener() end
                            elseif keyCode.EnumType == Enum.UserInputType and (keyCode == Enum.UserInputType.MouseButton1 or keyCode == Enum.UserInputType.MouseButton2) then
                                currentKey = nil
                                currentInputType = keyCode
                                if updateKeybindVisual then updateKeybindVisual() end
                                if not silent and setupKeybindListener then setupKeybindListener() end
                            end
                        end
                    end
                    
                    function KeybindToggle:GetToggle()
                        return isToggled
                    end
                    
                    function KeybindToggle:SetToggle(state, silent)
                        if mode == "Always" then return end
                        isToggled = state and true or false
                        updateToggleVisual()
                        
                        -- Update keybind list tracking
                        if updateKeybindTracking ~= nil then
                            local newActive
                            if mode == "Always" then
                                newActive = true
                            elseif mode == "Hold" then
                                newActive = false -- until pressed
                            elseif mode == "Toggle" then
                                newActive = keybindToggleState
                            end
                            updateKeybindTracking({ toggleEnabled = isToggled, active = newActive })
                        end
                        
                        if not silent and type(cb) == "function" then
                            pcall(cb, isToggled, currentKey)
                        end
                    end
                    
                    function KeybindToggle:GetMode()
                        return mode
                    end
                    
                    function KeybindToggle:SetMode(newMode, silent)
                        if newMode == "Toggle" or newMode == "Hold" or newMode == "Always" then
                            mode = newMode
                            if setupKeybindListener then setupKeybindListener() end
                            if mode == "Always" then
                                isToggled = true
                                if updateToggleVisual then updateToggleVisual() end
                                
                                -- Update keybind list tracking for Always mode
                                if updateKeybindTracking ~= nil then
                                    updateKeybindTracking({
                                        toggleEnabled = true,
                                        active = true
                                    })
                                end
                                
                                if not silent and type(cb) == "function" then
                                    pcall(cb, true, currentKey or currentInputType)
                                end
                            end
                        end
                    end
                    
                    function KeybindToggle:Set(options, silent)
                        if type(options) ~= "table" then return end
                        if options.Key then self:SetKey(options.Key, true) end
                        if options.Toggle ~= nil then self:SetToggle(options.Toggle, true) end
                        if options.Mode then self:SetMode(options.Mode, true) end
                        if not silent and type(cb) == "function" then
                            pcall(cb, isToggled, currentKey)
                        end
                    end
                    
                    function KeybindToggle:Get()
                        local activeState
                        if mode == "Always" then
                            activeState = true
                        elseif mode == "Hold" then
                            activeState = isToggled and isHolding or false
                        elseif mode == "Toggle" then
                            activeState = isToggled and keybindToggleState or false
                        end
                        return {
                            Key = currentKey or currentInputType,
                            Toggle = isToggled,
                            Mode = mode,
                            KeyName = getKeyName(currentKey, currentInputType),
                            Active = activeState
                        }
                    end
                    
                    function KeybindToggle:Destroy()
                        disconnectAll()
                        if row and row.Parent then pcall(function() row:Destroy() end) end
                    end
                    
                    -- Add to keybind list tracking system
                    local initialActive
                    if mode == "Always" then
                        initialActive = true
                    elseif mode == "Hold" then
                        initialActive = false
                    elseif mode == "Toggle" then
                        initialActive = keybindToggleState
                    end
                    keybindId = Library:_addKeybind(label, getKeyName(currentKey, currentInputType), "ToggleKeybind", {
                        active = initialActive,
                        toggleEnabled = isToggled,
                        showInList = true, -- Default added is fine; visibility is driven by toggle
                        keybindObject = KeybindToggle
                    })
                    KeybindToggle._keybindId = keybindId
                    
                    -- Register control
                    Library:_registerControl(KeybindToggle)
                    table.insert(Group._controls, KeybindToggle)
                    registerSearch(label)
                    return KeybindToggle
                end
                return Group
            end
            table.insert(Category._pages, Page)
            if not Category._selectedPage then Page:Select() end
            return Page
        end
        Category._btn = btn
        Category._label = lbl
        Category._indicator = catInd
        Category._icon = iconImg
        Category._container = catContainer
        table.insert(Window._categories, Category)
        if not Window._selectedCategory then Category:Select() end
        return Category
    end
    -- enhanced mobile toggle (gradient ring + hamburger->X + ripple + drag)
    local _mobileToggleSync
    if showMobileBtn then
        local accent = Theme.Accent
        local container = Create("Frame", {
            Name = "MobileToggleContainer",
            BackgroundTransparency = 1,
            Position = UDim2.new(1, -80, 0, 120),
            Size = UDim2.new(0, 70, 0, 70),
            ZIndex = 1,
            Parent = RootGui
        })

        local toggleFrame = Create("Frame", {
            Name = "MobileToggle",
            BackgroundColor3 = Theme.Bg,
            BorderSizePixel = 0,
            Position = UDim2.new(0, 10, 0, 10),
            Size = UDim2.new(0, 50, 0, 50),
            ClipsDescendants = false,
            ZIndex = 3,
            Parent = container
        })
        Create("UICorner", { CornerRadius = UDim.new(1, 0), Parent = toggleFrame })

        -- Soft shadow behind button
        local shadow = Create("ImageLabel", {
            Name = "Shadow",
            BackgroundTransparency = 1,
            AnchorPoint = Vector2.new(0.5, 0.5),
            Position = UDim2.new(0.5, 10, 0.5, 10),
            Size = UDim2.new(0, 66, 0, 66),
            Image = "rbxassetid://4996891970",
            ImageColor3 = Color3.fromRGB(0, 0, 0),
            ImageTransparency = 1,
            ScaleType = Enum.ScaleType.Slice,
            SliceCenter = Rect.new(20, 20, 280, 280),
            ZIndex = 2,
            Parent = container
        })

        -- Subtle internal gradient on the button for depth
        local fillGrad = Create("UIGradient", {
            Rotation = 90,
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0.00, Theme.Bg),
                ColorSequenceKeypoint.new(1.00, Theme.Button)
            }),
            Parent = toggleFrame
        })

        -- Button stroke
        local stroke = Create("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = accent, Thickness = 1.5, Transparency = 0.5, Parent = toggleFrame })

    -- Status dot (green/red) on the top-right of the button, with subtle outline and glow
    local status = Create("Frame", { Name = "StatusIndicator", BackgroundColor3 = Color3.fromRGB(255,85,85), BorderSizePixel = 0, Position = UDim2.new(1, -10, 0, 7), Size = UDim2.new(0, 8, 0, 8), ZIndex = 6, Parent = toggleFrame })
        Create("UICorner", { CornerRadius = UDim.new(1, 0), Parent = status })
    local statusStroke = Create("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = Theme.Bg, Thickness = 1, Transparency = 0, Parent = status })
    local statusGlow = Create("ImageLabel", { Name = "StatusGlow", Visible = false, BackgroundTransparency = 1, AnchorPoint = Vector2.new(0.5, 0.5), Position = UDim2.new(1, -10, 0, 7), Size = UDim2.new(0, 18, 0, 18), Image = "rbxassetid://4996891970", ImageColor3 = Color3.fromRGB(255,85,85), ImageTransparency = 1, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(20,20,280,280), ZIndex = 5, Parent = toggleFrame })

        -- Press/click surface
        local button = Create("TextButton", { Name = "ToggleButton", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), Text = "", AutoButtonColor = false, ZIndex = 7, Parent = toggleFrame })

        -- Hamburger icon
        local icon = Create("Frame", { Name = "Icon", BackgroundTransparency = 1, AnchorPoint = Vector2.new(0.5, 0.5), Position = UDim2.new(0.5, 0, 0.5, 0), Size = UDim2.new(0, 24, 0, 18), ZIndex = 7, Parent = toggleFrame })
        local function makeLine(name)
            local line = Create("Frame", { Name = name, BackgroundColor3 = Theme.Text, BorderSizePixel = 0, AnchorPoint = Vector2.new(0.5, 0.5), Size = UDim2.new(0, 22, 0, 2), Position = UDim2.new(0.5, 0, 0.5, 0), ZIndex = 7, Parent = icon })
            Create("UICorner", { CornerRadius = UDim.new(1, 0), Parent = line })
            return line
        end
        local lineTop = makeLine("Top"); lineTop.Position = UDim2.new(0.5, 0, 0.0, 0)
        local lineMid = makeLine("Mid"); lineMid.Position = UDim2.new(0.5, 0, 0.5, 0)
        local lineBot = makeLine("Bot"); lineBot.Position = UDim2.new(0.5, 0, 1.0, 0)

        -- Utilities
        local function makeRipple()
            local r = Create("Frame", { BackgroundColor3 = accent, BackgroundTransparency = 0.3, AnchorPoint = Vector2.new(0.5, 0.5), Position = UDim2.new(0.5, 0, 0.5, 0), Size = UDim2.new(0, 0, 0, 0), ZIndex = 6, Parent = toggleFrame })
            Create("UICorner", { CornerRadius = UDim.new(1, 0), Parent = r })
            local max = math.max(toggleFrame.AbsoluteSize.X, toggleFrame.AbsoluteSize.Y) * 1.6
            T(r, 0.4, { Size = UDim2.new(0, max, 0, max), BackgroundTransparency = 1 }):Play()
            task.delay(0.42, function() if r and r.Parent then r:Destroy() end end)
        end

        local function setIcon(open)
            if open then
                -- Hamburger -> X
                T(lineTop, 0.18, { Rotation = 45, Position = UDim2.new(0.5, 0, 0.5, 0) }):Play()
                T(lineBot, 0.18, { Rotation = -45, Position = UDim2.new(0.5, 0, 0.5, 0) }):Play()
                T(lineMid, 0.12, { BackgroundTransparency = 1 }):Play()
            else
                -- X -> Hamburger
                T(lineTop, 0.18, { Rotation = 0, Position = UDim2.new(0.5, 0, 0.0, 0) }):Play()
                T(lineBot, 0.18, { Rotation = 0, Position = UDim2.new(0.5, 0, 1.0, 0) }):Play()
                T(lineMid, 0.12, { BackgroundTransparency = 0 }):Play()
            end
        end

    local open = root and root.Visible or true
    local function applyState(animated)
            local good = Theme.Good or Color3.fromRGB(85, 255, 127)
            local bad = Theme.Bad or Color3.fromRGB(255, 85, 85)
            status.BackgroundColor3 = open and good or bad
            statusGlow.ImageColor3 = open and good or bad
            if animated then
                -- Background and stroke soften/harden
                T(toggleFrame, 0.20, { BackgroundColor3 = open and Theme.Panel or Theme.Bg }):Play()
                T(stroke, 0.20, { Transparency = open and 0.25 or 0.5 }):Play()
                -- Update gradient for a subtle light-from-top effect
                local seq = open and ColorSequence.new({
                    ColorSequenceKeypoint.new(0.00, Theme.Panel),
                    ColorSequenceKeypoint.new(1.00, Theme.Bg)
                }) or ColorSequence.new({
                    ColorSequenceKeypoint.new(0.00, Theme.Bg),
                    ColorSequenceKeypoint.new(1.00, Theme.Button)
                })
                fillGrad.Color = seq
            else
                toggleFrame.BackgroundColor3 = open and Theme.Panel or Theme.Bg
                stroke.Transparency = open and 0.25 or 0.5
                fillGrad.Color = open and ColorSequence.new({
                    ColorSequenceKeypoint.new(0.00, Theme.Panel),
                    ColorSequenceKeypoint.new(1.00, Theme.Bg)
                }) or ColorSequence.new({
                    ColorSequenceKeypoint.new(0.00, Theme.Bg),
                    ColorSequenceKeypoint.new(1.00, Theme.Button)
                })
            end
            setIcon(open)
        end
        applyState(false)
        -- Sync function for library keybind
        _mobileToggleSync = function(newVisible)
            open = newVisible
            if root then root.Visible = open end
            applyState(true)
        end

        -- Hover feedback on desktop
        button.MouseEnter:Connect(function()
            if UserInputService.KeyboardEnabled then
                T(toggleFrame, 0.12, { Size = UDim2.new(0, 52, 0, 52), Position = UDim2.new(0, 9, 0, 9) }):Play()
            end
        end)
        button.MouseLeave:Connect(function()
            if UserInputService.KeyboardEnabled and not UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
                T(toggleFrame, 0.12, { Size = UDim2.new(0, 50, 0, 50), Position = UDim2.new(0, 10, 0, 10) }):Play()
            end
        end)

        -- Input / dragging
        local holding, dragging = false, false
        local pressPos, dragOffset, pressTime
        local DRAG_THRESHOLD = 6

        local function getMouseGuiPos(input)
            -- Normalize to the same GUI coordinate space used by RootGui (IgnoreGuiInset = true)
            local ok, inset = pcall(function()
                return game:GetService("GuiService"):GetGuiInset()
            end)
            local pos
            if input and input.UserInputType == Enum.UserInputType.Touch then
                pos = Vector2.new(input.Position.X, input.Position.Y)
            else
                pos = UserInputService:GetMouseLocation()
            end
            if ok and typeof(inset) == "Vector2" then
                pos = Vector2.new(pos.X, pos.Y - inset.Y)
            end
            return pos
        end

        local function beginPress(inp)
            holding = true; dragging = false; pressTime = tick()
            local mouse = getMouseGuiPos(inp)
            pressPos = Vector2.new(mouse.X, mouse.Y)
            local abs = container.AbsolutePosition
            dragOffset = Vector2.new(mouse.X - abs.X, mouse.Y - abs.Y)
            T(toggleFrame, 0.10, { Size = UDim2.new(0, 48, 0, 48), Position = UDim2.new(0, 11, 0, 11) }):Play()
            makeRipple()
        end

        local function endPress()
            local wasTap = holding and (tick() - (pressTime or tick())) < 0.35 and not dragging
            holding = false
            T(toggleFrame, 0.16, { Size = UDim2.new(0, 50, 0, 50), Position = UDim2.new(0, 10, 0, 10) }):Play()
            if wasTap then
                open = not open
                if _mobileToggleSync then _mobileToggleSync(open) else if root then root.Visible = open end end
                applyState(true)
            end
            dragging = false
            pressPos = nil; dragOffset = nil
        end

        button.MouseButton1Down:Connect(function() beginPress() end)
        button.InputBegan:Connect(function(inp)
            if inp.UserInputType == Enum.UserInputType.Touch then beginPress(inp) end
        end)
        button.MouseButton1Up:Connect(endPress)
        UserInputService.InputEnded:Connect(function(inp)
            if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
                if holding then endPress() end
            end
        end)

        UserInputService.InputChanged:Connect(function(inp)
            if holding and pressPos and (inp.UserInputType == Enum.UserInputType.MouseMovement or inp.UserInputType == Enum.UserInputType.Touch) then
                local mouse = getMouseGuiPos(inp)
                if not dragging then
                    local dx = mouse.X - pressPos.X
                    local dy = mouse.Y - pressPos.Y
                    if (dx*dx + dy*dy) > (DRAG_THRESHOLD*DRAG_THRESHOLD) then
                        dragging = true
                    end
                end
                if dragging and dragOffset then
                    local viewport = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920,1080)
                    local newX = mouse.X - dragOffset.X
                    local newY = mouse.Y - dragOffset.Y
                    newX = math.max(0, math.min(viewport.X - container.AbsoluteSize.X, newX))
                    newY = math.max(0, math.min(viewport.Y - container.AbsoluteSize.Y, newY))
                    container.Position = UDim2.new(0, newX, 0, newY)
                end
            end
        end)
    end
    -- global library toggle keybind (default RightShift), syncs with mobile toggle
    do
        Library._libraryKeybind = Library._libraryKeybind or Enum.KeyCode.RightShift
        Library._rootFrame = root
        Library._mobileToggleSync = _mobileToggleSync
        if Library._libraryKeyConn then
            pcall(function() Library._libraryKeyConn:Disconnect() end)
            Library._libraryKeyConn = nil
        end
        local function syncToggle(newVisible)
            if root then root.Visible = newVisible end
            if Library._mobileToggleSync and typeof(Library._mobileToggleSync) == "function" then
                Library._mobileToggleSync(newVisible)
            end
        end
        Library._libraryKeyConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if input.UserInputType == Enum.UserInputType.Keyboard then
                local key = Library._libraryKeybind or Enum.KeyCode.RightShift
                if input.KeyCode == key and Library._rootFrame and Library._rootFrame.Parent then
                    local newVisible = not Library._rootFrame.Visible
                    syncToggle(newVisible)
                end
            end
        end)
        Library._syncToggle = syncToggle
    end
    
    Window.AddTab = Window.AddCategory
    -- enhanced search with fuzzy matching and ranking
    function Window:Search(term, suppressHighlight)
        term = tostring(term or ""):lower():gsub("%s+", " "):gsub("^%s*(.-)%s*$", "%1") -- trim whitespace
        if term == "" then return end
        
        local matches = {}
        local exactMatches = {}
        local fuzzyMatches = {}
        
        for _, entry in ipairs(Library._searchEntries) do
            local text = entry.textLower
            local score = 0
            
            -- Exact matches (highest priority)
            if text == term then
                score = 1000
                exactMatches[#exactMatches + 1] = {entry = entry, score = score}
            -- Starts with term (high priority)  
            elseif text:find("^" .. term:gsub("[%-%^%$%(%)%%%.%[%]%*%+%?]", "%%%1")) then
                score = 800 + (100 - #text) -- shorter matches rank higher
                exactMatches[#exactMatches + 1] = {entry = entry, score = score}
            -- Contains term (medium priority)
            elseif text:find(term, 1, true) then
                score = 600 + (100 - #text)
                matches[#matches + 1] = {entry = entry, score = score}
            else
                -- Fuzzy matching - check if all characters of term exist in order
                local termChars = {}
                for i = 1, #term do termChars[i] = term:sub(i,i) end
                
                local textPos = 1
                local matchedChars = 0
                for _, char in ipairs(termChars) do
                    local found = text:find(char, textPos, true)
                    if found then
                        textPos = found + 1
                        matchedChars = matchedChars + 1
                    else
                        break
                    end
                end
                
                if matchedChars == #termChars and #termChars >= 3 then -- min 3 chars for fuzzy
                    score = 300 + matchedChars * 10
                    fuzzyMatches[#fuzzyMatches + 1] = {entry = entry, score = score}
                end
            end
        end
        
        -- Combine and sort all matches by score
        local allMatches = {}
        for _, match in ipairs(exactMatches) do allMatches[#allMatches + 1] = match end
        for _, match in ipairs(matches) do allMatches[#allMatches + 1] = match end  
        for _, match in ipairs(fuzzyMatches) do allMatches[#allMatches + 1] = match end
        
        table.sort(allMatches, function(a, b) return a.score > b.score end)
        
        local match = allMatches[1] and allMatches[1].entry
        if not match then return nil end
        -- select category & page
        if Window._selectedCategory ~= match.category then match.category:Select() end
        if match.category._selectedPage ~= match.page then match.page:Select() end
        -- defer scroll/highlight until UI is visible
        task.defer(function()
            if not match.groupFrame or not match.groupFrame.Parent then return end
            local col = match.groupFrame.Parent
            if col and col:IsA("ScrollingFrame") then
                local absPos = match.groupFrame.AbsolutePosition.Y
                local colAbs = col.AbsolutePosition.Y
                local offset = absPos - colAbs - 6
                if offset < 0 then offset = 0 end
                col.CanvasPosition = Vector2.new(0, offset)
            end
            if not suppressHighlight then
                -- single outline pulse on search call without suppression
                local stroke = nil
                for _, child in ipairs(match.groupFrame:GetChildren()) do if child:IsA("UIStroke") then stroke = child break end end
                if stroke then
                    local origColor, origThick = stroke.Color, stroke.Thickness
                    stroke.Color = Theme.Accent
                    T(stroke,0.15,{Thickness = 3}):Play()
                    task.delay(0.45, function()
                        if stroke and stroke.Parent then
                            T(stroke,0.30,{Thickness = origThick, Color = origColor}):Play()
                        end
                    end)
                end
            end
        end)
        return match
    end
    
    -- Add Config functions to Window object
    Window.LibraryName = libraryName
    Window.SaveConfig = function(name)
        local safe = sanitize(name or "")
        if safe == "" or safe:lower() == "__meta" then return false end
        local ok = Config.Save(safe, Library:_getSnapshot())
        if ok then pcall(function() Config.RecordSave(name) end) end
        return ok
    end
    Window.LoadConfig = function(name)
        local safe = sanitize(name or "")
        if safe == "" or safe:lower() == "__meta" then return end
        local data = Config.Load(safe)
        for id, value in pairs(data) do Library:_setValue(id, value, true) end
    end
    Window.ListConfigs = function() return Config.List() end
    Window.DeleteConfig = function(name)
        local safe = sanitize(name or "")
        if safe == "" or safe:lower() == "__meta" then return end
        Config.Delete(safe)
        pcall(function() Config.ClearMeta(safe) end)
    end
    -- Build a Configs UI inside a provided Group
    Window.AddConfigSystem = function(self, group, opts)
        opts = opts or {}
        if not group or type(group) ~= "table" or not group.AddDropdown then return nil end
        local cfgLabel = tostring(opts.Label or "Configs")
        local namePlaceholder = tostring(opts.Placeholder or "MyConfig Name")

        -- Row 1: Dropdown
        local dd = group:AddDropdown({
            Name = cfgLabel,
            Options = Window.ListConfigs(),
            Default = nil,
            Multi = false,
            Search = true,
            Placeholder = "Select a config"
        })
        local function refreshList()
            local list = Window.ListConfigs() or {}
            dd:SetOptions(list)
        end

    -- Row 2: Name textbox
    local nameBox = group:AddTextbox({ Name = "Config Name", Placeholder = namePlaceholder, Default = "" })

        -- Row 3: Buttons (Create/Save/Load/Delete)
        local createBtn = group:AddButton({ Name = "Create", Compact = true, Callback = function()
            -- Always read live textbox value
            local raw = nameBox and nameBox.Get and nameBox:Get() or ""
            if type(raw) == "string" and raw:lower() == "__meta" then return end
            if not raw or raw == "" then return end
            local safe = sanitize(raw)
            if safe == "" or safe:lower() == "__meta" then return end
            if Window.SaveConfig(safe) then
                refreshList()
                dd:Set(safe, true)
                -- reflect stored name back into textbox so it matches the list
                if nameBox and nameBox.Set then nameBox:Set(safe, true) end
            end
        end })
        local saveBtn = group:AddButton({ Name = "Save", Compact = true, Callback = function()
            local raw = dd:Get() or (nameBox and nameBox.Get and nameBox:Get())
            if type(raw) == "string" and raw:lower() == "__meta" then return end
            if not raw or raw == "" then return end
            local safe = sanitize(raw)
            if safe == "" or safe:lower() == "__meta" then return end
            if Window.SaveConfig(safe) then
                refreshList()
                dd:Set(safe, true)
                if nameBox and nameBox.Set then nameBox:Set(safe, true) end
            end
        end })
        local loadBtn = group:AddButton({ Name = "Load", Compact = true, Callback = function()
            local raw = dd:Get() or (nameBox and nameBox.Get and nameBox:Get())
            if type(raw) == "string" and raw:lower() == "__meta" then return end
            if not raw or raw == "" then return end
            local safe = sanitize(raw)
            Window.LoadConfig(safe)
            -- keep UI in sync with sanitized name
            dd:Set(safe, true)
            if nameBox and nameBox.Set then nameBox:Set(safe, true) end
        end })
        local deleteBtn = group:AddButton({ Name = "Delete", Compact = true, Callback = function()
            local raw = dd:Get() or (nameBox and nameBox.Get and nameBox:Get())
            if type(raw) == "string" and raw:lower() == "__meta" then return end
            if not raw or raw == "" then return end
            local safe = sanitize(raw)
            Window.DeleteConfig(safe)
            refreshList()
            dd:Set(nil, true)
            if nameBox and nameBox.Set then nameBox:Set("", true) end
        end })

        -- Row 4: Refresh List (move above auto-load)
        local autoToggle -- forward declare for callback below
        local refreshBtn = group:AddButton({ Name = "Refresh List", Callback = function()
            refreshList()
            -- Re-sync autoload state to current selection after refresh
            local raw = dd:Get()
            local safe = raw and sanitize(raw) or nil
            local on = false
            pcall(function() on = Config.GetAutoLoad(safe) end)
            if autoToggle and autoToggle.Set then autoToggle:Set(on, true) end
        end, Compact = true })

        -- Row 5: Auto-load toggle for currently selected config
        autoToggle = group:AddToggle({ Name = "Auto Load Config", Default = false, Callback = function(on)
            local raw = dd:Get()
            local safe = raw and sanitize(raw) or nil
            if not safe or safe == "" then return end
            pcall(function() Config.SetAutoLoad(safe, on) end)
        end })

        -- Keep autoload toggle in sync when selection changes
        dd:OnOpen(function()
            -- no-op, but ensures dd exists
        end)
        -- There isn't a direct OnChanged, so wrap Set and call original
        local _ddSet = dd.Set
        function dd:Set(v, silent)
            _ddSet(self, v, silent)
            local raw = self:Get()
            local safe = raw and sanitize(raw) or nil
            local on = false
            pcall(function() on = Config.GetAutoLoad(safe) end)
            if autoToggle and autoToggle.Set then autoToggle:Set(on, true) end
            if nameBox and nameBox.Set then nameBox:Set(safe or "", true) end
        end

        -- Initialize autoload state to current selection (if any)
        do
            local cur = dd:Get()
            if cur and cur ~= "" then
                local on = false
                pcall(function() on = Config.GetAutoLoad(cur) end)
                autoToggle:Set(on, true)
            end
        end

    return { Dropdown = dd, NameBox = nameBox, Create = createBtn, Save = saveBtn, Load = loadBtn, Delete = deleteBtn, Refresh = refreshBtn, AutoToggle = autoToggle }
    end
    
    -- Auto-load most recent autoload-marked config for this place, if any
    task.spawn(function()
        -- slight delay to let controls register so _setValue calls propagate
        task.wait(0.25)
        local toLoad = nil
        pcall(function() toLoad = Config.MostRecentAutoLoad() end)
        if toLoad and type(toLoad) == "string" and #toLoad > 0 then
            pcall(function() Window.LoadConfig(toLoad) end)
        end
    end)

    -- Create keybind list immediately when library is created
    task.spawn(function()
        task.wait(1) -- Small delay to ensure everything is properly initialized
        if Library._keybindListVisible then
            Library:_createKeybindList()
        end
    end)
    
    -- expose this instance as the active window so Library-level helpers can forward
    self._activeWindow = Window
    return Window
end
function Library:MakeWindow(o) return self:CreateLibrary(o) end
function Library:NewWindow(o) return self:CreateLibrary(o) end
function Library:SetTheme(t) for k, v in pairs(t or {}) do if Theme[k] ~= nil then Theme[k] = v end end end
function Library:SetFonts(f) for k, v in pairs(f or {}) do if Fonts[k] ~= nil then Fonts[k] = v end end end
function Library:GetFlag(name)
    return (self.Flags and self.Flags[name]) or self._controls[name]
end
function Library:SetFlag(name, value, silent)
    local c = (self.Flags and self.Flags[name]) or self._controls[name]
    if c and c.Set then c:Set(value, silent) end
end

-- Set or change the library-wide toggle keybind
-- Accepts:
--  - Enum.KeyCode (preferred)
--  - string name of key (e.g., "RightShift", "E")
--  - a control/flag object with a Value property (e.g., Library.Flags.MyKeybind.Value)
function Library:LibraryKeybind(key)
    local resolve
    if typeof(key) == "EnumItem" and key.EnumType == Enum.KeyCode then
        resolve = key
    elseif typeof(key) == "string" then
        resolve = Enum.KeyCode[key] or ParseKeyFromString(key)
    elseif type(key) == "table" and key.Value then
        local v = key.Value
        if typeof(v) == "EnumItem" and v.EnumType == Enum.KeyCode then
            resolve = v
        elseif typeof(v) == "string" then
            resolve = Enum.KeyCode[v] or ParseKeyFromString(v)
        end
    end
    resolve = resolve or Enum.KeyCode.RightShift
    self._libraryKeybind = resolve
    -- Rebuild connection if needed
    if self._libraryKeyConn then
        pcall(function() self._libraryKeyConn:Disconnect() end)
        self._libraryKeyConn = nil
    end
    local function syncToggle(newVisible)
        if self._rootFrame then self._rootFrame.Visible = newVisible end
        if self._mobileToggleSync and typeof(self._mobileToggleSync) == "function" then
            self._mobileToggleSync(newVisible)
        end
    end
    self._libraryKeyConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.Keyboard then
            local k = self._libraryKeybind or Enum.KeyCode.RightShift
            if input.KeyCode == k and self._rootFrame and self._rootFrame.Parent then
                local newVisible = not self._rootFrame.Visible
                syncToggle(newVisible)
            end
        end
    end)
    self._syncToggle = syncToggle
end

-- Convenience proxy: allow Library:AddConfigSystem(group, opts)
function Library:AddConfigSystem(group, opts)
    if self and self._activeWindow and self._activeWindow.AddConfigSystem then
        return self._activeWindow:AddConfigSystem(group, opts)
    end
    return nil
end

return Library
